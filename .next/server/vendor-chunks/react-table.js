/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-table";
exports.ids = ["vendor-chunks/react-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-table/dist/react-table.development.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-table/dist/react-table.development.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function(global, factory) {\n     true ? factory(exports, __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\")) : 0;\n})(this, function(exports1, React) {\n    \"use strict\";\n    React = React && Object.prototype.hasOwnProperty.call(React, \"default\") ? React[\"default\"] : React;\n    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n        try {\n            var info = gen[key](arg);\n            var value = info.value;\n        } catch (error) {\n            reject(error);\n            return;\n        }\n        if (info.done) {\n            resolve(value);\n        } else {\n            Promise.resolve(value).then(_next, _throw);\n        }\n    }\n    function _asyncToGenerator(fn) {\n        return function() {\n            var self1 = this, args = arguments;\n            return new Promise(function(resolve, reject) {\n                var gen = fn.apply(self1, args);\n                function _next(value) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                }\n                function _throw(err) {\n                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                }\n                _next(undefined);\n            });\n        };\n    }\n    function _extends() {\n        _extends = Object.assign || function(target) {\n            for(var i = 1; i < arguments.length; i++){\n                var source = arguments[i];\n                for(var key in source){\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n            return target;\n        };\n        return _extends.apply(this, arguments);\n    }\n    function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n        for(i = 0; i < sourceKeys.length; i++){\n            key = sourceKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            target[key] = source[key];\n        }\n        return target;\n    }\n    function _toPrimitive(input, hint) {\n        if (typeof input !== \"object\" || input === null) return input;\n        var prim = input[Symbol.toPrimitive];\n        if (prim !== undefined) {\n            var res = prim.call(input, hint || \"default\");\n            if (typeof res !== \"object\") return res;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (hint === \"string\" ? String : Number)(input);\n    }\n    function _toPropertyKey(arg) {\n        var key = _toPrimitive(arg, \"string\");\n        return typeof key === \"symbol\" ? key : String(key);\n    }\n    var renderErr = \"Renderer Error ☝️\";\n    var actions = {\n        init: \"init\"\n    };\n    var defaultRenderer = function defaultRenderer(_ref) {\n        var _ref$value = _ref.value, value = _ref$value === void 0 ? \"\" : _ref$value;\n        return value;\n    };\n    var emptyRenderer = function emptyRenderer() {\n        return React.createElement(React.Fragment, null, \"\\xa0\");\n    };\n    var defaultColumn = {\n        Cell: defaultRenderer,\n        width: 150,\n        minWidth: 0,\n        maxWidth: Number.MAX_SAFE_INTEGER\n    };\n    function mergeProps() {\n        for(var _len = arguments.length, propList = new Array(_len), _key = 0; _key < _len; _key++){\n            propList[_key] = arguments[_key];\n        }\n        return propList.reduce(function(props, next) {\n            var style = next.style, className = next.className, rest = _objectWithoutPropertiesLoose(next, [\n                \"style\",\n                \"className\"\n            ]);\n            props = _extends({}, props, {}, rest);\n            if (style) {\n                props.style = props.style ? _extends({}, props.style || {}, {}, style || {}) : style;\n            }\n            if (className) {\n                props.className = props.className ? props.className + \" \" + className : className;\n            }\n            if (props.className === \"\") {\n                delete props.className;\n            }\n            return props;\n        }, {});\n    }\n    function handlePropGetter(prevProps, userProps, meta) {\n        // Handle a lambda, pass it the previous props\n        if (typeof userProps === \"function\") {\n            return handlePropGetter({}, userProps(prevProps, meta));\n        } // Handle an array, merge each item as separate props\n        if (Array.isArray(userProps)) {\n            return mergeProps.apply(void 0, [\n                prevProps\n            ].concat(userProps));\n        } // Handle an object by default, merge the two objects\n        return mergeProps(prevProps, userProps);\n    }\n    var makePropGetter = function makePropGetter(hooks, meta) {\n        if (meta === void 0) {\n            meta = {};\n        }\n        return function(userProps) {\n            if (userProps === void 0) {\n                userProps = {};\n            }\n            return [].concat(hooks, [\n                userProps\n            ]).reduce(function(prev, next) {\n                return handlePropGetter(prev, next, _extends({}, meta, {\n                    userProps: userProps\n                }));\n            }, {});\n        };\n    };\n    var reduceHooks = function reduceHooks(hooks, initial, meta, allowUndefined) {\n        if (meta === void 0) {\n            meta = {};\n        }\n        return hooks.reduce(function(prev, next) {\n            var nextValue = next(prev, meta);\n            {\n                if (!allowUndefined && typeof nextValue === \"undefined\") {\n                    console.info(next);\n                    throw new Error(\"React Table: A reducer hook ☝️ just returned undefined! This is not allowed.\");\n                }\n            }\n            return nextValue;\n        }, initial);\n    };\n    var loopHooks = function loopHooks(hooks, context, meta) {\n        if (meta === void 0) {\n            meta = {};\n        }\n        return hooks.forEach(function(hook) {\n            var nextValue = hook(context, meta);\n            {\n                if (typeof nextValue !== \"undefined\") {\n                    console.info(hook, nextValue);\n                    throw new Error(\"React Table: A loop-type hook ☝️ just returned a value! This is not allowed.\");\n                }\n            }\n        });\n    };\n    function ensurePluginOrder(plugins, befores, pluginName, afters) {\n        if (afters) {\n            throw new Error('Defining plugins in the \"after\" section of ensurePluginOrder is no longer supported (see plugin ' + pluginName + \")\");\n        }\n        var pluginIndex = plugins.findIndex(function(plugin) {\n            return plugin.pluginName === pluginName;\n        });\n        if (pluginIndex === -1) {\n            {\n                throw new Error('The plugin \"' + pluginName + \"\\\" was not found in the plugin list!\\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\\n\\n  \" + pluginName + \".pluginName = '\" + pluginName + \"'\\n\");\n            }\n        }\n        befores.forEach(function(before) {\n            var beforeIndex = plugins.findIndex(function(plugin) {\n                return plugin.pluginName === before;\n            });\n            if (beforeIndex > -1 && beforeIndex > pluginIndex) {\n                {\n                    throw new Error(\"React Table: The \" + pluginName + \" plugin hook must be placed after the \" + before + \" plugin hook!\");\n                }\n            }\n        });\n    }\n    function functionalUpdate(updater, old) {\n        return typeof updater === \"function\" ? updater(old) : updater;\n    }\n    function useGetLatest(obj) {\n        var ref = React.useRef();\n        ref.current = obj;\n        return React.useCallback(function() {\n            return ref.current;\n        }, []);\n    } // SSR has issues with useLayoutEffect still, so use useEffect during SSR\n    var safeUseLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\n    function useMountedLayoutEffect(fn, deps) {\n        var mountedRef = React.useRef(false);\n        safeUseLayoutEffect(function() {\n            if (mountedRef.current) {\n                fn();\n            }\n            mountedRef.current = true; // eslint-disable-next-line\n        }, deps);\n    }\n    function useAsyncDebounce(defaultFn, defaultWait) {\n        if (defaultWait === void 0) {\n            defaultWait = 0;\n        }\n        var debounceRef = React.useRef({});\n        var getDefaultFn = useGetLatest(defaultFn);\n        var getDefaultWait = useGetLatest(defaultWait);\n        return React.useCallback(/*#__PURE__*/ function() {\n            var _ref2 = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2() {\n                var _len2, args, _key2, _args2 = arguments;\n                return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while(1){\n                        switch(_context2.prev = _context2.next){\n                            case 0:\n                                for(_len2 = _args2.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                                    args[_key2] = _args2[_key2];\n                                }\n                                if (!debounceRef.current.promise) {\n                                    debounceRef.current.promise = new Promise(function(resolve, reject) {\n                                        debounceRef.current.resolve = resolve;\n                                        debounceRef.current.reject = reject;\n                                    });\n                                }\n                                if (debounceRef.current.timeout) {\n                                    clearTimeout(debounceRef.current.timeout);\n                                }\n                                debounceRef.current.timeout = setTimeout(/*#__PURE__*/ _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee() {\n                                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                                        while(1){\n                                            switch(_context.prev = _context.next){\n                                                case 0:\n                                                    delete debounceRef.current.timeout;\n                                                    _context.prev = 1;\n                                                    _context.t0 = debounceRef.current;\n                                                    _context.next = 5;\n                                                    return getDefaultFn().apply(void 0, args);\n                                                case 5:\n                                                    _context.t1 = _context.sent;\n                                                    _context.t0.resolve.call(_context.t0, _context.t1);\n                                                    _context.next = 12;\n                                                    break;\n                                                case 9:\n                                                    _context.prev = 9;\n                                                    _context.t2 = _context[\"catch\"](1);\n                                                    debounceRef.current.reject(_context.t2);\n                                                case 12:\n                                                    _context.prev = 12;\n                                                    delete debounceRef.current.promise;\n                                                    return _context.finish(12);\n                                                case 15:\n                                                case \"end\":\n                                                    return _context.stop();\n                                            }\n                                        }\n                                    }, _callee, null, [\n                                        [\n                                            1,\n                                            9,\n                                            12,\n                                            15\n                                        ]\n                                    ]);\n                                })), getDefaultWait());\n                                return _context2.abrupt(\"return\", debounceRef.current.promise);\n                            case 5:\n                            case \"end\":\n                                return _context2.stop();\n                        }\n                    }\n                }, _callee2);\n            }));\n            return function() {\n                return _ref2.apply(this, arguments);\n            };\n        }(), [\n            getDefaultFn,\n            getDefaultWait\n        ]);\n    }\n    function makeRenderer(instance, column, meta) {\n        if (meta === void 0) {\n            meta = {};\n        }\n        return function(type, userProps) {\n            if (userProps === void 0) {\n                userProps = {};\n            }\n            var Comp = typeof type === \"string\" ? column[type] : type;\n            if (typeof Comp === \"undefined\") {\n                console.info(column);\n                throw new Error(renderErr);\n            }\n            return flexRender(Comp, _extends({}, instance, {\n                column: column\n            }, meta, {}, userProps));\n        };\n    }\n    function flexRender(Comp, props) {\n        return isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;\n    }\n    function isReactComponent(component) {\n        return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n    }\n    function isClassComponent(component) {\n        return typeof component === \"function\" && function() {\n            var proto = Object.getPrototypeOf(component);\n            return proto.prototype && proto.prototype.isReactComponent;\n        }();\n    }\n    function isExoticComponent(component) {\n        return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n            \"react.memo\",\n            \"react.forward_ref\"\n        ].includes(component.$$typeof.description);\n    }\n    function linkColumnStructure(columns, parent, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        return columns.map(function(column) {\n            column = _extends({}, column, {\n                parent: parent,\n                depth: depth\n            });\n            assignColumnAccessor(column);\n            if (column.columns) {\n                column.columns = linkColumnStructure(column.columns, column, depth + 1);\n            }\n            return column;\n        });\n    }\n    function flattenColumns(columns) {\n        return flattenBy(columns, \"columns\");\n    }\n    function assignColumnAccessor(column) {\n        // First check for string accessor\n        var id = column.id, accessor = column.accessor, Header = column.Header;\n        if (typeof accessor === \"string\") {\n            id = id || accessor;\n            var accessorPath = accessor.split(\".\");\n            accessor = function accessor(row) {\n                return getBy(row, accessorPath);\n            };\n        }\n        if (!id && typeof Header === \"string\" && Header) {\n            id = Header;\n        }\n        if (!id && column.columns) {\n            console.error(column);\n            throw new Error('A column ID (or unique \"Header\" value) is required!');\n        }\n        if (!id) {\n            console.error(column);\n            throw new Error(\"A column ID (or string accessor) is required!\");\n        }\n        Object.assign(column, {\n            id: id,\n            accessor: accessor\n        });\n        return column;\n    }\n    function decorateColumn(column, userDefaultColumn) {\n        if (!userDefaultColumn) {\n            throw new Error();\n        }\n        Object.assign(column, _extends({\n            // Make sure there is a fallback header, just in case\n            Header: emptyRenderer,\n            Footer: emptyRenderer\n        }, defaultColumn, {}, userDefaultColumn, {}, column));\n        Object.assign(column, {\n            originalWidth: column.width\n        });\n        return column;\n    } // Build the header groups from the bottom up\n    function makeHeaderGroups(allColumns, defaultColumn, additionalHeaderProperties) {\n        if (additionalHeaderProperties === void 0) {\n            additionalHeaderProperties = function additionalHeaderProperties() {\n                return {};\n            };\n        }\n        var headerGroups = [];\n        var scanColumns = allColumns;\n        var uid = 0;\n        var getUID = function getUID() {\n            return uid++;\n        };\n        var _loop = function _loop() {\n            // The header group we are creating\n            var headerGroup = {\n                headers: []\n            }; // The parent columns we're going to scan next\n            var parentColumns = [];\n            var hasParents = scanColumns.some(function(d) {\n                return d.parent;\n            }); // Scan each column for parents\n            scanColumns.forEach(function(column) {\n                // What is the latest (last) parent column?\n                var latestParentColumn = [].concat(parentColumns).reverse()[0];\n                var newParent;\n                if (hasParents) {\n                    // If the column has a parent, add it if necessary\n                    if (column.parent) {\n                        newParent = _extends({}, column.parent, {\n                            originalId: column.parent.id,\n                            id: column.parent.id + \"_\" + getUID(),\n                            headers: [\n                                column\n                            ]\n                        }, additionalHeaderProperties(column));\n                    } else {\n                        // If other columns have parents, we'll need to add a place holder if necessary\n                        var originalId = column.id + \"_placeholder\";\n                        newParent = decorateColumn(_extends({\n                            originalId: originalId,\n                            id: column.id + \"_placeholder_\" + getUID(),\n                            placeholderOf: column,\n                            headers: [\n                                column\n                            ]\n                        }, additionalHeaderProperties(column)), defaultColumn);\n                    } // If the resulting parent columns are the same, just add\n                    // the column and increment the header span\n                    if (latestParentColumn && latestParentColumn.originalId === newParent.originalId) {\n                        latestParentColumn.headers.push(column);\n                    } else {\n                        parentColumns.push(newParent);\n                    }\n                }\n                headerGroup.headers.push(column);\n            });\n            headerGroups.push(headerGroup); // Start scanning the parent columns\n            scanColumns = parentColumns;\n        };\n        while(scanColumns.length){\n            _loop();\n        }\n        return headerGroups.reverse();\n    }\n    var pathObjCache = new Map();\n    function getBy(obj, path, def) {\n        if (!path) {\n            return obj;\n        }\n        var cacheKey = typeof path === \"function\" ? path : JSON.stringify(path);\n        var pathObj = pathObjCache.get(cacheKey) || function() {\n            var pathObj = makePathArray(path);\n            pathObjCache.set(cacheKey, pathObj);\n            return pathObj;\n        }();\n        var val;\n        try {\n            val = pathObj.reduce(function(cursor, pathPart) {\n                return cursor[pathPart];\n            }, obj);\n        } catch (e) {}\n        return typeof val !== \"undefined\" ? val : def;\n    }\n    function getFirstDefined() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        for(var i = 0; i < args.length; i += 1){\n            if (typeof args[i] !== \"undefined\") {\n                return args[i];\n            }\n        }\n    }\n    function isFunction(a) {\n        if (typeof a === \"function\") {\n            return a;\n        }\n    }\n    function flattenBy(arr, key) {\n        var flat = [];\n        var recurse = function recurse(arr) {\n            arr.forEach(function(d) {\n                if (!d[key]) {\n                    flat.push(d);\n                } else {\n                    recurse(d[key]);\n                }\n            });\n        };\n        recurse(arr);\n        return flat;\n    }\n    function expandRows(rows, _ref) {\n        var manualExpandedKey = _ref.manualExpandedKey, expanded = _ref.expanded, _ref$expandSubRows = _ref.expandSubRows, expandSubRows = _ref$expandSubRows === void 0 ? true : _ref$expandSubRows;\n        var expandedRows = [];\n        var handleRow = function handleRow(row, addToExpandedRows) {\n            if (addToExpandedRows === void 0) {\n                addToExpandedRows = true;\n            }\n            row.isExpanded = row.original && row.original[manualExpandedKey] || expanded[row.id];\n            row.canExpand = row.subRows && !!row.subRows.length;\n            if (addToExpandedRows) {\n                expandedRows.push(row);\n            }\n            if (row.subRows && row.subRows.length && row.isExpanded) {\n                row.subRows.forEach(function(row) {\n                    return handleRow(row, expandSubRows);\n                });\n            }\n        };\n        rows.forEach(function(row) {\n            return handleRow(row);\n        });\n        return expandedRows;\n    }\n    function getFilterMethod(filter, userFilterTypes, filterTypes) {\n        return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;\n    }\n    function shouldAutoRemoveFilter(autoRemove, value, column) {\n        return autoRemove ? autoRemove(value, column) : typeof value === \"undefined\";\n    }\n    function unpreparedAccessWarning() {\n        throw new Error(\"React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.\");\n    }\n    var passiveSupported = null;\n    function passiveEventSupported() {\n        // memoize support to avoid adding multiple test events\n        if (typeof passiveSupported === \"boolean\") return passiveSupported;\n        var supported = false;\n        try {\n            var options = {\n                get passive () {\n                    supported = true;\n                    return false;\n                }\n            };\n            window.addEventListener(\"test\", null, options);\n            window.removeEventListener(\"test\", null, options);\n        } catch (err) {\n            supported = false;\n        }\n        passiveSupported = supported;\n        return passiveSupported;\n    } //\n    var reOpenBracket = /\\[/g;\n    var reCloseBracket = /\\]/g;\n    function makePathArray(obj) {\n        return flattenDeep(obj) // remove all periods in parts\n        .map(function(d) {\n            return String(d).replace(\".\", \"_\");\n        }) // join parts using period\n        .join(\".\") // replace brackets with periods\n        .replace(reOpenBracket, \".\").replace(reCloseBracket, \"\") // split it back out on periods\n        .split(\".\");\n    }\n    function flattenDeep(arr, newArr) {\n        if (newArr === void 0) {\n            newArr = [];\n        }\n        if (!Array.isArray(arr)) {\n            newArr.push(arr);\n        } else {\n            for(var i = 0; i < arr.length; i += 1){\n                flattenDeep(arr[i], newArr);\n            }\n        }\n        return newArr;\n    }\n    var defaultGetTableProps = function defaultGetTableProps(props) {\n        return _extends({\n            role: \"table\"\n        }, props);\n    };\n    var defaultGetTableBodyProps = function defaultGetTableBodyProps(props) {\n        return _extends({\n            role: \"rowgroup\"\n        }, props);\n    };\n    var defaultGetHeaderProps = function defaultGetHeaderProps(props, _ref) {\n        var column = _ref.column;\n        return _extends({\n            key: \"header_\" + column.id,\n            colSpan: column.totalVisibleHeaderCount,\n            role: \"columnheader\"\n        }, props);\n    };\n    var defaultGetFooterProps = function defaultGetFooterProps(props, _ref2) {\n        var column = _ref2.column;\n        return _extends({\n            key: \"footer_\" + column.id,\n            colSpan: column.totalVisibleHeaderCount\n        }, props);\n    };\n    var defaultGetHeaderGroupProps = function defaultGetHeaderGroupProps(props, _ref3) {\n        var index = _ref3.index;\n        return _extends({\n            key: \"headerGroup_\" + index,\n            role: \"row\"\n        }, props);\n    };\n    var defaultGetFooterGroupProps = function defaultGetFooterGroupProps(props, _ref4) {\n        var index = _ref4.index;\n        return _extends({\n            key: \"footerGroup_\" + index\n        }, props);\n    };\n    var defaultGetRowProps = function defaultGetRowProps(props, _ref5) {\n        var row = _ref5.row;\n        return _extends({\n            key: \"row_\" + row.id,\n            role: \"row\"\n        }, props);\n    };\n    var defaultGetCellProps = function defaultGetCellProps(props, _ref6) {\n        var cell = _ref6.cell;\n        return _extends({\n            key: \"cell_\" + cell.row.id + \"_\" + cell.column.id,\n            role: \"cell\"\n        }, props);\n    };\n    function makeDefaultPluginHooks() {\n        return {\n            useOptions: [],\n            stateReducers: [],\n            useControlledState: [],\n            columns: [],\n            columnsDeps: [],\n            allColumns: [],\n            allColumnsDeps: [],\n            accessValue: [],\n            materializedColumns: [],\n            materializedColumnsDeps: [],\n            useInstanceAfterData: [],\n            visibleColumns: [],\n            visibleColumnsDeps: [],\n            headerGroups: [],\n            headerGroupsDeps: [],\n            useInstanceBeforeDimensions: [],\n            useInstance: [],\n            prepareRow: [],\n            getTableProps: [\n                defaultGetTableProps\n            ],\n            getTableBodyProps: [\n                defaultGetTableBodyProps\n            ],\n            getHeaderGroupProps: [\n                defaultGetHeaderGroupProps\n            ],\n            getFooterGroupProps: [\n                defaultGetFooterGroupProps\n            ],\n            getHeaderProps: [\n                defaultGetHeaderProps\n            ],\n            getFooterProps: [\n                defaultGetFooterProps\n            ],\n            getRowProps: [\n                defaultGetRowProps\n            ],\n            getCellProps: [\n                defaultGetCellProps\n            ],\n            useFinalInstance: []\n        };\n    }\n    actions.resetHiddenColumns = \"resetHiddenColumns\";\n    actions.toggleHideColumn = \"toggleHideColumn\";\n    actions.setHiddenColumns = \"setHiddenColumns\";\n    actions.toggleHideAllColumns = \"toggleHideAllColumns\";\n    var useColumnVisibility = function useColumnVisibility(hooks) {\n        hooks.getToggleHiddenProps = [\n            defaultGetToggleHiddenProps\n        ];\n        hooks.getToggleHideAllColumnsProps = [\n            defaultGetToggleHideAllColumnsProps\n        ];\n        hooks.stateReducers.push(reducer);\n        hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions);\n        hooks.headerGroupsDeps.push(function(deps, _ref) {\n            var instance = _ref.instance;\n            return [].concat(deps, [\n                instance.state.hiddenColumns\n            ]);\n        });\n        hooks.useInstance.push(useInstance);\n    };\n    useColumnVisibility.pluginName = \"useColumnVisibility\";\n    var defaultGetToggleHiddenProps = function defaultGetToggleHiddenProps(props, _ref2) {\n        var column = _ref2.column;\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    column.toggleHidden(!e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: column.isVisible,\n                title: \"Toggle Column Visible\"\n            }\n        ];\n    };\n    var defaultGetToggleHideAllColumnsProps = function defaultGetToggleHideAllColumnsProps(props, _ref3) {\n        var instance = _ref3.instance;\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    instance.toggleHideAllColumns(!e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: !instance.allColumnsHidden && !instance.state.hiddenColumns.length,\n                title: \"Toggle All Columns Hidden\",\n                indeterminate: !instance.allColumnsHidden && instance.state.hiddenColumns.length\n            }\n        ];\n    };\n    function reducer(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                hiddenColumns: []\n            }, state);\n        }\n        if (action.type === actions.resetHiddenColumns) {\n            return _extends({}, state, {\n                hiddenColumns: instance.initialState.hiddenColumns || []\n            });\n        }\n        if (action.type === actions.toggleHideColumn) {\n            var should = typeof action.value !== \"undefined\" ? action.value : !state.hiddenColumns.includes(action.columnId);\n            var hiddenColumns = should ? [].concat(state.hiddenColumns, [\n                action.columnId\n            ]) : state.hiddenColumns.filter(function(d) {\n                return d !== action.columnId;\n            });\n            return _extends({}, state, {\n                hiddenColumns: hiddenColumns\n            });\n        }\n        if (action.type === actions.setHiddenColumns) {\n            return _extends({}, state, {\n                hiddenColumns: functionalUpdate(action.value, state.hiddenColumns)\n            });\n        }\n        if (action.type === actions.toggleHideAllColumns) {\n            var shouldAll = typeof action.value !== \"undefined\" ? action.value : !state.hiddenColumns.length;\n            return _extends({}, state, {\n                hiddenColumns: shouldAll ? instance.allColumns.map(function(d) {\n                    return d.id;\n                }) : []\n            });\n        }\n    }\n    function useInstanceBeforeDimensions(instance) {\n        var headers = instance.headers, hiddenColumns = instance.state.hiddenColumns;\n        var isMountedRef = React.useRef(false);\n        if (!isMountedRef.current) ;\n        var handleColumn = function handleColumn(column, parentVisible) {\n            column.isVisible = parentVisible && !hiddenColumns.includes(column.id);\n            var totalVisibleHeaderCount = 0;\n            if (column.headers && column.headers.length) {\n                column.headers.forEach(function(subColumn) {\n                    return totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible);\n                });\n            } else {\n                totalVisibleHeaderCount = column.isVisible ? 1 : 0;\n            }\n            column.totalVisibleHeaderCount = totalVisibleHeaderCount;\n            return totalVisibleHeaderCount;\n        };\n        var totalVisibleHeaderCount = 0;\n        headers.forEach(function(subHeader) {\n            return totalVisibleHeaderCount += handleColumn(subHeader, true);\n        });\n    }\n    function useInstance(instance) {\n        var columns = instance.columns, flatHeaders = instance.flatHeaders, dispatch = instance.dispatch, allColumns = instance.allColumns, getHooks = instance.getHooks, hiddenColumns = instance.state.hiddenColumns, _instance$autoResetHi = instance.autoResetHiddenColumns, autoResetHiddenColumns = _instance$autoResetHi === void 0 ? true : _instance$autoResetHi;\n        var getInstance = useGetLatest(instance);\n        var allColumnsHidden = allColumns.length === hiddenColumns.length;\n        var toggleHideColumn = React.useCallback(function(columnId, value) {\n            return dispatch({\n                type: actions.toggleHideColumn,\n                columnId: columnId,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var setHiddenColumns = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.setHiddenColumns,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var toggleHideAllColumns = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.toggleHideAllColumns,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var getToggleHideAllColumnsProps = makePropGetter(getHooks().getToggleHideAllColumnsProps, {\n            instance: getInstance()\n        });\n        flatHeaders.forEach(function(column) {\n            column.toggleHidden = function(value) {\n                dispatch({\n                    type: actions.toggleHideColumn,\n                    columnId: column.id,\n                    value: value\n                });\n            };\n            column.getToggleHiddenProps = makePropGetter(getHooks().getToggleHiddenProps, {\n                instance: getInstance(),\n                column: column\n            });\n        });\n        var getAutoResetHiddenColumns = useGetLatest(autoResetHiddenColumns);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetHiddenColumns()) {\n                dispatch({\n                    type: actions.resetHiddenColumns\n                });\n            }\n        }, [\n            dispatch,\n            columns\n        ]);\n        Object.assign(instance, {\n            allColumnsHidden: allColumnsHidden,\n            toggleHideColumn: toggleHideColumn,\n            setHiddenColumns: setHiddenColumns,\n            toggleHideAllColumns: toggleHideAllColumns,\n            getToggleHideAllColumnsProps: getToggleHideAllColumnsProps\n        });\n    }\n    var defaultInitialState = {};\n    var defaultColumnInstance = {};\n    var defaultReducer = function defaultReducer(state, action, prevState) {\n        return state;\n    };\n    var defaultGetSubRows = function defaultGetSubRows(row, index) {\n        return row.subRows || [];\n    };\n    var defaultGetRowId = function defaultGetRowId(row, index, parent) {\n        return \"\" + (parent ? [\n            parent.id,\n            index\n        ].join(\".\") : index);\n    };\n    var defaultUseControlledState = function defaultUseControlledState(d) {\n        return d;\n    };\n    function applyDefaults(props) {\n        var _props$initialState = props.initialState, initialState = _props$initialState === void 0 ? defaultInitialState : _props$initialState, _props$defaultColumn = props.defaultColumn, defaultColumn = _props$defaultColumn === void 0 ? defaultColumnInstance : _props$defaultColumn, _props$getSubRows = props.getSubRows, getSubRows = _props$getSubRows === void 0 ? defaultGetSubRows : _props$getSubRows, _props$getRowId = props.getRowId, getRowId = _props$getRowId === void 0 ? defaultGetRowId : _props$getRowId, _props$stateReducer = props.stateReducer, stateReducer = _props$stateReducer === void 0 ? defaultReducer : _props$stateReducer, _props$useControlledS = props.useControlledState, useControlledState = _props$useControlledS === void 0 ? defaultUseControlledState : _props$useControlledS, rest = _objectWithoutPropertiesLoose(props, [\n            \"initialState\",\n            \"defaultColumn\",\n            \"getSubRows\",\n            \"getRowId\",\n            \"stateReducer\",\n            \"useControlledState\"\n        ]);\n        return _extends({}, rest, {\n            initialState: initialState,\n            defaultColumn: defaultColumn,\n            getSubRows: getSubRows,\n            getRowId: getRowId,\n            stateReducer: stateReducer,\n            useControlledState: useControlledState\n        });\n    }\n    var useTable = function useTable(props) {\n        for(var _len = arguments.length, plugins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            plugins[_key - 1] = arguments[_key];\n        }\n        // Apply default props\n        props = applyDefaults(props); // Add core plugins\n        plugins = [\n            useColumnVisibility\n        ].concat(plugins); // Create the table instance\n        var instanceRef = React.useRef({}); // Create a getter for the instance (helps avoid a lot of potential memory leaks)\n        var getInstance = useGetLatest(instanceRef.current); // Assign the props, plugins and hooks to the instance\n        Object.assign(getInstance(), _extends({}, props, {\n            plugins: plugins,\n            hooks: makeDefaultPluginHooks()\n        })); // Allow plugins to register hooks as early as possible\n        plugins.filter(Boolean).forEach(function(plugin) {\n            plugin(getInstance().hooks);\n        }); // Consume all hooks and make a getter for them\n        var getHooks = useGetLatest(getInstance().hooks);\n        getInstance().getHooks = getHooks;\n        delete getInstance().hooks; // Allow useOptions hooks to modify the options coming into the table\n        Object.assign(getInstance(), reduceHooks(getHooks().useOptions, applyDefaults(props)));\n        var _getInstance = getInstance(), data = _getInstance.data, userColumns = _getInstance.columns, initialState = _getInstance.initialState, defaultColumn = _getInstance.defaultColumn, getSubRows = _getInstance.getSubRows, getRowId = _getInstance.getRowId, stateReducer = _getInstance.stateReducer, useControlledState = _getInstance.useControlledState; // Setup user reducer ref\n        var getStateReducer = useGetLatest(stateReducer); // Build the reducer\n        var reducer = React.useCallback(function(state, action) {\n            // Detect invalid actions\n            if (!action.type) {\n                console.info({\n                    action: action\n                });\n                throw new Error(\"Unknown Action \\uD83D\\uDC46\");\n            } // Reduce the state from all plugin reducers\n            return [].concat(getHooks().stateReducers, Array.isArray(getStateReducer()) ? getStateReducer() : [\n                getStateReducer()\n            ]).reduce(function(s, handler) {\n                return handler(s, action, state, getInstance()) || s;\n            }, state);\n        }, [\n            getHooks,\n            getStateReducer,\n            getInstance\n        ]); // Start the reducer\n        var _React$useReducer = React.useReducer(reducer, undefined, function() {\n            return reducer(initialState, {\n                type: actions.init\n            });\n        }), reducerState = _React$useReducer[0], dispatch = _React$useReducer[1]; // Allow the user to control the final state with hooks\n        var state = reduceHooks([].concat(getHooks().useControlledState, [\n            useControlledState\n        ]), reducerState, {\n            instance: getInstance()\n        });\n        Object.assign(getInstance(), {\n            state: state,\n            dispatch: dispatch\n        }); // Decorate All the columns\n        var columns = React.useMemo(function() {\n            return linkColumnStructure(reduceHooks(getHooks().columns, userColumns, {\n                instance: getInstance()\n            }));\n        }, [\n            getHooks,\n            getInstance,\n            userColumns\n        ].concat(reduceHooks(getHooks().columnsDeps, [], {\n            instance: getInstance()\n        })));\n        getInstance().columns = columns; // Get the flat list of all columns and allow hooks to decorate\n        // those columns (and trigger this memoization via deps)\n        var allColumns = React.useMemo(function() {\n            return reduceHooks(getHooks().allColumns, flattenColumns(columns), {\n                instance: getInstance()\n            }).map(assignColumnAccessor);\n        }, [\n            columns,\n            getHooks,\n            getInstance\n        ].concat(reduceHooks(getHooks().allColumnsDeps, [], {\n            instance: getInstance()\n        })));\n        getInstance().allColumns = allColumns; // Access the row model using initial columns\n        var _React$useMemo = React.useMemo(function() {\n            var rows = [];\n            var flatRows = [];\n            var rowsById = {};\n            var allColumnsQueue = [].concat(allColumns);\n            while(allColumnsQueue.length){\n                var column = allColumnsQueue.shift();\n                accessRowsForColumn({\n                    data: data,\n                    rows: rows,\n                    flatRows: flatRows,\n                    rowsById: rowsById,\n                    column: column,\n                    getRowId: getRowId,\n                    getSubRows: getSubRows,\n                    accessValueHooks: getHooks().accessValue,\n                    getInstance: getInstance\n                });\n            }\n            return [\n                rows,\n                flatRows,\n                rowsById\n            ];\n        }, [\n            allColumns,\n            data,\n            getRowId,\n            getSubRows,\n            getHooks,\n            getInstance\n        ]), rows = _React$useMemo[0], flatRows = _React$useMemo[1], rowsById = _React$useMemo[2];\n        Object.assign(getInstance(), {\n            rows: rows,\n            initialRows: [].concat(rows),\n            flatRows: flatRows,\n            rowsById: rowsById // materializedColumns,\n        });\n        loopHooks(getHooks().useInstanceAfterData, getInstance()); // Get the flat list of all columns AFTER the rows\n        // have been access, and allow hooks to decorate\n        // those columns (and trigger this memoization via deps)\n        var visibleColumns = React.useMemo(function() {\n            return reduceHooks(getHooks().visibleColumns, allColumns, {\n                instance: getInstance()\n            }).map(function(d) {\n                return decorateColumn(d, defaultColumn);\n            });\n        }, [\n            getHooks,\n            allColumns,\n            getInstance,\n            defaultColumn\n        ].concat(reduceHooks(getHooks().visibleColumnsDeps, [], {\n            instance: getInstance()\n        }))); // Combine new visible columns with all columns\n        allColumns = React.useMemo(function() {\n            var columns = [].concat(visibleColumns);\n            allColumns.forEach(function(column) {\n                if (!columns.find(function(d) {\n                    return d.id === column.id;\n                })) {\n                    columns.push(column);\n                }\n            });\n            return columns;\n        }, [\n            allColumns,\n            visibleColumns\n        ]);\n        getInstance().allColumns = allColumns;\n        {\n            var duplicateColumns = allColumns.filter(function(column, i) {\n                return allColumns.findIndex(function(d) {\n                    return d.id === column.id;\n                }) !== i;\n            });\n            if (duplicateColumns.length) {\n                console.info(allColumns);\n                throw new Error('Duplicate columns were found with ids: \"' + duplicateColumns.map(function(d) {\n                    return d.id;\n                }).join(\", \") + '\" in the columns array above');\n            }\n        }\n        var headerGroups = React.useMemo(function() {\n            return reduceHooks(getHooks().headerGroups, makeHeaderGroups(visibleColumns, defaultColumn), getInstance());\n        }, [\n            getHooks,\n            visibleColumns,\n            defaultColumn,\n            getInstance\n        ].concat(reduceHooks(getHooks().headerGroupsDeps, [], {\n            instance: getInstance()\n        })));\n        getInstance().headerGroups = headerGroups; // Get the first level of headers\n        var headers = React.useMemo(function() {\n            return headerGroups.length ? headerGroups[0].headers : [];\n        }, [\n            headerGroups\n        ]);\n        getInstance().headers = headers; // Provide a flat header list for utilities\n        getInstance().flatHeaders = headerGroups.reduce(function(all, headerGroup) {\n            return [].concat(all, headerGroup.headers);\n        }, []);\n        loopHooks(getHooks().useInstanceBeforeDimensions, getInstance()); // Filter columns down to visible ones\n        var visibleColumnsDep = visibleColumns.filter(function(d) {\n            return d.isVisible;\n        }).map(function(d) {\n            return d.id;\n        }).sort().join(\"_\");\n        visibleColumns = React.useMemo(function() {\n            return visibleColumns.filter(function(d) {\n                return d.isVisible;\n            });\n        }, [\n            visibleColumns,\n            visibleColumnsDep\n        ]);\n        getInstance().visibleColumns = visibleColumns; // Header Visibility is needed by this point\n        var _calculateHeaderWidth = calculateHeaderWidths(headers), totalColumnsMinWidth = _calculateHeaderWidth[0], totalColumnsWidth = _calculateHeaderWidth[1], totalColumnsMaxWidth = _calculateHeaderWidth[2];\n        getInstance().totalColumnsMinWidth = totalColumnsMinWidth;\n        getInstance().totalColumnsWidth = totalColumnsWidth;\n        getInstance().totalColumnsMaxWidth = totalColumnsMaxWidth;\n        loopHooks(getHooks().useInstance, getInstance()) // Each materialized header needs to be assigned a render function and other\n        ;\n        [].concat(getInstance().flatHeaders, getInstance().allColumns).forEach(function(column) {\n            // Give columns/headers rendering power\n            column.render = makeRenderer(getInstance(), column); // Give columns/headers a default getHeaderProps\n            column.getHeaderProps = makePropGetter(getHooks().getHeaderProps, {\n                instance: getInstance(),\n                column: column\n            }); // Give columns/headers a default getFooterProps\n            column.getFooterProps = makePropGetter(getHooks().getFooterProps, {\n                instance: getInstance(),\n                column: column\n            });\n        });\n        getInstance().headerGroups = React.useMemo(function() {\n            return headerGroups.filter(function(headerGroup, i) {\n                // Filter out any headers and headerGroups that don't have visible columns\n                headerGroup.headers = headerGroup.headers.filter(function(column) {\n                    var recurse = function recurse(headers) {\n                        return headers.filter(function(column) {\n                            if (column.headers) {\n                                return recurse(column.headers);\n                            }\n                            return column.isVisible;\n                        }).length;\n                    };\n                    if (column.headers) {\n                        return recurse(column.headers);\n                    }\n                    return column.isVisible;\n                }); // Give headerGroups getRowProps\n                if (headerGroup.headers.length) {\n                    headerGroup.getHeaderGroupProps = makePropGetter(getHooks().getHeaderGroupProps, {\n                        instance: getInstance(),\n                        headerGroup: headerGroup,\n                        index: i\n                    });\n                    headerGroup.getFooterGroupProps = makePropGetter(getHooks().getFooterGroupProps, {\n                        instance: getInstance(),\n                        headerGroup: headerGroup,\n                        index: i\n                    });\n                    return true;\n                }\n                return false;\n            });\n        }, [\n            headerGroups,\n            getInstance,\n            getHooks\n        ]);\n        getInstance().footerGroups = [].concat(getInstance().headerGroups).reverse(); // The prepareRow function is absolutely necessary and MUST be called on\n        // any rows the user wishes to be displayed.\n        getInstance().prepareRow = React.useCallback(function(row) {\n            row.getRowProps = makePropGetter(getHooks().getRowProps, {\n                instance: getInstance(),\n                row: row\n            }); // Build the visible cells for each row\n            row.allCells = allColumns.map(function(column) {\n                var value = row.values[column.id];\n                var cell = {\n                    column: column,\n                    row: row,\n                    value: value\n                }; // Give each cell a getCellProps base\n                cell.getCellProps = makePropGetter(getHooks().getCellProps, {\n                    instance: getInstance(),\n                    cell: cell\n                }); // Give each cell a renderer function (supports multiple renderers)\n                cell.render = makeRenderer(getInstance(), column, {\n                    row: row,\n                    cell: cell,\n                    value: value\n                });\n                return cell;\n            });\n            row.cells = visibleColumns.map(function(column) {\n                return row.allCells.find(function(cell) {\n                    return cell.column.id === column.id;\n                });\n            }); // need to apply any row specific hooks (useExpanded requires this)\n            loopHooks(getHooks().prepareRow, row, {\n                instance: getInstance()\n            });\n        }, [\n            getHooks,\n            getInstance,\n            allColumns,\n            visibleColumns\n        ]);\n        getInstance().getTableProps = makePropGetter(getHooks().getTableProps, {\n            instance: getInstance()\n        });\n        getInstance().getTableBodyProps = makePropGetter(getHooks().getTableBodyProps, {\n            instance: getInstance()\n        });\n        loopHooks(getHooks().useFinalInstance, getInstance());\n        return getInstance();\n    };\n    function calculateHeaderWidths(headers, left) {\n        if (left === void 0) {\n            left = 0;\n        }\n        var sumTotalMinWidth = 0;\n        var sumTotalWidth = 0;\n        var sumTotalMaxWidth = 0;\n        var sumTotalFlexWidth = 0;\n        headers.forEach(function(header) {\n            var subHeaders = header.headers;\n            header.totalLeft = left;\n            if (subHeaders && subHeaders.length) {\n                var _calculateHeaderWidth2 = calculateHeaderWidths(subHeaders, left), totalMinWidth = _calculateHeaderWidth2[0], totalWidth = _calculateHeaderWidth2[1], totalMaxWidth = _calculateHeaderWidth2[2], totalFlexWidth = _calculateHeaderWidth2[3];\n                header.totalMinWidth = totalMinWidth;\n                header.totalWidth = totalWidth;\n                header.totalMaxWidth = totalMaxWidth;\n                header.totalFlexWidth = totalFlexWidth;\n            } else {\n                header.totalMinWidth = header.minWidth;\n                header.totalWidth = Math.min(Math.max(header.minWidth, header.width), header.maxWidth);\n                header.totalMaxWidth = header.maxWidth;\n                header.totalFlexWidth = header.canResize ? header.totalWidth : 0;\n            }\n            if (header.isVisible) {\n                left += header.totalWidth;\n                sumTotalMinWidth += header.totalMinWidth;\n                sumTotalWidth += header.totalWidth;\n                sumTotalMaxWidth += header.totalMaxWidth;\n                sumTotalFlexWidth += header.totalFlexWidth;\n            }\n        });\n        return [\n            sumTotalMinWidth,\n            sumTotalWidth,\n            sumTotalMaxWidth,\n            sumTotalFlexWidth\n        ];\n    }\n    function accessRowsForColumn(_ref) {\n        var data = _ref.data, rows = _ref.rows, flatRows = _ref.flatRows, rowsById = _ref.rowsById, column = _ref.column, getRowId = _ref.getRowId, getSubRows = _ref.getSubRows, accessValueHooks = _ref.accessValueHooks, getInstance = _ref.getInstance;\n        // Access the row's data column-by-column\n        // We do it this way so we can incrementally add materialized\n        // columns after the first pass and avoid excessive looping\n        var accessRow = function accessRow(originalRow, rowIndex, depth, parent, parentRows) {\n            if (depth === void 0) {\n                depth = 0;\n            }\n            // Keep the original reference around\n            var original = originalRow;\n            var id = getRowId(originalRow, rowIndex, parent);\n            var row = rowsById[id]; // If the row hasn't been created, let's make it\n            if (!row) {\n                row = {\n                    id: id,\n                    original: original,\n                    index: rowIndex,\n                    depth: depth,\n                    cells: [\n                        {}\n                    ] // This is a dummy cell\n                }; // Override common array functions (and the dummy cell's getCellProps function)\n                // to show an error if it is accessed without calling prepareRow\n                row.cells.map = unpreparedAccessWarning;\n                row.cells.filter = unpreparedAccessWarning;\n                row.cells.forEach = unpreparedAccessWarning;\n                row.cells[0].getCellProps = unpreparedAccessWarning; // Create the cells and values\n                row.values = {}; // Push this row into the parentRows array\n                parentRows.push(row); // Keep track of every row in a flat array\n                flatRows.push(row); // Also keep track of every row by its ID\n                rowsById[id] = row; // Get the original subrows\n                row.originalSubRows = getSubRows(originalRow, rowIndex); // Then recursively access them\n                if (row.originalSubRows) {\n                    var subRows = [];\n                    row.originalSubRows.forEach(function(d, i) {\n                        return accessRow(d, i, depth + 1, row, subRows);\n                    }); // Keep the new subRows array on the row\n                    row.subRows = subRows;\n                }\n            } else if (row.subRows) {\n                // If the row exists, then it's already been accessed\n                // Keep recursing, but don't worry about passing the\n                // accumlator array (those rows already exist)\n                row.originalSubRows.forEach(function(d, i) {\n                    return accessRow(d, i, depth + 1, row);\n                });\n            } // If the column has an accessor, use it to get a value\n            if (column.accessor) {\n                row.values[column.id] = column.accessor(originalRow, rowIndex, row, parentRows, data);\n            } // Allow plugins to manipulate the column value\n            row.values[column.id] = reduceHooks(accessValueHooks, row.values[column.id], {\n                row: row,\n                column: column,\n                instance: getInstance()\n            }, true);\n        };\n        data.forEach(function(originalRow, rowIndex) {\n            return accessRow(originalRow, rowIndex, 0, undefined, rows);\n        });\n    }\n    actions.resetExpanded = \"resetExpanded\";\n    actions.toggleRowExpanded = \"toggleRowExpanded\";\n    actions.toggleAllRowsExpanded = \"toggleAllRowsExpanded\";\n    var useExpanded = function useExpanded(hooks) {\n        hooks.getToggleAllRowsExpandedProps = [\n            defaultGetToggleAllRowsExpandedProps\n        ];\n        hooks.getToggleRowExpandedProps = [\n            defaultGetToggleRowExpandedProps\n        ];\n        hooks.stateReducers.push(reducer$1);\n        hooks.useInstance.push(useInstance$1);\n        hooks.prepareRow.push(prepareRow);\n    };\n    useExpanded.pluginName = \"useExpanded\";\n    var defaultGetToggleAllRowsExpandedProps = function defaultGetToggleAllRowsExpandedProps(props, _ref) {\n        var instance = _ref.instance;\n        return [\n            props,\n            {\n                onClick: function onClick(e) {\n                    instance.toggleAllRowsExpanded();\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                title: \"Toggle All Rows Expanded\"\n            }\n        ];\n    };\n    var defaultGetToggleRowExpandedProps = function defaultGetToggleRowExpandedProps(props, _ref2) {\n        var row = _ref2.row;\n        return [\n            props,\n            {\n                onClick: function onClick() {\n                    row.toggleRowExpanded();\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                title: \"Toggle Row Expanded\"\n            }\n        ];\n    }; // Reducer\n    function reducer$1(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                expanded: {}\n            }, state);\n        }\n        if (action.type === actions.resetExpanded) {\n            return _extends({}, state, {\n                expanded: instance.initialState.expanded || {}\n            });\n        }\n        if (action.type === actions.toggleAllRowsExpanded) {\n            var value = action.value;\n            var rowsById = instance.rowsById;\n            var isAllRowsExpanded = Object.keys(rowsById).length === Object.keys(state.expanded).length;\n            var expandAll = typeof value !== \"undefined\" ? value : !isAllRowsExpanded;\n            if (expandAll) {\n                var expanded = {};\n                Object.keys(rowsById).forEach(function(rowId) {\n                    expanded[rowId] = true;\n                });\n                return _extends({}, state, {\n                    expanded: expanded\n                });\n            }\n            return _extends({}, state, {\n                expanded: {}\n            });\n        }\n        if (action.type === actions.toggleRowExpanded) {\n            var id = action.id, setExpanded = action.value;\n            var exists = state.expanded[id];\n            var shouldExist = typeof setExpanded !== \"undefined\" ? setExpanded : !exists;\n            if (!exists && shouldExist) {\n                var _extends2;\n                return _extends({}, state, {\n                    expanded: _extends({}, state.expanded, (_extends2 = {}, _extends2[id] = true, _extends2))\n                });\n            } else if (exists && !shouldExist) {\n                var _state$expanded = state.expanded, _ = _state$expanded[id], rest = _objectWithoutPropertiesLoose(_state$expanded, [\n                    id\n                ].map(_toPropertyKey));\n                return _extends({}, state, {\n                    expanded: rest\n                });\n            } else {\n                return state;\n            }\n        }\n    }\n    function useInstance$1(instance) {\n        var data = instance.data, rows = instance.rows, rowsById = instance.rowsById, _instance$manualExpan = instance.manualExpandedKey, manualExpandedKey = _instance$manualExpan === void 0 ? \"expanded\" : _instance$manualExpan, _instance$paginateExp = instance.paginateExpandedRows, paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp, _instance$expandSubRo = instance.expandSubRows, expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo, _instance$autoResetEx = instance.autoResetExpanded, autoResetExpanded = _instance$autoResetEx === void 0 ? true : _instance$autoResetEx, getHooks = instance.getHooks, plugins = instance.plugins, expanded = instance.state.expanded, dispatch = instance.dispatch;\n        ensurePluginOrder(plugins, [\n            \"useSortBy\",\n            \"useGroupBy\",\n            \"usePivotColumns\",\n            \"useGlobalFilter\"\n        ], \"useExpanded\");\n        var getAutoResetExpanded = useGetLatest(autoResetExpanded);\n        var isAllRowsExpanded = Boolean(Object.keys(rowsById).length && Object.keys(expanded).length);\n        if (isAllRowsExpanded) {\n            if (Object.keys(rowsById).some(function(id) {\n                return !expanded[id];\n            })) {\n                isAllRowsExpanded = false;\n            }\n        } // Bypass any effects from firing when this changes\n        useMountedLayoutEffect(function() {\n            if (getAutoResetExpanded()) {\n                dispatch({\n                    type: actions.resetExpanded\n                });\n            }\n        }, [\n            dispatch,\n            data\n        ]);\n        var toggleRowExpanded = React.useCallback(function(id, value) {\n            dispatch({\n                type: actions.toggleRowExpanded,\n                id: id,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var toggleAllRowsExpanded = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.toggleAllRowsExpanded,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var expandedRows = React.useMemo(function() {\n            if (paginateExpandedRows) {\n                return expandRows(rows, {\n                    manualExpandedKey: manualExpandedKey,\n                    expanded: expanded,\n                    expandSubRows: expandSubRows\n                });\n            }\n            return rows;\n        }, [\n            paginateExpandedRows,\n            rows,\n            manualExpandedKey,\n            expanded,\n            expandSubRows\n        ]);\n        var expandedDepth = React.useMemo(function() {\n            return findExpandedDepth(expanded);\n        }, [\n            expanded\n        ]);\n        var getInstance = useGetLatest(instance);\n        var getToggleAllRowsExpandedProps = makePropGetter(getHooks().getToggleAllRowsExpandedProps, {\n            instance: getInstance()\n        });\n        Object.assign(instance, {\n            preExpandedRows: rows,\n            expandedRows: expandedRows,\n            rows: expandedRows,\n            expandedDepth: expandedDepth,\n            isAllRowsExpanded: isAllRowsExpanded,\n            toggleRowExpanded: toggleRowExpanded,\n            toggleAllRowsExpanded: toggleAllRowsExpanded,\n            getToggleAllRowsExpandedProps: getToggleAllRowsExpandedProps\n        });\n    }\n    function prepareRow(row, _ref3) {\n        var getHooks = _ref3.instance.getHooks, instance = _ref3.instance;\n        row.toggleRowExpanded = function(set) {\n            return instance.toggleRowExpanded(row.id, set);\n        };\n        row.getToggleRowExpandedProps = makePropGetter(getHooks().getToggleRowExpandedProps, {\n            instance: instance,\n            row: row\n        });\n    }\n    function findExpandedDepth(expanded) {\n        var maxDepth = 0;\n        Object.keys(expanded).forEach(function(id) {\n            var splitId = id.split(\".\");\n            maxDepth = Math.max(maxDepth, splitId.length);\n        });\n        return maxDepth;\n    }\n    var text = function text(rows, ids, filterValue) {\n        rows = rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return String(rowValue).toLowerCase().includes(String(filterValue).toLowerCase());\n            });\n        });\n        return rows;\n    };\n    text.autoRemove = function(val) {\n        return !val;\n    };\n    var exactText = function exactText(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue !== undefined ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase() : true;\n            });\n        });\n    };\n    exactText.autoRemove = function(val) {\n        return !val;\n    };\n    var exactTextCase = function exactTextCase(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue !== undefined ? String(rowValue) === String(filterValue) : true;\n            });\n        });\n    };\n    exactTextCase.autoRemove = function(val) {\n        return !val;\n    };\n    var includes = function includes(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue.includes(filterValue);\n            });\n        });\n    };\n    includes.autoRemove = function(val) {\n        return !val || !val.length;\n    };\n    var includesAll = function includesAll(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue && rowValue.length && filterValue.every(function(val) {\n                    return rowValue.includes(val);\n                });\n            });\n        });\n    };\n    includesAll.autoRemove = function(val) {\n        return !val || !val.length;\n    };\n    var includesSome = function includesSome(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue && rowValue.length && filterValue.some(function(val) {\n                    return rowValue.includes(val);\n                });\n            });\n        });\n    };\n    includesSome.autoRemove = function(val) {\n        return !val || !val.length;\n    };\n    var includesValue = function includesValue(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return filterValue.includes(rowValue);\n            });\n        });\n    };\n    includesValue.autoRemove = function(val) {\n        return !val || !val.length;\n    };\n    var exact = function exact(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue === filterValue;\n            });\n        });\n    };\n    exact.autoRemove = function(val) {\n        return typeof val === \"undefined\";\n    };\n    var equals = function equals(rows, ids, filterValue) {\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id]; // eslint-disable-next-line eqeqeq\n                return rowValue == filterValue;\n            });\n        });\n    };\n    equals.autoRemove = function(val) {\n        return val == null;\n    };\n    var between = function between(rows, ids, filterValue) {\n        var _ref = filterValue || [], min = _ref[0], max = _ref[1];\n        min = typeof min === \"number\" ? min : -Infinity;\n        max = typeof max === \"number\" ? max : Infinity;\n        if (min > max) {\n            var temp = min;\n            min = max;\n            max = temp;\n        }\n        return rows.filter(function(row) {\n            return ids.some(function(id) {\n                var rowValue = row.values[id];\n                return rowValue >= min && rowValue <= max;\n            });\n        });\n    };\n    between.autoRemove = function(val) {\n        return !val || typeof val[0] !== \"number\" && typeof val[1] !== \"number\";\n    };\n    var filterTypes = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        text: text,\n        exactText: exactText,\n        exactTextCase: exactTextCase,\n        includes: includes,\n        includesAll: includesAll,\n        includesSome: includesSome,\n        includesValue: includesValue,\n        exact: exact,\n        equals: equals,\n        between: between\n    });\n    actions.resetFilters = \"resetFilters\";\n    actions.setFilter = \"setFilter\";\n    actions.setAllFilters = \"setAllFilters\";\n    var useFilters = function useFilters(hooks) {\n        hooks.stateReducers.push(reducer$2);\n        hooks.useInstance.push(useInstance$2);\n    };\n    useFilters.pluginName = \"useFilters\";\n    function reducer$2(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                filters: []\n            }, state);\n        }\n        if (action.type === actions.resetFilters) {\n            return _extends({}, state, {\n                filters: instance.initialState.filters || []\n            });\n        }\n        if (action.type === actions.setFilter) {\n            var columnId = action.columnId, filterValue = action.filterValue;\n            var allColumns = instance.allColumns, userFilterTypes = instance.filterTypes;\n            var column = allColumns.find(function(d) {\n                return d.id === columnId;\n            });\n            if (!column) {\n                throw new Error(\"React-Table: Could not find a column with id: \" + columnId);\n            }\n            var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n            var previousfilter = state.filters.find(function(d) {\n                return d.id === columnId;\n            });\n            var newFilter = functionalUpdate(filterValue, previousfilter && previousfilter.value); //\n            if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter, column)) {\n                return _extends({}, state, {\n                    filters: state.filters.filter(function(d) {\n                        return d.id !== columnId;\n                    })\n                });\n            }\n            if (previousfilter) {\n                return _extends({}, state, {\n                    filters: state.filters.map(function(d) {\n                        if (d.id === columnId) {\n                            return {\n                                id: columnId,\n                                value: newFilter\n                            };\n                        }\n                        return d;\n                    })\n                });\n            }\n            return _extends({}, state, {\n                filters: [].concat(state.filters, [\n                    {\n                        id: columnId,\n                        value: newFilter\n                    }\n                ])\n            });\n        }\n        if (action.type === actions.setAllFilters) {\n            var filters = action.filters;\n            var _allColumns = instance.allColumns, _userFilterTypes = instance.filterTypes;\n            return _extends({}, state, {\n                // Filter out undefined values\n                filters: functionalUpdate(filters, state.filters).filter(function(filter) {\n                    var column = _allColumns.find(function(d) {\n                        return d.id === filter.id;\n                    });\n                    var filterMethod = getFilterMethod(column.filter, _userFilterTypes || {}, filterTypes);\n                    if (shouldAutoRemoveFilter(filterMethod.autoRemove, filter.value, column)) {\n                        return false;\n                    }\n                    return true;\n                })\n            });\n        }\n    }\n    function useInstance$2(instance) {\n        var data = instance.data, rows = instance.rows, flatRows = instance.flatRows, rowsById = instance.rowsById, allColumns = instance.allColumns, userFilterTypes = instance.filterTypes, manualFilters = instance.manualFilters, _instance$defaultCanF = instance.defaultCanFilter, defaultCanFilter = _instance$defaultCanF === void 0 ? false : _instance$defaultCanF, disableFilters = instance.disableFilters, filters = instance.state.filters, dispatch = instance.dispatch, _instance$autoResetFi = instance.autoResetFilters, autoResetFilters = _instance$autoResetFi === void 0 ? true : _instance$autoResetFi;\n        var setFilter = React.useCallback(function(columnId, filterValue) {\n            dispatch({\n                type: actions.setFilter,\n                columnId: columnId,\n                filterValue: filterValue\n            });\n        }, [\n            dispatch\n        ]);\n        var setAllFilters = React.useCallback(function(filters) {\n            dispatch({\n                type: actions.setAllFilters,\n                filters: filters\n            });\n        }, [\n            dispatch\n        ]);\n        allColumns.forEach(function(column) {\n            var id = column.id, accessor = column.accessor, columnDefaultCanFilter = column.defaultCanFilter, columnDisableFilters = column.disableFilters; // Determine if a column is filterable\n            column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false); // Provide the column a way of updating the filter value\n            column.setFilter = function(val) {\n                return setFilter(column.id, val);\n            }; // Provide the current filter value to the column for\n            // convenience\n            var found = filters.find(function(d) {\n                return d.id === id;\n            });\n            column.filterValue = found && found.value;\n        });\n        var _React$useMemo = React.useMemo(function() {\n            if (manualFilters || !filters.length) {\n                return [\n                    rows,\n                    flatRows,\n                    rowsById\n                ];\n            }\n            var filteredFlatRows = [];\n            var filteredRowsById = {}; // Filters top level and nested rows\n            var filterRows = function filterRows(rows, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                var filteredRows = rows;\n                filteredRows = filters.reduce(function(filteredSoFar, _ref) {\n                    var columnId = _ref.id, filterValue = _ref.value;\n                    // Find the filters column\n                    var column = allColumns.find(function(d) {\n                        return d.id === columnId;\n                    });\n                    if (!column) {\n                        return filteredSoFar;\n                    }\n                    if (depth === 0) {\n                        column.preFilteredRows = filteredSoFar;\n                    }\n                    var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n                    if (!filterMethod) {\n                        console.warn(\"Could not find a valid 'column.filter' for column with the ID: \" + column.id + \".\");\n                        return filteredSoFar;\n                    } // Pass the rows, id, filterValue and column to the filterMethod\n                    // to get the filtered rows back\n                    column.filteredRows = filterMethod(filteredSoFar, [\n                        columnId\n                    ], filterValue);\n                    return column.filteredRows;\n                }, rows); // Apply the filter to any subRows\n                // We technically could do this recursively in the above loop,\n                // but that would severely hinder the API for the user, since they\n                // would be required to do that recursion in some scenarios\n                filteredRows.forEach(function(row) {\n                    filteredFlatRows.push(row);\n                    filteredRowsById[row.id] = row;\n                    if (!row.subRows) {\n                        return;\n                    }\n                    row.subRows = row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows;\n                });\n                return filteredRows;\n            };\n            return [\n                filterRows(rows),\n                filteredFlatRows,\n                filteredRowsById\n            ];\n        }, [\n            manualFilters,\n            filters,\n            rows,\n            flatRows,\n            rowsById,\n            allColumns,\n            userFilterTypes\n        ]), filteredRows = _React$useMemo[0], filteredFlatRows = _React$useMemo[1], filteredRowsById = _React$useMemo[2];\n        React.useMemo(function() {\n            // Now that each filtered column has it's partially filtered rows,\n            // lets assign the final filtered rows to all of the other columns\n            var nonFilteredColumns = allColumns.filter(function(column) {\n                return !filters.find(function(d) {\n                    return d.id === column.id;\n                });\n            }); // This essentially enables faceted filter options to be built easily\n            // using every column's preFilteredRows value\n            nonFilteredColumns.forEach(function(column) {\n                column.preFilteredRows = filteredRows;\n                column.filteredRows = filteredRows;\n            });\n        }, [\n            filteredRows,\n            filters,\n            allColumns\n        ]);\n        var getAutoResetFilters = useGetLatest(autoResetFilters);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetFilters()) {\n                dispatch({\n                    type: actions.resetFilters\n                });\n            }\n        }, [\n            dispatch,\n            manualFilters ? null : data\n        ]);\n        Object.assign(instance, {\n            preFilteredRows: rows,\n            preFilteredFlatRows: flatRows,\n            preFilteredRowsById: rowsById,\n            filteredRows: filteredRows,\n            filteredFlatRows: filteredFlatRows,\n            filteredRowsById: filteredRowsById,\n            rows: filteredRows,\n            flatRows: filteredFlatRows,\n            rowsById: filteredRowsById,\n            setFilter: setFilter,\n            setAllFilters: setAllFilters\n        });\n    }\n    actions.resetGlobalFilter = \"resetGlobalFilter\";\n    actions.setGlobalFilter = \"setGlobalFilter\";\n    var useGlobalFilter = function useGlobalFilter(hooks) {\n        hooks.stateReducers.push(reducer$3);\n        hooks.useInstance.push(useInstance$3);\n    };\n    useGlobalFilter.pluginName = \"useGlobalFilter\";\n    function reducer$3(state, action, previousState, instance) {\n        if (action.type === actions.resetGlobalFilter) {\n            return _extends({}, state, {\n                globalFilter: instance.initialState.globalFilter || undefined\n            });\n        }\n        if (action.type === actions.setGlobalFilter) {\n            var filterValue = action.filterValue;\n            var userFilterTypes = instance.userFilterTypes;\n            var filterMethod = getFilterMethod(instance.globalFilter, userFilterTypes || {}, filterTypes);\n            var newFilter = functionalUpdate(filterValue, state.globalFilter); //\n            if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter)) {\n                var globalFilter = state.globalFilter, stateWithoutGlobalFilter = _objectWithoutPropertiesLoose(state, [\n                    \"globalFilter\"\n                ]);\n                return stateWithoutGlobalFilter;\n            }\n            return _extends({}, state, {\n                globalFilter: newFilter\n            });\n        }\n    }\n    function useInstance$3(instance) {\n        var data = instance.data, rows = instance.rows, flatRows = instance.flatRows, rowsById = instance.rowsById, allColumns = instance.allColumns, userFilterTypes = instance.filterTypes, globalFilter = instance.globalFilter, manualGlobalFilter = instance.manualGlobalFilter, globalFilterValue = instance.state.globalFilter, dispatch = instance.dispatch, _instance$autoResetGl = instance.autoResetGlobalFilter, autoResetGlobalFilter = _instance$autoResetGl === void 0 ? true : _instance$autoResetGl, disableGlobalFilter = instance.disableGlobalFilter;\n        var setGlobalFilter = React.useCallback(function(filterValue) {\n            dispatch({\n                type: actions.setGlobalFilter,\n                filterValue: filterValue\n            });\n        }, [\n            dispatch\n        ]); // TODO: Create a filter cache for incremental high speed multi-filtering\n        // This gets pretty complicated pretty fast, since you have to maintain a\n        // cache for each row group (top-level rows, and each row's recursive subrows)\n        // This would make multi-filtering a lot faster though. Too far?\n        var _React$useMemo = React.useMemo(function() {\n            if (manualGlobalFilter || typeof globalFilterValue === \"undefined\") {\n                return [\n                    rows,\n                    flatRows,\n                    rowsById\n                ];\n            }\n            var filteredFlatRows = [];\n            var filteredRowsById = {};\n            var filterMethod = getFilterMethod(globalFilter, userFilterTypes || {}, filterTypes);\n            if (!filterMethod) {\n                console.warn(\"Could not find a valid 'globalFilter' option.\");\n                return rows;\n            }\n            allColumns.forEach(function(column) {\n                var columnDisableGlobalFilter = column.disableGlobalFilter;\n                column.canFilter = getFirstDefined(columnDisableGlobalFilter === true ? false : undefined, disableGlobalFilter === true ? false : undefined, true);\n            });\n            var filterableColumns = allColumns.filter(function(c) {\n                return c.canFilter === true;\n            }); // Filters top level and nested rows\n            var filterRows = function filterRows(filteredRows) {\n                filteredRows = filterMethod(filteredRows, filterableColumns.map(function(d) {\n                    return d.id;\n                }), globalFilterValue);\n                filteredRows.forEach(function(row) {\n                    filteredFlatRows.push(row);\n                    filteredRowsById[row.id] = row;\n                    row.subRows = row.subRows && row.subRows.length ? filterRows(row.subRows) : row.subRows;\n                });\n                return filteredRows;\n            };\n            return [\n                filterRows(rows),\n                filteredFlatRows,\n                filteredRowsById\n            ];\n        }, [\n            manualGlobalFilter,\n            globalFilterValue,\n            globalFilter,\n            userFilterTypes,\n            allColumns,\n            rows,\n            flatRows,\n            rowsById,\n            disableGlobalFilter\n        ]), globalFilteredRows = _React$useMemo[0], globalFilteredFlatRows = _React$useMemo[1], globalFilteredRowsById = _React$useMemo[2];\n        var getAutoResetGlobalFilter = useGetLatest(autoResetGlobalFilter);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetGlobalFilter()) {\n                dispatch({\n                    type: actions.resetGlobalFilter\n                });\n            }\n        }, [\n            dispatch,\n            manualGlobalFilter ? null : data\n        ]);\n        Object.assign(instance, {\n            preGlobalFilteredRows: rows,\n            preGlobalFilteredFlatRows: flatRows,\n            preGlobalFilteredRowsById: rowsById,\n            globalFilteredRows: globalFilteredRows,\n            globalFilteredFlatRows: globalFilteredFlatRows,\n            globalFilteredRowsById: globalFilteredRowsById,\n            rows: globalFilteredRows,\n            flatRows: globalFilteredFlatRows,\n            rowsById: globalFilteredRowsById,\n            setGlobalFilter: setGlobalFilter,\n            disableGlobalFilter: disableGlobalFilter\n        });\n    }\n    function sum(values, aggregatedValues) {\n        // It's faster to just add the aggregations together instead of\n        // process leaf nodes individually\n        return aggregatedValues.reduce(function(sum, next) {\n            return sum + (typeof next === \"number\" ? next : 0);\n        }, 0);\n    }\n    function min(values) {\n        var min = values[0] || 0;\n        values.forEach(function(value) {\n            if (typeof value === \"number\") {\n                min = Math.min(min, value);\n            }\n        });\n        return min;\n    }\n    function max(values) {\n        var max = values[0] || 0;\n        values.forEach(function(value) {\n            if (typeof value === \"number\") {\n                max = Math.max(max, value);\n            }\n        });\n        return max;\n    }\n    function minMax(values) {\n        var min = values[0] || 0;\n        var max = values[0] || 0;\n        values.forEach(function(value) {\n            if (typeof value === \"number\") {\n                min = Math.min(min, value);\n                max = Math.max(max, value);\n            }\n        });\n        return min + \"..\" + max;\n    }\n    function average(values) {\n        return sum(null, values) / values.length;\n    }\n    function median(values) {\n        if (!values.length) {\n            return null;\n        }\n        var mid = Math.floor(values.length / 2);\n        var nums = [].concat(values).sort(function(a, b) {\n            return a - b;\n        });\n        return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n    }\n    function unique(values) {\n        return Array.from(new Set(values).values());\n    }\n    function uniqueCount(values) {\n        return new Set(values).size;\n    }\n    function count(values) {\n        return values.length;\n    }\n    var aggregations = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        sum: sum,\n        min: min,\n        max: max,\n        minMax: minMax,\n        average: average,\n        median: median,\n        unique: unique,\n        uniqueCount: uniqueCount,\n        count: count\n    });\n    var emptyArray = [];\n    var emptyObject = {}; // Actions\n    actions.resetGroupBy = \"resetGroupBy\";\n    actions.setGroupBy = \"setGroupBy\";\n    actions.toggleGroupBy = \"toggleGroupBy\";\n    var useGroupBy = function useGroupBy(hooks) {\n        hooks.getGroupByToggleProps = [\n            defaultGetGroupByToggleProps\n        ];\n        hooks.stateReducers.push(reducer$4);\n        hooks.visibleColumnsDeps.push(function(deps, _ref) {\n            var instance = _ref.instance;\n            return [].concat(deps, [\n                instance.state.groupBy\n            ]);\n        });\n        hooks.visibleColumns.push(visibleColumns);\n        hooks.useInstance.push(useInstance$4);\n        hooks.prepareRow.push(prepareRow$1);\n    };\n    useGroupBy.pluginName = \"useGroupBy\";\n    var defaultGetGroupByToggleProps = function defaultGetGroupByToggleProps(props, _ref2) {\n        var header = _ref2.header;\n        return [\n            props,\n            {\n                onClick: header.canGroupBy ? function(e) {\n                    e.persist();\n                    header.toggleGroupBy();\n                } : undefined,\n                style: {\n                    cursor: header.canGroupBy ? \"pointer\" : undefined\n                },\n                title: \"Toggle GroupBy\"\n            }\n        ];\n    }; // Reducer\n    function reducer$4(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                groupBy: []\n            }, state);\n        }\n        if (action.type === actions.resetGroupBy) {\n            return _extends({}, state, {\n                groupBy: instance.initialState.groupBy || []\n            });\n        }\n        if (action.type === actions.setGroupBy) {\n            var value = action.value;\n            return _extends({}, state, {\n                groupBy: value\n            });\n        }\n        if (action.type === actions.toggleGroupBy) {\n            var columnId = action.columnId, setGroupBy = action.value;\n            var resolvedGroupBy = typeof setGroupBy !== \"undefined\" ? setGroupBy : !state.groupBy.includes(columnId);\n            if (resolvedGroupBy) {\n                return _extends({}, state, {\n                    groupBy: [].concat(state.groupBy, [\n                        columnId\n                    ])\n                });\n            }\n            return _extends({}, state, {\n                groupBy: state.groupBy.filter(function(d) {\n                    return d !== columnId;\n                })\n            });\n        }\n    }\n    function visibleColumns(columns, _ref3) {\n        var groupBy = _ref3.instance.state.groupBy;\n        // Sort grouped columns to the start of the column list\n        // before the headers are built\n        var groupByColumns = groupBy.map(function(g) {\n            return columns.find(function(col) {\n                return col.id === g;\n            });\n        }).filter(Boolean);\n        var nonGroupByColumns = columns.filter(function(col) {\n            return !groupBy.includes(col.id);\n        });\n        columns = [].concat(groupByColumns, nonGroupByColumns);\n        columns.forEach(function(column) {\n            column.isGrouped = groupBy.includes(column.id);\n            column.groupedIndex = groupBy.indexOf(column.id);\n        });\n        return columns;\n    }\n    var defaultUserAggregations = {};\n    function useInstance$4(instance) {\n        var data = instance.data, rows = instance.rows, flatRows = instance.flatRows, rowsById = instance.rowsById, allColumns = instance.allColumns, flatHeaders = instance.flatHeaders, _instance$groupByFn = instance.groupByFn, groupByFn = _instance$groupByFn === void 0 ? defaultGroupByFn : _instance$groupByFn, manualGroupBy = instance.manualGroupBy, _instance$aggregation = instance.aggregations, userAggregations = _instance$aggregation === void 0 ? defaultUserAggregations : _instance$aggregation, plugins = instance.plugins, groupBy = instance.state.groupBy, dispatch = instance.dispatch, _instance$autoResetGr = instance.autoResetGroupBy, autoResetGroupBy = _instance$autoResetGr === void 0 ? true : _instance$autoResetGr, disableGroupBy = instance.disableGroupBy, defaultCanGroupBy = instance.defaultCanGroupBy, getHooks = instance.getHooks;\n        ensurePluginOrder(plugins, [\n            \"useColumnOrder\",\n            \"useFilters\"\n        ], \"useGroupBy\");\n        var getInstance = useGetLatest(instance);\n        allColumns.forEach(function(column) {\n            var accessor = column.accessor, defaultColumnGroupBy = column.defaultGroupBy, columnDisableGroupBy = column.disableGroupBy;\n            column.canGroupBy = accessor ? getFirstDefined(column.canGroupBy, columnDisableGroupBy === true ? false : undefined, disableGroupBy === true ? false : undefined, true) : getFirstDefined(column.canGroupBy, defaultColumnGroupBy, defaultCanGroupBy, false);\n            if (column.canGroupBy) {\n                column.toggleGroupBy = function() {\n                    return instance.toggleGroupBy(column.id);\n                };\n            }\n            column.Aggregated = column.Aggregated || column.Cell;\n        });\n        var toggleGroupBy = React.useCallback(function(columnId, value) {\n            dispatch({\n                type: actions.toggleGroupBy,\n                columnId: columnId,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var setGroupBy = React.useCallback(function(value) {\n            dispatch({\n                type: actions.setGroupBy,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        flatHeaders.forEach(function(header) {\n            header.getGroupByToggleProps = makePropGetter(getHooks().getGroupByToggleProps, {\n                instance: getInstance(),\n                header: header\n            });\n        });\n        var _React$useMemo = React.useMemo(function() {\n            if (manualGroupBy || !groupBy.length) {\n                return [\n                    rows,\n                    flatRows,\n                    rowsById,\n                    emptyArray,\n                    emptyObject,\n                    flatRows,\n                    rowsById\n                ];\n            } // Ensure that the list of filtered columns exist\n            var existingGroupBy = groupBy.filter(function(g) {\n                return allColumns.find(function(col) {\n                    return col.id === g;\n                });\n            }); // Find the columns that can or are aggregating\n            // Uses each column to aggregate rows into a single value\n            var aggregateRowsToValues = function aggregateRowsToValues(leafRows, groupedRows, depth) {\n                var values = {};\n                allColumns.forEach(function(column) {\n                    // Don't aggregate columns that are in the groupBy\n                    if (existingGroupBy.includes(column.id)) {\n                        values[column.id] = groupedRows[0] ? groupedRows[0].values[column.id] : null;\n                        return;\n                    } // Aggregate the values\n                    var aggregateFn = typeof column.aggregate === \"function\" ? column.aggregate : userAggregations[column.aggregate] || aggregations[column.aggregate];\n                    if (aggregateFn) {\n                        // Get the columnValues to aggregate\n                        var groupedValues = groupedRows.map(function(row) {\n                            return row.values[column.id];\n                        }); // Get the columnValues to aggregate\n                        var leafValues = leafRows.map(function(row) {\n                            var columnValue = row.values[column.id];\n                            if (!depth && column.aggregateValue) {\n                                var aggregateValueFn = typeof column.aggregateValue === \"function\" ? column.aggregateValue : userAggregations[column.aggregateValue] || aggregations[column.aggregateValue];\n                                if (!aggregateValueFn) {\n                                    console.info({\n                                        column: column\n                                    });\n                                    throw new Error(\"React Table: Invalid column.aggregateValue option for column listed above\");\n                                }\n                                columnValue = aggregateValueFn(columnValue, row, column);\n                            }\n                            return columnValue;\n                        });\n                        values[column.id] = aggregateFn(leafValues, groupedValues);\n                    } else if (column.aggregate) {\n                        console.info({\n                            column: column\n                        });\n                        throw new Error(\"React Table: Invalid column.aggregate option for column listed above\");\n                    } else {\n                        values[column.id] = null;\n                    }\n                });\n                return values;\n            };\n            var groupedFlatRows = [];\n            var groupedRowsById = {};\n            var onlyGroupedFlatRows = [];\n            var onlyGroupedRowsById = {};\n            var nonGroupedFlatRows = [];\n            var nonGroupedRowsById = {}; // Recursively group the data\n            var groupUpRecursively = function groupUpRecursively(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // This is the last level, just return the rows\n                if (depth === existingGroupBy.length) {\n                    return rows.map(function(row) {\n                        return _extends({}, row, {\n                            depth: depth\n                        });\n                    });\n                }\n                var columnId = existingGroupBy[depth]; // Group the rows together for this level\n                var rowGroupsMap = groupByFn(rows, columnId); // Peform aggregations for each group\n                var aggregatedGroupedRows = Object.entries(rowGroupsMap).map(function(_ref4, index) {\n                    var groupByVal = _ref4[0], groupedRows = _ref4[1];\n                    var id = columnId + \":\" + groupByVal;\n                    id = parentId ? parentId + \">\" + id : id; // First, Recurse to group sub rows before aggregation\n                    var subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group\n                    var leafRows = depth ? flattenBy(groupedRows, \"leafRows\") : groupedRows;\n                    var values = aggregateRowsToValues(leafRows, groupedRows, depth);\n                    var row = {\n                        id: id,\n                        isGrouped: true,\n                        groupByID: columnId,\n                        groupByVal: groupByVal,\n                        values: values,\n                        subRows: subRows,\n                        leafRows: leafRows,\n                        depth: depth,\n                        index: index\n                    };\n                    subRows.forEach(function(subRow) {\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                        if (subRow.isGrouped) {\n                            onlyGroupedFlatRows.push(subRow);\n                            onlyGroupedRowsById[subRow.id] = subRow;\n                        } else {\n                            nonGroupedFlatRows.push(subRow);\n                            nonGroupedRowsById[subRow.id] = subRow;\n                        }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            var groupedRows = groupUpRecursively(rows);\n            groupedRows.forEach(function(subRow) {\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n                if (subRow.isGrouped) {\n                    onlyGroupedFlatRows.push(subRow);\n                    onlyGroupedRowsById[subRow.id] = subRow;\n                } else {\n                    nonGroupedFlatRows.push(subRow);\n                    nonGroupedRowsById[subRow.id] = subRow;\n                }\n            }); // Assign the new data\n            return [\n                groupedRows,\n                groupedFlatRows,\n                groupedRowsById,\n                onlyGroupedFlatRows,\n                onlyGroupedRowsById,\n                nonGroupedFlatRows,\n                nonGroupedRowsById\n            ];\n        }, [\n            manualGroupBy,\n            groupBy,\n            rows,\n            flatRows,\n            rowsById,\n            allColumns,\n            userAggregations,\n            groupByFn\n        ]), groupedRows = _React$useMemo[0], groupedFlatRows = _React$useMemo[1], groupedRowsById = _React$useMemo[2], onlyGroupedFlatRows = _React$useMemo[3], onlyGroupedRowsById = _React$useMemo[4], nonGroupedFlatRows = _React$useMemo[5], nonGroupedRowsById = _React$useMemo[6];\n        var getAutoResetGroupBy = useGetLatest(autoResetGroupBy);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetGroupBy()) {\n                dispatch({\n                    type: actions.resetGroupBy\n                });\n            }\n        }, [\n            dispatch,\n            manualGroupBy ? null : data\n        ]);\n        Object.assign(instance, {\n            preGroupedRows: rows,\n            preGroupedFlatRow: flatRows,\n            preGroupedRowsById: rowsById,\n            groupedRows: groupedRows,\n            groupedFlatRows: groupedFlatRows,\n            groupedRowsById: groupedRowsById,\n            onlyGroupedFlatRows: onlyGroupedFlatRows,\n            onlyGroupedRowsById: onlyGroupedRowsById,\n            nonGroupedFlatRows: nonGroupedFlatRows,\n            nonGroupedRowsById: nonGroupedRowsById,\n            rows: groupedRows,\n            flatRows: groupedFlatRows,\n            rowsById: groupedRowsById,\n            toggleGroupBy: toggleGroupBy,\n            setGroupBy: setGroupBy\n        });\n    }\n    function prepareRow$1(row) {\n        row.allCells.forEach(function(cell) {\n            var _row$subRows;\n            // Grouped cells are in the groupBy and the pivot cell for the row\n            cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Placeholder cells are any columns in the groupBy that are not grouped\n            cell.isPlaceholder = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows\n            cell.isAggregated = !cell.isGrouped && !cell.isPlaceholder && ((_row$subRows = row.subRows) == null ? void 0 : _row$subRows.length);\n        });\n    }\n    function defaultGroupByFn(rows, columnId) {\n        return rows.reduce(function(prev, row, i) {\n            // TODO: Might want to implement a key serializer here so\n            // irregular column values can still be grouped if needed?\n            var resKey = \"\" + row.values[columnId];\n            prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];\n            prev[resKey].push(row);\n            return prev;\n        }, {});\n    }\n    var reSplitAlphaNumeric = /([0-9]+)/gm; // Mixed sorting is slow, but very inclusive of many edge cases.\n    // It handles numbers, mixed alphanumeric combinations, and even\n    // null, undefined, and Infinity\n    var alphanumeric = function alphanumeric(rowA, rowB, columnId) {\n        var _getRowValuesByColumn = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn[0], b = _getRowValuesByColumn[1]; // Force to strings (or \"\" for unsupported types)\n        a = toString(a);\n        b = toString(b); // Split on number groups, but keep the delimiter\n        // Then remove falsey split values\n        a = a.split(reSplitAlphaNumeric).filter(Boolean);\n        b = b.split(reSplitAlphaNumeric).filter(Boolean); // While\n        while(a.length && b.length){\n            var aa = a.shift();\n            var bb = b.shift();\n            var an = parseInt(aa, 10);\n            var bn = parseInt(bb, 10);\n            var combo = [\n                an,\n                bn\n            ].sort(); // Both are string\n            if (isNaN(combo[0])) {\n                if (aa > bb) {\n                    return 1;\n                }\n                if (bb > aa) {\n                    return -1;\n                }\n                continue;\n            } // One is a string, one is a number\n            if (isNaN(combo[1])) {\n                return isNaN(an) ? -1 : 1;\n            } // Both are numbers\n            if (an > bn) {\n                return 1;\n            }\n            if (bn > an) {\n                return -1;\n            }\n        }\n        return a.length - b.length;\n    };\n    function datetime(rowA, rowB, columnId) {\n        var _getRowValuesByColumn2 = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn2[0], b = _getRowValuesByColumn2[1];\n        a = a.getTime();\n        b = b.getTime();\n        return compareBasic(a, b);\n    }\n    function basic(rowA, rowB, columnId) {\n        var _getRowValuesByColumn3 = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn3[0], b = _getRowValuesByColumn3[1];\n        return compareBasic(a, b);\n    }\n    function string(rowA, rowB, columnId) {\n        var _getRowValuesByColumn4 = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn4[0], b = _getRowValuesByColumn4[1];\n        a = a.split(\"\").filter(Boolean);\n        b = b.split(\"\").filter(Boolean);\n        while(a.length && b.length){\n            var aa = a.shift();\n            var bb = b.shift();\n            var alower = aa.toLowerCase();\n            var blower = bb.toLowerCase(); // Case insensitive comparison until characters match\n            if (alower > blower) {\n                return 1;\n            }\n            if (blower > alower) {\n                return -1;\n            } // If lowercase characters are identical\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        return a.length - b.length;\n    }\n    function number(rowA, rowB, columnId) {\n        var _getRowValuesByColumn5 = getRowValuesByColumnID(rowA, rowB, columnId), a = _getRowValuesByColumn5[0], b = _getRowValuesByColumn5[1];\n        var replaceNonNumeric = /[^0-9.]/gi;\n        a = Number(String(a).replace(replaceNonNumeric, \"\"));\n        b = Number(String(b).replace(replaceNonNumeric, \"\"));\n        return compareBasic(a, b);\n    } // Utils\n    function compareBasic(a, b) {\n        return a === b ? 0 : a > b ? 1 : -1;\n    }\n    function getRowValuesByColumnID(row1, row2, columnId) {\n        return [\n            row1.values[columnId],\n            row2.values[columnId]\n        ];\n    }\n    function toString(a) {\n        if (typeof a === \"number\") {\n            if (isNaN(a) || a === Infinity || a === -Infinity) {\n                return \"\";\n            }\n            return String(a);\n        }\n        if (typeof a === \"string\") {\n            return a;\n        }\n        return \"\";\n    }\n    var sortTypes = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        alphanumeric: alphanumeric,\n        datetime: datetime,\n        basic: basic,\n        string: string,\n        number: number\n    });\n    actions.resetSortBy = \"resetSortBy\";\n    actions.setSortBy = \"setSortBy\";\n    actions.toggleSortBy = \"toggleSortBy\";\n    actions.clearSortBy = \"clearSortBy\";\n    defaultColumn.sortType = \"alphanumeric\";\n    defaultColumn.sortDescFirst = false;\n    var useSortBy = function useSortBy(hooks) {\n        hooks.getSortByToggleProps = [\n            defaultGetSortByToggleProps\n        ];\n        hooks.stateReducers.push(reducer$5);\n        hooks.useInstance.push(useInstance$5);\n    };\n    useSortBy.pluginName = \"useSortBy\";\n    var defaultGetSortByToggleProps = function defaultGetSortByToggleProps(props, _ref) {\n        var instance = _ref.instance, column = _ref.column;\n        var _instance$isMultiSort = instance.isMultiSortEvent, isMultiSortEvent = _instance$isMultiSort === void 0 ? function(e) {\n            return e.shiftKey;\n        } : _instance$isMultiSort;\n        return [\n            props,\n            {\n                onClick: column.canSort ? function(e) {\n                    e.persist();\n                    column.toggleSortBy(undefined, !instance.disableMultiSort && isMultiSortEvent(e));\n                } : undefined,\n                style: {\n                    cursor: column.canSort ? \"pointer\" : undefined\n                },\n                title: column.canSort ? \"Toggle SortBy\" : undefined\n            }\n        ];\n    }; // Reducer\n    function reducer$5(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                sortBy: []\n            }, state);\n        }\n        if (action.type === actions.resetSortBy) {\n            return _extends({}, state, {\n                sortBy: instance.initialState.sortBy || []\n            });\n        }\n        if (action.type === actions.clearSortBy) {\n            var sortBy = state.sortBy;\n            var newSortBy = sortBy.filter(function(d) {\n                return d.id !== action.columnId;\n            });\n            return _extends({}, state, {\n                sortBy: newSortBy\n            });\n        }\n        if (action.type === actions.setSortBy) {\n            var _sortBy = action.sortBy;\n            return _extends({}, state, {\n                sortBy: _sortBy\n            });\n        }\n        if (action.type === actions.toggleSortBy) {\n            var columnId = action.columnId, desc = action.desc, multi = action.multi;\n            var allColumns = instance.allColumns, disableMultiSort = instance.disableMultiSort, disableSortRemove = instance.disableSortRemove, disableMultiRemove = instance.disableMultiRemove, _instance$maxMultiSor = instance.maxMultiSortColCount, maxMultiSortColCount = _instance$maxMultiSor === void 0 ? Number.MAX_SAFE_INTEGER : _instance$maxMultiSor;\n            var _sortBy2 = state.sortBy; // Find the column for this columnId\n            var column = allColumns.find(function(d) {\n                return d.id === columnId;\n            });\n            var sortDescFirst = column.sortDescFirst; // Find any existing sortBy for this column\n            var existingSortBy = _sortBy2.find(function(d) {\n                return d.id === columnId;\n            });\n            var existingIndex = _sortBy2.findIndex(function(d) {\n                return d.id === columnId;\n            });\n            var hasDescDefined = typeof desc !== \"undefined\" && desc !== null;\n            var _newSortBy = []; // What should we do with this sort action?\n            var sortAction;\n            if (!disableMultiSort && multi) {\n                if (existingSortBy) {\n                    sortAction = \"toggle\";\n                } else {\n                    sortAction = \"add\";\n                }\n            } else {\n                // Normal mode\n                if (existingIndex !== _sortBy2.length - 1 || _sortBy2.length !== 1) {\n                    sortAction = \"replace\";\n                } else if (existingSortBy) {\n                    sortAction = \"toggle\";\n                } else {\n                    sortAction = \"replace\";\n                }\n            } // Handle toggle states that will remove the sortBy\n            if (sortAction === \"toggle\" && // Must be toggling\n            !disableSortRemove && // If disableSortRemove, disable in general\n            !hasDescDefined && (multi ? !disableMultiRemove : true) && (existingSortBy && // Finally, detect if it should indeed be removed\n            existingSortBy.desc && !sortDescFirst || !existingSortBy.desc && sortDescFirst)) {\n                sortAction = \"remove\";\n            }\n            if (sortAction === \"replace\") {\n                _newSortBy = [\n                    {\n                        id: columnId,\n                        desc: hasDescDefined ? desc : sortDescFirst\n                    }\n                ];\n            } else if (sortAction === \"add\") {\n                _newSortBy = [].concat(_sortBy2, [\n                    {\n                        id: columnId,\n                        desc: hasDescDefined ? desc : sortDescFirst\n                    }\n                ]); // Take latest n columns\n                _newSortBy.splice(0, _newSortBy.length - maxMultiSortColCount);\n            } else if (sortAction === \"toggle\") {\n                // This flips (or sets) the\n                _newSortBy = _sortBy2.map(function(d) {\n                    if (d.id === columnId) {\n                        return _extends({}, d, {\n                            desc: hasDescDefined ? desc : !existingSortBy.desc\n                        });\n                    }\n                    return d;\n                });\n            } else if (sortAction === \"remove\") {\n                _newSortBy = _sortBy2.filter(function(d) {\n                    return d.id !== columnId;\n                });\n            }\n            return _extends({}, state, {\n                sortBy: _newSortBy\n            });\n        }\n    }\n    function useInstance$5(instance) {\n        var data = instance.data, rows = instance.rows, flatRows = instance.flatRows, allColumns = instance.allColumns, _instance$orderByFn = instance.orderByFn, orderByFn = _instance$orderByFn === void 0 ? defaultOrderByFn : _instance$orderByFn, userSortTypes = instance.sortTypes, manualSortBy = instance.manualSortBy, defaultCanSort = instance.defaultCanSort, disableSortBy = instance.disableSortBy, flatHeaders = instance.flatHeaders, sortBy = instance.state.sortBy, dispatch = instance.dispatch, plugins = instance.plugins, getHooks = instance.getHooks, _instance$autoResetSo = instance.autoResetSortBy, autoResetSortBy = _instance$autoResetSo === void 0 ? true : _instance$autoResetSo;\n        ensurePluginOrder(plugins, [\n            \"useFilters\",\n            \"useGlobalFilter\",\n            \"useGroupBy\",\n            \"usePivotColumns\"\n        ], \"useSortBy\");\n        var setSortBy = React.useCallback(function(sortBy) {\n            dispatch({\n                type: actions.setSortBy,\n                sortBy: sortBy\n            });\n        }, [\n            dispatch\n        ]); // Updates sorting based on a columnId, desc flag and multi flag\n        var toggleSortBy = React.useCallback(function(columnId, desc, multi) {\n            dispatch({\n                type: actions.toggleSortBy,\n                columnId: columnId,\n                desc: desc,\n                multi: multi\n            });\n        }, [\n            dispatch\n        ]); // use reference to avoid memory leak in #1608\n        var getInstance = useGetLatest(instance); // Add the getSortByToggleProps method to columns and headers\n        flatHeaders.forEach(function(column) {\n            var accessor = column.accessor, defaultColumnCanSort = column.canSort, columnDisableSortBy = column.disableSortBy, id = column.id;\n            var canSort = accessor ? getFirstDefined(columnDisableSortBy === true ? false : undefined, disableSortBy === true ? false : undefined, true) : getFirstDefined(defaultCanSort, defaultColumnCanSort, false);\n            column.canSort = canSort;\n            if (column.canSort) {\n                column.toggleSortBy = function(desc, multi) {\n                    return toggleSortBy(column.id, desc, multi);\n                };\n                column.clearSortBy = function() {\n                    dispatch({\n                        type: actions.clearSortBy,\n                        columnId: column.id\n                    });\n                };\n            }\n            column.getSortByToggleProps = makePropGetter(getHooks().getSortByToggleProps, {\n                instance: getInstance(),\n                column: column\n            });\n            var columnSort = sortBy.find(function(d) {\n                return d.id === id;\n            });\n            column.isSorted = !!columnSort;\n            column.sortedIndex = sortBy.findIndex(function(d) {\n                return d.id === id;\n            });\n            column.isSortedDesc = column.isSorted ? columnSort.desc : undefined;\n        });\n        var _React$useMemo = React.useMemo(function() {\n            if (manualSortBy || !sortBy.length) {\n                return [\n                    rows,\n                    flatRows\n                ];\n            }\n            var sortedFlatRows = []; // Filter out sortBys that correspond to non existing columns\n            var availableSortBy = sortBy.filter(function(sort) {\n                return allColumns.find(function(col) {\n                    return col.id === sort.id;\n                });\n            });\n            var sortData = function sortData(rows) {\n                // Use the orderByFn to compose multiple sortBy's together.\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                var sortedData = orderByFn(rows, availableSortBy.map(function(sort) {\n                    // Support custom sorting methods for each column\n                    var column = allColumns.find(function(d) {\n                        return d.id === sort.id;\n                    });\n                    if (!column) {\n                        throw new Error(\"React-Table: Could not find a column with id: \" + sort.id + \" while sorting\");\n                    }\n                    var sortType = column.sortType; // Look up sortBy functions in this order:\n                    // column function\n                    // column string lookup on user sortType\n                    // column string lookup on built-in sortType\n                    // default function\n                    // default string lookup on user sortType\n                    // default string lookup on built-in sortType\n                    var sortMethod = isFunction(sortType) || (userSortTypes || {})[sortType] || sortTypes[sortType];\n                    if (!sortMethod) {\n                        throw new Error(\"React-Table: Could not find a valid sortType of '\" + sortType + \"' for column '\" + sort.id + \"'.\");\n                    } // Return the correct sortFn.\n                    // This function should always return in ascending order\n                    return function(a, b) {\n                        return sortMethod(a, b, sort.id, sort.desc);\n                    };\n                }), availableSortBy.map(function(sort) {\n                    // Detect and use the sortInverted option\n                    var column = allColumns.find(function(d) {\n                        return d.id === sort.id;\n                    });\n                    if (column && column.sortInverted) {\n                        return sort.desc;\n                    }\n                    return !sort.desc;\n                })); // If there are sub-rows, sort them\n                sortedData.forEach(function(row) {\n                    sortedFlatRows.push(row);\n                    if (!row.subRows || row.subRows.length === 0) {\n                        return;\n                    }\n                    row.subRows = sortData(row.subRows);\n                });\n                return sortedData;\n            };\n            return [\n                sortData(rows),\n                sortedFlatRows\n            ];\n        }, [\n            manualSortBy,\n            sortBy,\n            rows,\n            flatRows,\n            allColumns,\n            orderByFn,\n            userSortTypes\n        ]), sortedRows = _React$useMemo[0], sortedFlatRows = _React$useMemo[1];\n        var getAutoResetSortBy = useGetLatest(autoResetSortBy);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetSortBy()) {\n                dispatch({\n                    type: actions.resetSortBy\n                });\n            }\n        }, [\n            manualSortBy ? null : data\n        ]);\n        Object.assign(instance, {\n            preSortedRows: rows,\n            preSortedFlatRows: flatRows,\n            sortedRows: sortedRows,\n            sortedFlatRows: sortedFlatRows,\n            rows: sortedRows,\n            flatRows: sortedFlatRows,\n            setSortBy: setSortBy,\n            toggleSortBy: toggleSortBy\n        });\n    }\n    function defaultOrderByFn(arr, funcs, dirs) {\n        return [].concat(arr).sort(function(rowA, rowB) {\n            for(var i = 0; i < funcs.length; i += 1){\n                var sortFn = funcs[i];\n                var desc = dirs[i] === false || dirs[i] === \"desc\";\n                var sortInt = sortFn(rowA, rowB);\n                if (sortInt !== 0) {\n                    return desc ? -sortInt : sortInt;\n                }\n            }\n            return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index;\n        });\n    }\n    var pluginName = \"usePagination\"; // Actions\n    actions.resetPage = \"resetPage\";\n    actions.gotoPage = \"gotoPage\";\n    actions.setPageSize = \"setPageSize\";\n    var usePagination = function usePagination(hooks) {\n        hooks.stateReducers.push(reducer$6);\n        hooks.useInstance.push(useInstance$6);\n    };\n    usePagination.pluginName = pluginName;\n    function reducer$6(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                pageSize: 10,\n                pageIndex: 0\n            }, state);\n        }\n        if (action.type === actions.resetPage) {\n            return _extends({}, state, {\n                pageIndex: instance.initialState.pageIndex || 0\n            });\n        }\n        if (action.type === actions.gotoPage) {\n            var pageCount = instance.pageCount, page = instance.page;\n            var newPageIndex = functionalUpdate(action.pageIndex, state.pageIndex);\n            var canNavigate = false;\n            if (newPageIndex > state.pageIndex) {\n                // next page\n                canNavigate = pageCount === -1 ? page.length >= state.pageSize : newPageIndex < pageCount;\n            } else if (newPageIndex < state.pageIndex) {\n                // prev page\n                canNavigate = newPageIndex > -1;\n            }\n            if (!canNavigate) {\n                return state;\n            }\n            return _extends({}, state, {\n                pageIndex: newPageIndex\n            });\n        }\n        if (action.type === actions.setPageSize) {\n            var pageSize = action.pageSize;\n            var topRowIndex = state.pageSize * state.pageIndex;\n            var pageIndex = Math.floor(topRowIndex / pageSize);\n            return _extends({}, state, {\n                pageIndex: pageIndex,\n                pageSize: pageSize\n            });\n        }\n    }\n    function useInstance$6(instance) {\n        var rows = instance.rows, _instance$autoResetPa = instance.autoResetPage, autoResetPage = _instance$autoResetPa === void 0 ? true : _instance$autoResetPa, _instance$manualExpan = instance.manualExpandedKey, manualExpandedKey = _instance$manualExpan === void 0 ? \"expanded\" : _instance$manualExpan, plugins = instance.plugins, userPageCount = instance.pageCount, _instance$paginateExp = instance.paginateExpandedRows, paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp, _instance$expandSubRo = instance.expandSubRows, expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo, _instance$state = instance.state, pageSize = _instance$state.pageSize, pageIndex = _instance$state.pageIndex, expanded = _instance$state.expanded, globalFilter = _instance$state.globalFilter, filters = _instance$state.filters, groupBy = _instance$state.groupBy, sortBy = _instance$state.sortBy, dispatch = instance.dispatch, data = instance.data, manualPagination = instance.manualPagination;\n        ensurePluginOrder(plugins, [\n            \"useGlobalFilter\",\n            \"useFilters\",\n            \"useGroupBy\",\n            \"useSortBy\",\n            \"useExpanded\"\n        ], \"usePagination\");\n        var getAutoResetPage = useGetLatest(autoResetPage);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetPage()) {\n                dispatch({\n                    type: actions.resetPage\n                });\n            }\n        }, [\n            dispatch,\n            manualPagination ? null : data,\n            globalFilter,\n            filters,\n            groupBy,\n            sortBy\n        ]);\n        var pageCount = manualPagination ? userPageCount : Math.ceil(rows.length / pageSize);\n        var pageOptions = React.useMemo(function() {\n            return pageCount > 0 ? [].concat(new Array(pageCount)).fill(null).map(function(d, i) {\n                return i;\n            }) : [];\n        }, [\n            pageCount\n        ]);\n        var page = React.useMemo(function() {\n            var page;\n            if (manualPagination) {\n                page = rows;\n            } else {\n                var pageStart = pageSize * pageIndex;\n                var pageEnd = pageStart + pageSize;\n                page = rows.slice(pageStart, pageEnd);\n            }\n            if (paginateExpandedRows) {\n                return page;\n            }\n            return expandRows(page, {\n                manualExpandedKey: manualExpandedKey,\n                expanded: expanded,\n                expandSubRows: expandSubRows\n            });\n        }, [\n            expandSubRows,\n            expanded,\n            manualExpandedKey,\n            manualPagination,\n            pageIndex,\n            pageSize,\n            paginateExpandedRows,\n            rows\n        ]);\n        var canPreviousPage = pageIndex > 0;\n        var canNextPage = pageCount === -1 ? page.length >= pageSize : pageIndex < pageCount - 1;\n        var gotoPage = React.useCallback(function(pageIndex) {\n            dispatch({\n                type: actions.gotoPage,\n                pageIndex: pageIndex\n            });\n        }, [\n            dispatch\n        ]);\n        var previousPage = React.useCallback(function() {\n            return gotoPage(function(old) {\n                return old - 1;\n            });\n        }, [\n            gotoPage\n        ]);\n        var nextPage = React.useCallback(function() {\n            return gotoPage(function(old) {\n                return old + 1;\n            });\n        }, [\n            gotoPage\n        ]);\n        var setPageSize = React.useCallback(function(pageSize) {\n            dispatch({\n                type: actions.setPageSize,\n                pageSize: pageSize\n            });\n        }, [\n            dispatch\n        ]);\n        Object.assign(instance, {\n            pageOptions: pageOptions,\n            pageCount: pageCount,\n            page: page,\n            canPreviousPage: canPreviousPage,\n            canNextPage: canNextPage,\n            gotoPage: gotoPage,\n            previousPage: previousPage,\n            nextPage: nextPage,\n            setPageSize: setPageSize\n        });\n    }\n    actions.resetPivot = \"resetPivot\";\n    actions.togglePivot = \"togglePivot\";\n    var _UNSTABLE_usePivotColumns = function _UNSTABLE_usePivotColumns(hooks) {\n        hooks.getPivotToggleProps = [\n            defaultGetPivotToggleProps\n        ];\n        hooks.stateReducers.push(reducer$7);\n        hooks.useInstanceAfterData.push(useInstanceAfterData);\n        hooks.allColumns.push(allColumns);\n        hooks.accessValue.push(accessValue);\n        hooks.materializedColumns.push(materializedColumns);\n        hooks.materializedColumnsDeps.push(materializedColumnsDeps);\n        hooks.visibleColumns.push(visibleColumns$1);\n        hooks.visibleColumnsDeps.push(visibleColumnsDeps);\n        hooks.useInstance.push(useInstance$7);\n        hooks.prepareRow.push(prepareRow$2);\n    };\n    _UNSTABLE_usePivotColumns.pluginName = \"usePivotColumns\";\n    var defaultPivotColumns = [];\n    var defaultGetPivotToggleProps = function defaultGetPivotToggleProps(props, _ref) {\n        var header = _ref.header;\n        return [\n            props,\n            {\n                onClick: header.canPivot ? function(e) {\n                    e.persist();\n                    header.togglePivot();\n                } : undefined,\n                style: {\n                    cursor: header.canPivot ? \"pointer\" : undefined\n                },\n                title: \"Toggle Pivot\"\n            }\n        ];\n    }; // Reducer\n    function reducer$7(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                pivotColumns: defaultPivotColumns\n            }, state);\n        }\n        if (action.type === actions.resetPivot) {\n            return _extends({}, state, {\n                pivotColumns: instance.initialState.pivotColumns || defaultPivotColumns\n            });\n        }\n        if (action.type === actions.togglePivot) {\n            var columnId = action.columnId, setPivot = action.value;\n            var resolvedPivot = typeof setPivot !== \"undefined\" ? setPivot : !state.pivotColumns.includes(columnId);\n            if (resolvedPivot) {\n                return _extends({}, state, {\n                    pivotColumns: [].concat(state.pivotColumns, [\n                        columnId\n                    ])\n                });\n            }\n            return _extends({}, state, {\n                pivotColumns: state.pivotColumns.filter(function(d) {\n                    return d !== columnId;\n                })\n            });\n        }\n    }\n    function useInstanceAfterData(instance) {\n        instance.allColumns.forEach(function(column) {\n            column.isPivotSource = instance.state.pivotColumns.includes(column.id);\n        });\n    }\n    function allColumns(columns, _ref2) {\n        var instance = _ref2.instance;\n        columns.forEach(function(column) {\n            column.isPivotSource = instance.state.pivotColumns.includes(column.id);\n            column.uniqueValues = new Set();\n        });\n        return columns;\n    }\n    function accessValue(value, _ref3) {\n        var column = _ref3.column;\n        if (column.uniqueValues && typeof value !== \"undefined\") {\n            column.uniqueValues.add(value);\n        }\n        return value;\n    }\n    function materializedColumns(materialized, _ref4) {\n        var instance = _ref4.instance;\n        var allColumns = instance.allColumns, state = instance.state;\n        if (!state.pivotColumns.length || !state.groupBy || !state.groupBy.length) {\n            return materialized;\n        }\n        var pivotColumns = state.pivotColumns.map(function(id) {\n            return allColumns.find(function(d) {\n                return d.id === id;\n            });\n        }).filter(Boolean);\n        var sourceColumns = allColumns.filter(function(d) {\n            return !d.isPivotSource && !state.groupBy.includes(d.id) && !state.pivotColumns.includes(d.id);\n        });\n        var buildPivotColumns = function buildPivotColumns(depth, parent, pivotFilters) {\n            if (depth === void 0) {\n                depth = 0;\n            }\n            if (pivotFilters === void 0) {\n                pivotFilters = [];\n            }\n            var pivotColumn = pivotColumns[depth];\n            if (!pivotColumn) {\n                return sourceColumns.map(function(sourceColumn) {\n                    // TODO: We could offer support here for renesting pivoted\n                    // columns inside copies of their header groups. For now,\n                    // that seems like it would be (1) overkill on nesting, considering\n                    // you already get nesting for every pivot level and (2)\n                    // really hard. :)\n                    return _extends({}, sourceColumn, {\n                        canPivot: false,\n                        isPivoted: true,\n                        parent: parent,\n                        depth: depth,\n                        id: \"\" + (parent ? parent.id + \".\" + sourceColumn.id : sourceColumn.id),\n                        accessor: function accessor(originalRow, i, row) {\n                            if (pivotFilters.every(function(filter) {\n                                return filter(row);\n                            })) {\n                                return row.values[sourceColumn.id];\n                            }\n                        }\n                    });\n                });\n            }\n            var uniqueValues = Array.from(pivotColumn.uniqueValues).sort();\n            return uniqueValues.map(function(uniqueValue) {\n                var columnGroup = _extends({}, pivotColumn, {\n                    Header: pivotColumn.PivotHeader || typeof pivotColumn.header === \"string\" ? pivotColumn.Header + \": \" + uniqueValue : uniqueValue,\n                    isPivotGroup: true,\n                    parent: parent,\n                    depth: depth,\n                    id: parent ? parent.id + \".\" + pivotColumn.id + \".\" + uniqueValue : pivotColumn.id + \".\" + uniqueValue,\n                    pivotValue: uniqueValue\n                });\n                columnGroup.columns = buildPivotColumns(depth + 1, columnGroup, [].concat(pivotFilters, [\n                    function(row) {\n                        return row.values[pivotColumn.id] === uniqueValue;\n                    }\n                ]));\n                return columnGroup;\n            });\n        };\n        var newMaterialized = flattenColumns(buildPivotColumns());\n        return [].concat(materialized, newMaterialized);\n    }\n    function materializedColumnsDeps(deps, _ref5) {\n        var _ref5$instance$state = _ref5.instance.state, pivotColumns = _ref5$instance$state.pivotColumns, groupBy = _ref5$instance$state.groupBy;\n        return [].concat(deps, [\n            pivotColumns,\n            groupBy\n        ]);\n    }\n    function visibleColumns$1(visibleColumns, _ref6) {\n        var state = _ref6.instance.state;\n        visibleColumns = visibleColumns.filter(function(d) {\n            return !d.isPivotSource;\n        });\n        if (state.pivotColumns.length && state.groupBy && state.groupBy.length) {\n            visibleColumns = visibleColumns.filter(function(column) {\n                return column.isGrouped || column.isPivoted;\n            });\n        }\n        return visibleColumns;\n    }\n    function visibleColumnsDeps(deps, _ref7) {\n        var instance = _ref7.instance;\n        return [].concat(deps, [\n            instance.state.pivotColumns,\n            instance.state.groupBy\n        ]);\n    }\n    function useInstance$7(instance) {\n        var columns = instance.columns, allColumns = instance.allColumns, flatHeaders = instance.flatHeaders, getHooks = instance.getHooks, plugins = instance.plugins, dispatch = instance.dispatch, _instance$autoResetPi = instance.autoResetPivot, autoResetPivot = _instance$autoResetPi === void 0 ? true : _instance$autoResetPi, manaulPivot = instance.manaulPivot, disablePivot = instance.disablePivot, defaultCanPivot = instance.defaultCanPivot;\n        ensurePluginOrder(plugins, [\n            \"useGroupBy\"\n        ], \"usePivotColumns\");\n        var getInstance = useGetLatest(instance);\n        allColumns.forEach(function(column) {\n            var accessor = column.accessor, defaultColumnPivot = column.defaultPivot, columnDisablePivot = column.disablePivot;\n            column.canPivot = accessor ? getFirstDefined(column.canPivot, columnDisablePivot === true ? false : undefined, disablePivot === true ? false : undefined, true) : getFirstDefined(column.canPivot, defaultColumnPivot, defaultCanPivot, false);\n            if (column.canPivot) {\n                column.togglePivot = function() {\n                    return instance.togglePivot(column.id);\n                };\n            }\n            column.Aggregated = column.Aggregated || column.Cell;\n        });\n        var togglePivot = function togglePivot(columnId, value) {\n            dispatch({\n                type: actions.togglePivot,\n                columnId: columnId,\n                value: value\n            });\n        };\n        flatHeaders.forEach(function(header) {\n            header.getPivotToggleProps = makePropGetter(getHooks().getPivotToggleProps, {\n                instance: getInstance(),\n                header: header\n            });\n        });\n        var getAutoResetPivot = useGetLatest(autoResetPivot);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetPivot()) {\n                dispatch({\n                    type: actions.resetPivot\n                });\n            }\n        }, [\n            dispatch,\n            manaulPivot ? null : columns\n        ]);\n        Object.assign(instance, {\n            togglePivot: togglePivot\n        });\n    }\n    function prepareRow$2(row) {\n        row.allCells.forEach(function(cell) {\n            // Grouped cells are in the pivotColumns and the pivot cell for the row\n            cell.isPivoted = cell.column.isPivoted;\n        });\n    }\n    var pluginName$1 = \"useRowSelect\"; // Actions\n    actions.resetSelectedRows = \"resetSelectedRows\";\n    actions.toggleAllRowsSelected = \"toggleAllRowsSelected\";\n    actions.toggleRowSelected = \"toggleRowSelected\";\n    actions.toggleAllPageRowsSelected = \"toggleAllPageRowsSelected\";\n    var useRowSelect = function useRowSelect(hooks) {\n        hooks.getToggleRowSelectedProps = [\n            defaultGetToggleRowSelectedProps\n        ];\n        hooks.getToggleAllRowsSelectedProps = [\n            defaultGetToggleAllRowsSelectedProps\n        ];\n        hooks.getToggleAllPageRowsSelectedProps = [\n            defaultGetToggleAllPageRowsSelectedProps\n        ];\n        hooks.stateReducers.push(reducer$8);\n        hooks.useInstance.push(useInstance$8);\n        hooks.prepareRow.push(prepareRow$3);\n    };\n    useRowSelect.pluginName = pluginName$1;\n    var defaultGetToggleRowSelectedProps = function defaultGetToggleRowSelectedProps(props, _ref) {\n        var instance = _ref.instance, row = _ref.row;\n        var _instance$manualRowSe = instance.manualRowSelectedKey, manualRowSelectedKey = _instance$manualRowSe === void 0 ? \"isSelected\" : _instance$manualRowSe;\n        var checked = false;\n        if (row.original && row.original[manualRowSelectedKey]) {\n            checked = true;\n        } else {\n            checked = row.isSelected;\n        }\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    row.toggleRowSelected(e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: checked,\n                title: \"Toggle Row Selected\",\n                indeterminate: row.isSomeSelected\n            }\n        ];\n    };\n    var defaultGetToggleAllRowsSelectedProps = function defaultGetToggleAllRowsSelectedProps(props, _ref2) {\n        var instance = _ref2.instance;\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    instance.toggleAllRowsSelected(e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: instance.isAllRowsSelected,\n                title: \"Toggle All Rows Selected\",\n                indeterminate: Boolean(!instance.isAllRowsSelected && Object.keys(instance.state.selectedRowIds).length)\n            }\n        ];\n    };\n    var defaultGetToggleAllPageRowsSelectedProps = function defaultGetToggleAllPageRowsSelectedProps(props, _ref3) {\n        var instance = _ref3.instance;\n        return [\n            props,\n            {\n                onChange: function onChange(e) {\n                    instance.toggleAllPageRowsSelected(e.target.checked);\n                },\n                style: {\n                    cursor: \"pointer\"\n                },\n                checked: instance.isAllPageRowsSelected,\n                title: \"Toggle All Current Page Rows Selected\",\n                indeterminate: Boolean(!instance.isAllPageRowsSelected && instance.page.some(function(_ref4) {\n                    var id = _ref4.id;\n                    return instance.state.selectedRowIds[id];\n                }))\n            }\n        ];\n    }; // eslint-disable-next-line max-params\n    function reducer$8(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                selectedRowIds: {}\n            }, state);\n        }\n        if (action.type === actions.resetSelectedRows) {\n            return _extends({}, state, {\n                selectedRowIds: instance.initialState.selectedRowIds || {}\n            });\n        }\n        if (action.type === actions.toggleAllRowsSelected) {\n            var setSelected = action.value;\n            var isAllRowsSelected = instance.isAllRowsSelected, rowsById = instance.rowsById, _instance$nonGroupedR = instance.nonGroupedRowsById, nonGroupedRowsById = _instance$nonGroupedR === void 0 ? rowsById : _instance$nonGroupedR;\n            var selectAll = typeof setSelected !== \"undefined\" ? setSelected : !isAllRowsSelected; // Only remove/add the rows that are visible on the screen\n            //  Leave all the other rows that are selected alone.\n            var selectedRowIds = Object.assign({}, state.selectedRowIds);\n            if (selectAll) {\n                Object.keys(nonGroupedRowsById).forEach(function(rowId) {\n                    selectedRowIds[rowId] = true;\n                });\n            } else {\n                Object.keys(nonGroupedRowsById).forEach(function(rowId) {\n                    delete selectedRowIds[rowId];\n                });\n            }\n            return _extends({}, state, {\n                selectedRowIds: selectedRowIds\n            });\n        }\n        if (action.type === actions.toggleRowSelected) {\n            var id = action.id, _setSelected = action.value;\n            var _rowsById = instance.rowsById, _instance$selectSubRo = instance.selectSubRows, selectSubRows = _instance$selectSubRo === void 0 ? true : _instance$selectSubRo, getSubRows = instance.getSubRows;\n            var isSelected = state.selectedRowIds[id];\n            var shouldExist = typeof _setSelected !== \"undefined\" ? _setSelected : !isSelected;\n            if (isSelected === shouldExist) {\n                return state;\n            }\n            var newSelectedRowIds = _extends({}, state.selectedRowIds);\n            var handleRowById = function handleRowById(id) {\n                var row = _rowsById[id];\n                if (row) {\n                    if (!row.isGrouped) {\n                        if (shouldExist) {\n                            newSelectedRowIds[id] = true;\n                        } else {\n                            delete newSelectedRowIds[id];\n                        }\n                    }\n                    if (selectSubRows && getSubRows(row)) {\n                        return getSubRows(row).forEach(function(row) {\n                            return handleRowById(row.id);\n                        });\n                    }\n                }\n            };\n            handleRowById(id);\n            return _extends({}, state, {\n                selectedRowIds: newSelectedRowIds\n            });\n        }\n        if (action.type === actions.toggleAllPageRowsSelected) {\n            var _setSelected2 = action.value;\n            var page = instance.page, _rowsById2 = instance.rowsById, _instance$selectSubRo2 = instance.selectSubRows, _selectSubRows = _instance$selectSubRo2 === void 0 ? true : _instance$selectSubRo2, isAllPageRowsSelected = instance.isAllPageRowsSelected, _getSubRows = instance.getSubRows;\n            var _selectAll = typeof _setSelected2 !== \"undefined\" ? _setSelected2 : !isAllPageRowsSelected;\n            var _newSelectedRowIds = _extends({}, state.selectedRowIds);\n            var _handleRowById = function _handleRowById(id) {\n                var row = _rowsById2[id];\n                if (!row.isGrouped) {\n                    if (_selectAll) {\n                        _newSelectedRowIds[id] = true;\n                    } else {\n                        delete _newSelectedRowIds[id];\n                    }\n                }\n                if (_selectSubRows && _getSubRows(row)) {\n                    return _getSubRows(row).forEach(function(row) {\n                        return _handleRowById(row.id);\n                    });\n                }\n            };\n            page.forEach(function(row) {\n                return _handleRowById(row.id);\n            });\n            return _extends({}, state, {\n                selectedRowIds: _newSelectedRowIds\n            });\n        }\n        return state;\n    }\n    function useInstance$8(instance) {\n        var data = instance.data, rows = instance.rows, getHooks = instance.getHooks, plugins = instance.plugins, rowsById = instance.rowsById, _instance$nonGroupedR2 = instance.nonGroupedRowsById, nonGroupedRowsById = _instance$nonGroupedR2 === void 0 ? rowsById : _instance$nonGroupedR2, _instance$autoResetSe = instance.autoResetSelectedRows, autoResetSelectedRows = _instance$autoResetSe === void 0 ? true : _instance$autoResetSe, selectedRowIds = instance.state.selectedRowIds, _instance$selectSubRo3 = instance.selectSubRows, selectSubRows = _instance$selectSubRo3 === void 0 ? true : _instance$selectSubRo3, dispatch = instance.dispatch, page = instance.page, getSubRows = instance.getSubRows;\n        ensurePluginOrder(plugins, [\n            \"useFilters\",\n            \"useGroupBy\",\n            \"useSortBy\",\n            \"useExpanded\",\n            \"usePagination\"\n        ], \"useRowSelect\");\n        var selectedFlatRows = React.useMemo(function() {\n            var selectedFlatRows = [];\n            rows.forEach(function(row) {\n                var isSelected = selectSubRows ? getRowIsSelected(row, selectedRowIds, getSubRows) : !!selectedRowIds[row.id];\n                row.isSelected = !!isSelected;\n                row.isSomeSelected = isSelected === null;\n                if (isSelected) {\n                    selectedFlatRows.push(row);\n                }\n            });\n            return selectedFlatRows;\n        }, [\n            rows,\n            selectSubRows,\n            selectedRowIds,\n            getSubRows\n        ]);\n        var isAllRowsSelected = Boolean(Object.keys(nonGroupedRowsById).length && Object.keys(selectedRowIds).length);\n        var isAllPageRowsSelected = isAllRowsSelected;\n        if (isAllRowsSelected) {\n            if (Object.keys(nonGroupedRowsById).some(function(id) {\n                return !selectedRowIds[id];\n            })) {\n                isAllRowsSelected = false;\n            }\n        }\n        if (!isAllRowsSelected) {\n            if (page && page.length && page.some(function(_ref5) {\n                var id = _ref5.id;\n                return !selectedRowIds[id];\n            })) {\n                isAllPageRowsSelected = false;\n            }\n        }\n        var getAutoResetSelectedRows = useGetLatest(autoResetSelectedRows);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetSelectedRows()) {\n                dispatch({\n                    type: actions.resetSelectedRows\n                });\n            }\n        }, [\n            dispatch,\n            data\n        ]);\n        var toggleAllRowsSelected = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.toggleAllRowsSelected,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var toggleAllPageRowsSelected = React.useCallback(function(value) {\n            return dispatch({\n                type: actions.toggleAllPageRowsSelected,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var toggleRowSelected = React.useCallback(function(id, value) {\n            return dispatch({\n                type: actions.toggleRowSelected,\n                id: id,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var getInstance = useGetLatest(instance);\n        var getToggleAllRowsSelectedProps = makePropGetter(getHooks().getToggleAllRowsSelectedProps, {\n            instance: getInstance()\n        });\n        var getToggleAllPageRowsSelectedProps = makePropGetter(getHooks().getToggleAllPageRowsSelectedProps, {\n            instance: getInstance()\n        });\n        Object.assign(instance, {\n            selectedFlatRows: selectedFlatRows,\n            isAllRowsSelected: isAllRowsSelected,\n            isAllPageRowsSelected: isAllPageRowsSelected,\n            toggleRowSelected: toggleRowSelected,\n            toggleAllRowsSelected: toggleAllRowsSelected,\n            getToggleAllRowsSelectedProps: getToggleAllRowsSelectedProps,\n            getToggleAllPageRowsSelectedProps: getToggleAllPageRowsSelectedProps,\n            toggleAllPageRowsSelected: toggleAllPageRowsSelected\n        });\n    }\n    function prepareRow$3(row, _ref6) {\n        var instance = _ref6.instance;\n        row.toggleRowSelected = function(set) {\n            return instance.toggleRowSelected(row.id, set);\n        };\n        row.getToggleRowSelectedProps = makePropGetter(instance.getHooks().getToggleRowSelectedProps, {\n            instance: instance,\n            row: row\n        });\n    }\n    function getRowIsSelected(row, selectedRowIds, getSubRows) {\n        if (selectedRowIds[row.id]) {\n            return true;\n        }\n        var subRows = getSubRows(row);\n        if (subRows && subRows.length) {\n            var allChildrenSelected = true;\n            var someSelected = false;\n            subRows.forEach(function(subRow) {\n                // Bail out early if we know both of these\n                if (someSelected && !allChildrenSelected) {\n                    return;\n                }\n                if (getRowIsSelected(subRow, selectedRowIds, getSubRows)) {\n                    someSelected = true;\n                } else {\n                    allChildrenSelected = false;\n                }\n            });\n            return allChildrenSelected ? true : someSelected ? null : false;\n        }\n        return false;\n    }\n    var defaultInitialRowStateAccessor = function defaultInitialRowStateAccessor(row) {\n        return {};\n    };\n    var defaultInitialCellStateAccessor = function defaultInitialCellStateAccessor(cell) {\n        return {};\n    }; // Actions\n    actions.setRowState = \"setRowState\";\n    actions.setCellState = \"setCellState\";\n    actions.resetRowState = \"resetRowState\";\n    var useRowState = function useRowState(hooks) {\n        hooks.stateReducers.push(reducer$9);\n        hooks.useInstance.push(useInstance$9);\n        hooks.prepareRow.push(prepareRow$4);\n    };\n    useRowState.pluginName = \"useRowState\";\n    function reducer$9(state, action, previousState, instance) {\n        var _instance$initialRowS = instance.initialRowStateAccessor, initialRowStateAccessor = _instance$initialRowS === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS, _instance$initialCell = instance.initialCellStateAccessor, initialCellStateAccessor = _instance$initialCell === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell, rowsById = instance.rowsById;\n        if (action.type === actions.init) {\n            return _extends({\n                rowState: {}\n            }, state);\n        }\n        if (action.type === actions.resetRowState) {\n            return _extends({}, state, {\n                rowState: instance.initialState.rowState || {}\n            });\n        }\n        if (action.type === actions.setRowState) {\n            var _extends2;\n            var rowId = action.rowId, value = action.value;\n            var oldRowState = typeof state.rowState[rowId] !== \"undefined\" ? state.rowState[rowId] : initialRowStateAccessor(rowsById[rowId]);\n            return _extends({}, state, {\n                rowState: _extends({}, state.rowState, (_extends2 = {}, _extends2[rowId] = functionalUpdate(value, oldRowState), _extends2))\n            });\n        }\n        if (action.type === actions.setCellState) {\n            var _oldRowState$cellStat, _rowsById$_rowId, _rowsById$_rowId$cell, _extends3, _extends4;\n            var _rowId = action.rowId, columnId = action.columnId, _value = action.value;\n            var _oldRowState = typeof state.rowState[_rowId] !== \"undefined\" ? state.rowState[_rowId] : initialRowStateAccessor(rowsById[_rowId]);\n            var oldCellState = typeof (_oldRowState == null ? void 0 : (_oldRowState$cellStat = _oldRowState.cellState) == null ? void 0 : _oldRowState$cellStat[columnId]) !== \"undefined\" ? _oldRowState.cellState[columnId] : initialCellStateAccessor((_rowsById$_rowId = rowsById[_rowId]) == null ? void 0 : (_rowsById$_rowId$cell = _rowsById$_rowId.cells) == null ? void 0 : _rowsById$_rowId$cell.find(function(cell) {\n                return cell.column.id === columnId;\n            }));\n            return _extends({}, state, {\n                rowState: _extends({}, state.rowState, (_extends4 = {}, _extends4[_rowId] = _extends({}, _oldRowState, {\n                    cellState: _extends({}, _oldRowState.cellState || {}, (_extends3 = {}, _extends3[columnId] = functionalUpdate(_value, oldCellState), _extends3))\n                }), _extends4))\n            });\n        }\n    }\n    function useInstance$9(instance) {\n        var _instance$autoResetRo = instance.autoResetRowState, autoResetRowState = _instance$autoResetRo === void 0 ? true : _instance$autoResetRo, data = instance.data, dispatch = instance.dispatch;\n        var setRowState = React.useCallback(function(rowId, value) {\n            return dispatch({\n                type: actions.setRowState,\n                rowId: rowId,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var setCellState = React.useCallback(function(rowId, columnId, value) {\n            return dispatch({\n                type: actions.setCellState,\n                rowId: rowId,\n                columnId: columnId,\n                value: value\n            });\n        }, [\n            dispatch\n        ]);\n        var getAutoResetRowState = useGetLatest(autoResetRowState);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetRowState()) {\n                dispatch({\n                    type: actions.resetRowState\n                });\n            }\n        }, [\n            data\n        ]);\n        Object.assign(instance, {\n            setRowState: setRowState,\n            setCellState: setCellState\n        });\n    }\n    function prepareRow$4(row, _ref) {\n        var instance = _ref.instance;\n        var _instance$initialRowS2 = instance.initialRowStateAccessor, initialRowStateAccessor = _instance$initialRowS2 === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS2, _instance$initialCell2 = instance.initialCellStateAccessor, initialCellStateAccessor = _instance$initialCell2 === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell2, rowState = instance.state.rowState;\n        if (row) {\n            row.state = typeof rowState[row.id] !== \"undefined\" ? rowState[row.id] : initialRowStateAccessor(row);\n            row.setState = function(updater) {\n                return instance.setRowState(row.id, updater);\n            };\n            row.cells.forEach(function(cell) {\n                if (!row.state.cellState) {\n                    row.state.cellState = {};\n                }\n                cell.state = typeof row.state.cellState[cell.column.id] !== \"undefined\" ? row.state.cellState[cell.column.id] : initialCellStateAccessor(cell);\n                cell.setState = function(updater) {\n                    return instance.setCellState(row.id, cell.column.id, updater);\n                };\n            });\n        }\n    }\n    actions.resetColumnOrder = \"resetColumnOrder\";\n    actions.setColumnOrder = \"setColumnOrder\";\n    var useColumnOrder = function useColumnOrder(hooks) {\n        hooks.stateReducers.push(reducer$a);\n        hooks.visibleColumnsDeps.push(function(deps, _ref) {\n            var instance = _ref.instance;\n            return [].concat(deps, [\n                instance.state.columnOrder\n            ]);\n        });\n        hooks.visibleColumns.push(visibleColumns$2);\n        hooks.useInstance.push(useInstance$a);\n    };\n    useColumnOrder.pluginName = \"useColumnOrder\";\n    function reducer$a(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                columnOrder: []\n            }, state);\n        }\n        if (action.type === actions.resetColumnOrder) {\n            return _extends({}, state, {\n                columnOrder: instance.initialState.columnOrder || []\n            });\n        }\n        if (action.type === actions.setColumnOrder) {\n            return _extends({}, state, {\n                columnOrder: functionalUpdate(action.columnOrder, state.columnOrder)\n            });\n        }\n    }\n    function visibleColumns$2(columns, _ref2) {\n        var columnOrder = _ref2.instance.state.columnOrder;\n        // If there is no order, return the normal columns\n        if (!columnOrder || !columnOrder.length) {\n            return columns;\n        }\n        var columnOrderCopy = [].concat(columnOrder); // If there is an order, make a copy of the columns\n        var columnsCopy = [].concat(columns); // And make a new ordered array of the columns\n        var columnsInOrder = []; // Loop over the columns and place them in order into the new array\n        var _loop = function _loop() {\n            var targetColumnId = columnOrderCopy.shift();\n            var foundIndex = columnsCopy.findIndex(function(d) {\n                return d.id === targetColumnId;\n            });\n            if (foundIndex > -1) {\n                columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0]);\n            }\n        };\n        while(columnsCopy.length && columnOrderCopy.length){\n            _loop();\n        } // If there are any columns left, add them to the end\n        return [].concat(columnsInOrder, columnsCopy);\n    }\n    function useInstance$a(instance) {\n        var dispatch = instance.dispatch;\n        instance.setColumnOrder = React.useCallback(function(columnOrder) {\n            return dispatch({\n                type: actions.setColumnOrder,\n                columnOrder: columnOrder\n            });\n        }, [\n            dispatch\n        ]);\n    }\n    defaultColumn.canResize = true; // Actions\n    actions.columnStartResizing = \"columnStartResizing\";\n    actions.columnResizing = \"columnResizing\";\n    actions.columnDoneResizing = \"columnDoneResizing\";\n    actions.resetResize = \"resetResize\";\n    var useResizeColumns = function useResizeColumns(hooks) {\n        hooks.getResizerProps = [\n            defaultGetResizerProps\n        ];\n        hooks.getHeaderProps.push({\n            style: {\n                position: \"relative\"\n            }\n        });\n        hooks.stateReducers.push(reducer$b);\n        hooks.useInstance.push(useInstance$b);\n        hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions$1);\n    };\n    var defaultGetResizerProps = function defaultGetResizerProps(props, _ref) {\n        var instance = _ref.instance, header = _ref.header;\n        var dispatch = instance.dispatch;\n        var onResizeStart = function onResizeStart(e, header) {\n            var isTouchEvent = false;\n            if (e.type === \"touchstart\") {\n                // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                if (e.touches && e.touches.length > 1) {\n                    return;\n                }\n                isTouchEvent = true;\n            }\n            var headersToResize = getLeafHeaders(header);\n            var headerIdWidths = headersToResize.map(function(d) {\n                return [\n                    d.id,\n                    d.totalWidth\n                ];\n            });\n            var clientX = isTouchEvent ? Math.round(e.touches[0].clientX) : e.clientX;\n            var raf;\n            var mostRecentClientX;\n            var dispatchEnd = function dispatchEnd() {\n                window.cancelAnimationFrame(raf);\n                raf = null;\n                dispatch({\n                    type: actions.columnDoneResizing\n                });\n            };\n            var dispatchMove = function dispatchMove() {\n                window.cancelAnimationFrame(raf);\n                raf = null;\n                dispatch({\n                    type: actions.columnResizing,\n                    clientX: mostRecentClientX\n                });\n            };\n            var scheduleDispatchMoveOnNextAnimationFrame = function scheduleDispatchMoveOnNextAnimationFrame(clientXPos) {\n                mostRecentClientX = clientXPos;\n                if (!raf) {\n                    raf = window.requestAnimationFrame(dispatchMove);\n                }\n            };\n            var handlersAndEvents = {\n                mouse: {\n                    moveEvent: \"mousemove\",\n                    moveHandler: function moveHandler(e) {\n                        return scheduleDispatchMoveOnNextAnimationFrame(e.clientX);\n                    },\n                    upEvent: \"mouseup\",\n                    upHandler: function upHandler(e) {\n                        document.removeEventListener(\"mousemove\", handlersAndEvents.mouse.moveHandler);\n                        document.removeEventListener(\"mouseup\", handlersAndEvents.mouse.upHandler);\n                        dispatchEnd();\n                    }\n                },\n                touch: {\n                    moveEvent: \"touchmove\",\n                    moveHandler: function moveHandler(e) {\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        scheduleDispatchMoveOnNextAnimationFrame(e.touches[0].clientX);\n                        return false;\n                    },\n                    upEvent: \"touchend\",\n                    upHandler: function upHandler(e) {\n                        document.removeEventListener(handlersAndEvents.touch.moveEvent, handlersAndEvents.touch.moveHandler);\n                        document.removeEventListener(handlersAndEvents.touch.upEvent, handlersAndEvents.touch.moveHandler);\n                        dispatchEnd();\n                    }\n                }\n            };\n            var events = isTouchEvent ? handlersAndEvents.touch : handlersAndEvents.mouse;\n            var passiveIfSupported = passiveEventSupported() ? {\n                passive: false\n            } : false;\n            document.addEventListener(events.moveEvent, events.moveHandler, passiveIfSupported);\n            document.addEventListener(events.upEvent, events.upHandler, passiveIfSupported);\n            dispatch({\n                type: actions.columnStartResizing,\n                columnId: header.id,\n                columnWidth: header.totalWidth,\n                headerIdWidths: headerIdWidths,\n                clientX: clientX\n            });\n        };\n        return [\n            props,\n            {\n                onMouseDown: function onMouseDown(e) {\n                    return e.persist() || onResizeStart(e, header);\n                },\n                onTouchStart: function onTouchStart(e) {\n                    return e.persist() || onResizeStart(e, header);\n                },\n                style: {\n                    cursor: \"col-resize\"\n                },\n                draggable: false,\n                role: \"separator\"\n            }\n        ];\n    };\n    useResizeColumns.pluginName = \"useResizeColumns\";\n    function reducer$b(state, action) {\n        if (action.type === actions.init) {\n            return _extends({\n                columnResizing: {\n                    columnWidths: {}\n                }\n            }, state);\n        }\n        if (action.type === actions.resetResize) {\n            return _extends({}, state, {\n                columnResizing: {\n                    columnWidths: {}\n                }\n            });\n        }\n        if (action.type === actions.columnStartResizing) {\n            var clientX = action.clientX, columnId = action.columnId, columnWidth = action.columnWidth, headerIdWidths = action.headerIdWidths;\n            return _extends({}, state, {\n                columnResizing: _extends({}, state.columnResizing, {\n                    startX: clientX,\n                    headerIdWidths: headerIdWidths,\n                    columnWidth: columnWidth,\n                    isResizingColumn: columnId\n                })\n            });\n        }\n        if (action.type === actions.columnResizing) {\n            var _clientX = action.clientX;\n            var _state$columnResizing = state.columnResizing, startX = _state$columnResizing.startX, _columnWidth = _state$columnResizing.columnWidth, _state$columnResizing2 = _state$columnResizing.headerIdWidths, _headerIdWidths = _state$columnResizing2 === void 0 ? [] : _state$columnResizing2;\n            var deltaX = _clientX - startX;\n            var percentageDeltaX = deltaX / _columnWidth;\n            var newColumnWidths = {};\n            _headerIdWidths.forEach(function(_ref2) {\n                var headerId = _ref2[0], headerWidth = _ref2[1];\n                newColumnWidths[headerId] = Math.max(headerWidth + headerWidth * percentageDeltaX, 0);\n            });\n            return _extends({}, state, {\n                columnResizing: _extends({}, state.columnResizing, {\n                    columnWidths: _extends({}, state.columnResizing.columnWidths, {}, newColumnWidths)\n                })\n            });\n        }\n        if (action.type === actions.columnDoneResizing) {\n            return _extends({}, state, {\n                columnResizing: _extends({}, state.columnResizing, {\n                    startX: null,\n                    isResizingColumn: null\n                })\n            });\n        }\n    }\n    var useInstanceBeforeDimensions$1 = function useInstanceBeforeDimensions(instance) {\n        var flatHeaders = instance.flatHeaders, disableResizing = instance.disableResizing, getHooks = instance.getHooks, columnResizing = instance.state.columnResizing;\n        var getInstance = useGetLatest(instance);\n        flatHeaders.forEach(function(header) {\n            var canResize = getFirstDefined(header.disableResizing === true ? false : undefined, disableResizing === true ? false : undefined, true);\n            header.canResize = canResize;\n            header.width = columnResizing.columnWidths[header.id] || header.originalWidth || header.width;\n            header.isResizing = columnResizing.isResizingColumn === header.id;\n            if (canResize) {\n                header.getResizerProps = makePropGetter(getHooks().getResizerProps, {\n                    instance: getInstance(),\n                    header: header\n                });\n            }\n        });\n    };\n    function useInstance$b(instance) {\n        var plugins = instance.plugins, dispatch = instance.dispatch, _instance$autoResetRe = instance.autoResetResize, autoResetResize = _instance$autoResetRe === void 0 ? true : _instance$autoResetRe, columns = instance.columns;\n        ensurePluginOrder(plugins, [\n            \"useAbsoluteLayout\"\n        ], \"useResizeColumns\");\n        var getAutoResetResize = useGetLatest(autoResetResize);\n        useMountedLayoutEffect(function() {\n            if (getAutoResetResize()) {\n                dispatch({\n                    type: actions.resetResize\n                });\n            }\n        }, [\n            columns\n        ]);\n        var resetResizing = React.useCallback(function() {\n            return dispatch({\n                type: actions.resetResize\n            });\n        }, [\n            dispatch\n        ]);\n        Object.assign(instance, {\n            resetResizing: resetResizing\n        });\n    }\n    function getLeafHeaders(header) {\n        var leafHeaders = [];\n        var recurseHeader = function recurseHeader(header) {\n            if (header.columns && header.columns.length) {\n                header.columns.map(recurseHeader);\n            }\n            leafHeaders.push(header);\n        };\n        recurseHeader(header);\n        return leafHeaders;\n    }\n    var cellStyles = {\n        position: \"absolute\",\n        top: 0\n    };\n    var useAbsoluteLayout = function useAbsoluteLayout(hooks) {\n        hooks.getTableBodyProps.push(getRowStyles);\n        hooks.getRowProps.push(getRowStyles);\n        hooks.getHeaderGroupProps.push(getRowStyles);\n        hooks.getFooterGroupProps.push(getRowStyles);\n        hooks.getHeaderProps.push(function(props, _ref) {\n            var column = _ref.column;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles, {\n                        left: column.totalLeft + \"px\",\n                        width: column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n        hooks.getCellProps.push(function(props, _ref2) {\n            var cell = _ref2.cell;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles, {\n                        left: cell.column.totalLeft + \"px\",\n                        width: cell.column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n        hooks.getFooterProps.push(function(props, _ref3) {\n            var column = _ref3.column;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles, {\n                        left: column.totalLeft + \"px\",\n                        width: column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n    };\n    useAbsoluteLayout.pluginName = \"useAbsoluteLayout\";\n    var getRowStyles = function getRowStyles(props, _ref4) {\n        var instance = _ref4.instance;\n        return [\n            props,\n            {\n                style: {\n                    position: \"relative\",\n                    width: instance.totalColumnsWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var cellStyles$1 = {\n        display: \"inline-block\",\n        boxSizing: \"border-box\"\n    };\n    var getRowStyles$1 = function getRowStyles(props, _ref) {\n        var instance = _ref.instance;\n        return [\n            props,\n            {\n                style: {\n                    display: \"flex\",\n                    width: instance.totalColumnsWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var useBlockLayout = function useBlockLayout(hooks) {\n        hooks.getRowProps.push(getRowStyles$1);\n        hooks.getHeaderGroupProps.push(getRowStyles$1);\n        hooks.getFooterGroupProps.push(getRowStyles$1);\n        hooks.getHeaderProps.push(function(props, _ref2) {\n            var column = _ref2.column;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles$1, {\n                        width: column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n        hooks.getCellProps.push(function(props, _ref3) {\n            var cell = _ref3.cell;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles$1, {\n                        width: cell.column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n        hooks.getFooterProps.push(function(props, _ref4) {\n            var column = _ref4.column;\n            return [\n                props,\n                {\n                    style: _extends({}, cellStyles$1, {\n                        width: column.totalWidth + \"px\"\n                    })\n                }\n            ];\n        });\n    };\n    useBlockLayout.pluginName = \"useBlockLayout\";\n    function useFlexLayout(hooks) {\n        hooks.getTableProps.push(getTableProps);\n        hooks.getRowProps.push(getRowStyles$2);\n        hooks.getHeaderGroupProps.push(getRowStyles$2);\n        hooks.getFooterGroupProps.push(getRowStyles$2);\n        hooks.getHeaderProps.push(getHeaderProps);\n        hooks.getCellProps.push(getCellProps);\n        hooks.getFooterProps.push(getFooterProps);\n    }\n    useFlexLayout.pluginName = \"useFlexLayout\";\n    var getTableProps = function getTableProps(props, _ref) {\n        var instance = _ref.instance;\n        return [\n            props,\n            {\n                style: {\n                    minWidth: instance.totalColumnsMinWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var getRowStyles$2 = function getRowStyles(props, _ref2) {\n        var instance = _ref2.instance;\n        return [\n            props,\n            {\n                style: {\n                    display: \"flex\",\n                    flex: \"1 0 auto\",\n                    minWidth: instance.totalColumnsMinWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var getHeaderProps = function getHeaderProps(props, _ref3) {\n        var column = _ref3.column;\n        return [\n            props,\n            {\n                style: {\n                    boxSizing: \"border-box\",\n                    flex: column.totalFlexWidth ? column.totalFlexWidth + \" 0 auto\" : undefined,\n                    minWidth: column.totalMinWidth + \"px\",\n                    width: column.totalWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var getCellProps = function getCellProps(props, _ref4) {\n        var cell = _ref4.cell;\n        return [\n            props,\n            {\n                style: {\n                    boxSizing: \"border-box\",\n                    flex: cell.column.totalFlexWidth + \" 0 auto\",\n                    minWidth: cell.column.totalMinWidth + \"px\",\n                    width: cell.column.totalWidth + \"px\"\n                }\n            }\n        ];\n    };\n    var getFooterProps = function getFooterProps(props, _ref5) {\n        var column = _ref5.column;\n        return [\n            props,\n            {\n                style: {\n                    boxSizing: \"border-box\",\n                    flex: column.totalFlexWidth ? column.totalFlexWidth + \" 0 auto\" : undefined,\n                    minWidth: column.totalMinWidth + \"px\",\n                    width: column.totalWidth + \"px\"\n                }\n            }\n        ];\n    };\n    actions.columnStartResizing = \"columnStartResizing\";\n    actions.columnResizing = \"columnResizing\";\n    actions.columnDoneResizing = \"columnDoneResizing\";\n    actions.resetResize = \"resetResize\";\n    function useGridLayout(hooks) {\n        hooks.stateReducers.push(reducer$c);\n        hooks.getTableProps.push(getTableProps$1);\n        hooks.getHeaderProps.push(getHeaderProps$1);\n        hooks.getRowProps.push(getRowProps);\n    }\n    useGridLayout.pluginName = \"useGridLayout\";\n    var getTableProps$1 = function getTableProps(props, _ref) {\n        var instance = _ref.instance;\n        var gridTemplateColumns = instance.visibleColumns.map(function(column) {\n            var _instance$state$colum;\n            if (instance.state.gridLayout.columnWidths[column.id]) return instance.state.gridLayout.columnWidths[column.id] + \"px\"; // When resizing, lock the width of all unset columns\n            // instead of using user-provided width or defaultColumn width,\n            // which could potentially be 'auto' or 'fr' units that don't scale linearly\n            if ((_instance$state$colum = instance.state.columnResizing) == null ? void 0 : _instance$state$colum.isResizingColumn) return instance.state.gridLayout.startWidths[column.id] + \"px\";\n            if (typeof column.width === \"number\") return column.width + \"px\";\n            return column.width;\n        });\n        return [\n            props,\n            {\n                style: {\n                    display: \"grid\",\n                    gridTemplateColumns: gridTemplateColumns.join(\" \")\n                }\n            }\n        ];\n    };\n    var getHeaderProps$1 = function getHeaderProps(props, _ref2) {\n        var column = _ref2.column;\n        return [\n            props,\n            {\n                id: \"header-cell-\" + column.id,\n                style: {\n                    position: \"sticky\",\n                    //enables a scroll wrapper to be placed around the table and have sticky headers\n                    gridColumn: \"span \" + column.totalVisibleHeaderCount\n                }\n            }\n        ];\n    };\n    var getRowProps = function getRowProps(props, _ref3) {\n        var row = _ref3.row;\n        if (row.isExpanded) {\n            return [\n                props,\n                {\n                    style: {\n                        gridColumn: \"1 / \" + (row.cells.length + 1)\n                    }\n                }\n            ];\n        }\n        return [\n            props,\n            {}\n        ];\n    };\n    function reducer$c(state, action, previousState, instance) {\n        if (action.type === actions.init) {\n            return _extends({\n                gridLayout: {\n                    columnWidths: {}\n                }\n            }, state);\n        }\n        if (action.type === actions.resetResize) {\n            return _extends({}, state, {\n                gridLayout: {\n                    columnWidths: {}\n                }\n            });\n        }\n        if (action.type === actions.columnStartResizing) {\n            var columnId = action.columnId, headerIdWidths = action.headerIdWidths;\n            var columnWidth = getElementWidth(columnId);\n            if (columnWidth !== undefined) {\n                var startWidths = instance.visibleColumns.reduce(function(acc, column) {\n                    var _extends2;\n                    return _extends({}, acc, (_extends2 = {}, _extends2[column.id] = getElementWidth(column.id), _extends2));\n                }, {});\n                var minWidths = instance.visibleColumns.reduce(function(acc, column) {\n                    var _extends3;\n                    return _extends({}, acc, (_extends3 = {}, _extends3[column.id] = column.minWidth, _extends3));\n                }, {});\n                var maxWidths = instance.visibleColumns.reduce(function(acc, column) {\n                    var _extends4;\n                    return _extends({}, acc, (_extends4 = {}, _extends4[column.id] = column.maxWidth, _extends4));\n                }, {});\n                var headerIdGridWidths = headerIdWidths.map(function(_ref4) {\n                    var headerId = _ref4[0];\n                    return [\n                        headerId,\n                        getElementWidth(headerId)\n                    ];\n                });\n                return _extends({}, state, {\n                    gridLayout: _extends({}, state.gridLayout, {\n                        startWidths: startWidths,\n                        minWidths: minWidths,\n                        maxWidths: maxWidths,\n                        headerIdGridWidths: headerIdGridWidths,\n                        columnWidth: columnWidth\n                    })\n                });\n            } else {\n                return state;\n            }\n        }\n        if (action.type === actions.columnResizing) {\n            var clientX = action.clientX;\n            var startX = state.columnResizing.startX;\n            var _state$gridLayout = state.gridLayout, _columnWidth = _state$gridLayout.columnWidth, _minWidths = _state$gridLayout.minWidths, _maxWidths = _state$gridLayout.maxWidths, _state$gridLayout$hea = _state$gridLayout.headerIdGridWidths, _headerIdGridWidths = _state$gridLayout$hea === void 0 ? [] : _state$gridLayout$hea;\n            var deltaX = clientX - startX;\n            var percentageDeltaX = deltaX / _columnWidth;\n            var newColumnWidths = {};\n            _headerIdGridWidths.forEach(function(_ref5) {\n                var headerId = _ref5[0], headerWidth = _ref5[1];\n                newColumnWidths[headerId] = Math.min(Math.max(_minWidths[headerId], headerWidth + headerWidth * percentageDeltaX), _maxWidths[headerId]);\n            });\n            return _extends({}, state, {\n                gridLayout: _extends({}, state.gridLayout, {\n                    columnWidths: _extends({}, state.gridLayout.columnWidths, {}, newColumnWidths)\n                })\n            });\n        }\n        if (action.type === actions.columnDoneResizing) {\n            return _extends({}, state, {\n                gridLayout: _extends({}, state.gridLayout, {\n                    startWidths: {},\n                    minWidths: {},\n                    maxWidths: {}\n                })\n            });\n        }\n    }\n    function getElementWidth(columnId) {\n        var _document$getElementB;\n        var width = (_document$getElementB = document.getElementById(\"header-cell-\" + columnId)) == null ? void 0 : _document$getElementB.offsetWidth;\n        if (width !== undefined) {\n            return width;\n        }\n    }\n    exports1._UNSTABLE_usePivotColumns = _UNSTABLE_usePivotColumns;\n    exports1.actions = actions;\n    exports1.defaultColumn = defaultColumn;\n    exports1.defaultGroupByFn = defaultGroupByFn;\n    exports1.defaultOrderByFn = defaultOrderByFn;\n    exports1.defaultRenderer = defaultRenderer;\n    exports1.emptyRenderer = emptyRenderer;\n    exports1.ensurePluginOrder = ensurePluginOrder;\n    exports1.flexRender = flexRender;\n    exports1.functionalUpdate = functionalUpdate;\n    exports1.loopHooks = loopHooks;\n    exports1.makePropGetter = makePropGetter;\n    exports1.makeRenderer = makeRenderer;\n    exports1.reduceHooks = reduceHooks;\n    exports1.safeUseLayoutEffect = safeUseLayoutEffect;\n    exports1.useAbsoluteLayout = useAbsoluteLayout;\n    exports1.useAsyncDebounce = useAsyncDebounce;\n    exports1.useBlockLayout = useBlockLayout;\n    exports1.useColumnOrder = useColumnOrder;\n    exports1.useExpanded = useExpanded;\n    exports1.useFilters = useFilters;\n    exports1.useFlexLayout = useFlexLayout;\n    exports1.useGetLatest = useGetLatest;\n    exports1.useGlobalFilter = useGlobalFilter;\n    exports1.useGridLayout = useGridLayout;\n    exports1.useGroupBy = useGroupBy;\n    exports1.useMountedLayoutEffect = useMountedLayoutEffect;\n    exports1.usePagination = usePagination;\n    exports1.useResizeColumns = useResizeColumns;\n    exports1.useRowSelect = useRowSelect;\n    exports1.useRowState = useRowState;\n    exports1.useSortBy = useSortBy;\n    exports1.useTable = useTable;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n}); //# sourceMappingURL=react-table.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFibGUvZGlzdC9yZWFjdC10YWJsZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFVQSxNQUFNLEVBQUVDLE9BQU87SUFDeEIsS0FBaUQsR0FBY0EsUUFBUUMsU0FBU0UsbUJBQU9BLENBQUMsNkdBQ3hGLENBQ3VFO0FBQ3pFLEdBQUUsSUFBSSxFQUFHLFNBQVVGLFFBQU8sRUFBRU8sS0FBSztJQUFJO0lBRW5DQSxRQUFRQSxTQUFTQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixPQUFPLGFBQWFBLEtBQUssQ0FBQyxVQUFVLEdBQUdBO0lBRTdGLFNBQVNLLG1CQUFtQkMsR0FBRyxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUN2RSxJQUFJO1lBQ0YsSUFBSUMsT0FBT1AsR0FBRyxDQUFDSyxJQUFJLENBQUNDO1lBQ3BCLElBQUlFLFFBQVFELEtBQUtDLEtBQUs7UUFDeEIsRUFBRSxPQUFPQyxPQUFPO1lBQ2RQLE9BQU9PO1lBQ1A7UUFDRjtRQUVBLElBQUlGLEtBQUtHLElBQUksRUFBRTtZQUNiVCxRQUFRTztRQUNWLE9BQU87WUFDTEcsUUFBUVYsT0FBTyxDQUFDTyxPQUFPSSxJQUFJLENBQUNULE9BQU9DO1FBQ3JDO0lBQ0Y7SUFFQSxTQUFTUyxrQkFBa0JDLEVBQUU7UUFDM0IsT0FBTztZQUNMLElBQUl0QixRQUFPLElBQUksRUFDWHVCLE9BQU9DO1lBQ1gsT0FBTyxJQUFJTCxRQUFRLFNBQVVWLE9BQU8sRUFBRUMsTUFBTTtnQkFDMUMsSUFBSUYsTUFBTWMsR0FBR0csS0FBSyxDQUFDekIsT0FBTXVCO2dCQUV6QixTQUFTWixNQUFNSyxLQUFLO29CQUNsQlQsbUJBQW1CQyxLQUFLQyxTQUFTQyxRQUFRQyxPQUFPQyxRQUFRLFFBQVFJO2dCQUNsRTtnQkFFQSxTQUFTSixPQUFPYyxHQUFH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QUFRdWEsV0FBVyxHQUFHQTtJQUN0QnZhLFNBQVF3ZCxVQUFVLEdBQUdBO0lBQ3JCeGQsU0FBUXM2QixhQUFhLEdBQUdBO0lBQ3hCdDZCLFNBQVFpSCxZQUFZLEdBQUdBO0lBQ3ZCakgsU0FBUXdmLGVBQWUsR0FBR0E7SUFDMUJ4ZixTQUFReTZCLGFBQWEsR0FBR0E7SUFDeEJ6NkIsU0FBUWlpQixVQUFVLEdBQUdBO0lBQ3JCamlCLFNBQVEySCxzQkFBc0IsR0FBR0E7SUFDakMzSCxTQUFRK3JCLGFBQWEsR0FBR0E7SUFDeEIvckIsU0FBUWkyQixnQkFBZ0IsR0FBR0E7SUFDM0JqMkIsU0FBUXV3QixZQUFZLEdBQUdBO0lBQ3ZCdndCLFNBQVF1ekIsV0FBVyxHQUFHQTtJQUN0QnZ6QixTQUFRcW9CLFNBQVMsR0FBR0E7SUFDcEJyb0IsU0FBUTBXLFFBQVEsR0FBR0E7SUFFbkJsVyxPQUFPdTdCLGNBQWMsQ0FBQy83QixVQUFTLGNBQWM7UUFBRXFCLE9BQU87SUFBSztBQUU3RCxJQUNBLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LXRhYmxlLWRlbW8vLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFibGUvZGlzdC9yZWFjdC10YWJsZS5kZXZlbG9wbWVudC5qcz9lMjlkIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgncmVhY3QnKSkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3JlYWN0J10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdFRhYmxlID0ge30sIGdsb2JhbC5SZWFjdCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuICBSZWFjdCA9IFJlYWN0ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChSZWFjdCwgJ2RlZmF1bHQnKSA/IFJlYWN0WydkZWZhdWx0J10gOiBSZWFjdDtcblxuICBmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gICAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXG4gICAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICAgIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcblxuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG4gIH1cblxuICB2YXIgcmVuZGVyRXJyID0gJ1JlbmRlcmVyIEVycm9yIOKYne+4jyc7XG4gIHZhciBhY3Rpb25zID0ge1xuICAgIGluaXQ6ICdpbml0J1xuICB9O1xuICB2YXIgZGVmYXVsdFJlbmRlcmVyID0gZnVuY3Rpb24gZGVmYXVsdFJlbmRlcmVyKF9yZWYpIHtcbiAgICB2YXIgX3JlZiR2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICAgIHZhbHVlID0gX3JlZiR2YWx1ZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgdmFyIGVtcHR5UmVuZGVyZXIgPSBmdW5jdGlvbiBlbXB0eVJlbmRlcmVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBcIlxceEEwXCIpO1xuICB9O1xuICB2YXIgZGVmYXVsdENvbHVtbiA9IHtcbiAgICBDZWxsOiBkZWZhdWx0UmVuZGVyZXIsXG4gICAgd2lkdGg6IDE1MCxcbiAgICBtaW5XaWR0aDogMCxcbiAgICBtYXhXaWR0aDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgfTtcblxuICBmdW5jdGlvbiBtZXJnZVByb3BzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wTGlzdCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHByb3BMaXN0W19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHByb3BzLCBuZXh0KSB7XG4gICAgICB2YXIgc3R5bGUgPSBuZXh0LnN0eWxlLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IG5leHQuY2xhc3NOYW1lLFxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShuZXh0LCBbXCJzdHlsZVwiLCBcImNsYXNzTmFtZVwiXSk7XG5cbiAgICAgIHByb3BzID0gX2V4dGVuZHMoe30sIHByb3BzLCB7fSwgcmVzdCk7XG5cbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICBwcm9wcy5zdHlsZSA9IHByb3BzLnN0eWxlID8gX2V4dGVuZHMoe30sIHByb3BzLnN0eWxlIHx8IHt9LCB7fSwgc3R5bGUgfHwge30pIDogc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lID8gcHJvcHMuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lIDogY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMuY2xhc3NOYW1lID09PSAnJykge1xuICAgICAgICBkZWxldGUgcHJvcHMuY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfSwge30pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUHJvcEdldHRlcihwcmV2UHJvcHMsIHVzZXJQcm9wcywgbWV0YSkge1xuICAgIC8vIEhhbmRsZSBhIGxhbWJkYSwgcGFzcyBpdCB0aGUgcHJldmlvdXMgcHJvcHNcbiAgICBpZiAodHlwZW9mIHVzZXJQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGhhbmRsZVByb3BHZXR0ZXIoe30sIHVzZXJQcm9wcyhwcmV2UHJvcHMsIG1ldGEpKTtcbiAgICB9IC8vIEhhbmRsZSBhbiBhcnJheSwgbWVyZ2UgZWFjaCBpdGVtIGFzIHNlcGFyYXRlIHByb3BzXG5cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHVzZXJQcm9wcykpIHtcbiAgICAgIHJldHVybiBtZXJnZVByb3BzLmFwcGx5KHZvaWQgMCwgW3ByZXZQcm9wc10uY29uY2F0KHVzZXJQcm9wcykpO1xuICAgIH0gLy8gSGFuZGxlIGFuIG9iamVjdCBieSBkZWZhdWx0LCBtZXJnZSB0aGUgdHdvIG9iamVjdHNcblxuXG4gICAgcmV0dXJuIG1lcmdlUHJvcHMocHJldlByb3BzLCB1c2VyUHJvcHMpO1xuICB9XG5cbiAgdmFyIG1ha2VQcm9wR2V0dGVyID0gZnVuY3Rpb24gbWFrZVByb3BHZXR0ZXIoaG9va3MsIG1ldGEpIHtcbiAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXRhID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh1c2VyUHJvcHMpIHtcbiAgICAgIGlmICh1c2VyUHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgICB1c2VyUHJvcHMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdLmNvbmNhdChob29rcywgW3VzZXJQcm9wc10pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlUHJvcEdldHRlcihwcmV2LCBuZXh0LCBfZXh0ZW5kcyh7fSwgbWV0YSwge1xuICAgICAgICAgIHVzZXJQcm9wczogdXNlclByb3BzXG4gICAgICAgIH0pKTtcbiAgICAgIH0sIHt9KTtcbiAgICB9O1xuICB9O1xuICB2YXIgcmVkdWNlSG9va3MgPSBmdW5jdGlvbiByZWR1Y2VIb29rcyhob29rcywgaW5pdGlhbCwgbWV0YSwgYWxsb3dVbmRlZmluZWQpIHtcbiAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXRhID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvb2tzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbmV4dCkge1xuICAgICAgdmFyIG5leHRWYWx1ZSA9IG5leHQocHJldiwgbWV0YSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCFhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2YgbmV4dFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhuZXh0KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IFRhYmxlOiBBIHJlZHVjZXIgaG9vayDimJ3vuI8ganVzdCByZXR1cm5lZCB1bmRlZmluZWQhIFRoaXMgaXMgbm90IGFsbG93ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICB9LCBpbml0aWFsKTtcbiAgfTtcbiAgdmFyIGxvb3BIb29rcyA9IGZ1bmN0aW9uIGxvb3BIb29rcyhob29rcywgY29udGV4dCwgbWV0YSkge1xuICAgIGlmIChtZXRhID09PSB2b2lkIDApIHtcbiAgICAgIG1ldGEgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgdmFyIG5leHRWYWx1ZSA9IGhvb2soY29udGV4dCwgbWV0YSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0VmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc29sZS5pbmZvKGhvb2ssIG5leHRWYWx1ZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBUYWJsZTogQSBsb29wLXR5cGUgaG9vayDimJ3vuI8ganVzdCByZXR1cm5lZCBhIHZhbHVlISBUaGlzIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIGJlZm9yZXMsIHBsdWdpbk5hbWUsIGFmdGVycykge1xuICAgIGlmICggYWZ0ZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZpbmluZyBwbHVnaW5zIGluIHRoZSBcXFwiYWZ0ZXJcXFwiIHNlY3Rpb24gb2YgZW5zdXJlUGx1Z2luT3JkZXIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCAoc2VlIHBsdWdpbiBcIiArIHBsdWdpbk5hbWUgKyBcIilcIik7XG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbkluZGV4ID0gcGx1Z2lucy5maW5kSW5kZXgoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgcmV0dXJuIHBsdWdpbi5wbHVnaW5OYW1lID09PSBwbHVnaW5OYW1lO1xuICAgIH0pO1xuXG4gICAgaWYgKHBsdWdpbkluZGV4ID09PSAtMSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGx1Z2luIFxcXCJcIiArIHBsdWdpbk5hbWUgKyBcIlxcXCIgd2FzIG5vdCBmb3VuZCBpbiB0aGUgcGx1Z2luIGxpc3QhXFxuVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBuZWVkIHRvIG5lZWQgdG8gbmFtZSB5b3VyIHBsdWdpbiBob29rIGJ5IHNldHRpbmcgdGhlICdwbHVnaW5OYW1lJyBwcm9wZXJ0eSBvZiB0aGUgaG9vayBmdW5jdGlvbiwgZWc6XFxuXFxuICBcIiArIHBsdWdpbk5hbWUgKyBcIi5wbHVnaW5OYW1lID0gJ1wiICsgcGx1Z2luTmFtZSArIFwiJ1xcblwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiZWZvcmVzLmZvckVhY2goZnVuY3Rpb24gKGJlZm9yZSkge1xuICAgICAgdmFyIGJlZm9yZUluZGV4ID0gcGx1Z2lucy5maW5kSW5kZXgoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLnBsdWdpbk5hbWUgPT09IGJlZm9yZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYmVmb3JlSW5kZXggPiAtMSAmJiBiZWZvcmVJbmRleCA+IHBsdWdpbkluZGV4KSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBUYWJsZTogVGhlIFwiICsgcGx1Z2luTmFtZSArIFwiIHBsdWdpbiBob29rIG11c3QgYmUgcGxhY2VkIGFmdGVyIHRoZSBcIiArIGJlZm9yZSArIFwiIHBsdWdpbiBob29rIVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1cGRhdGVyID09PSAnZnVuY3Rpb24nID8gdXBkYXRlcihvbGQpIDogdXBkYXRlcjtcbiAgfVxuICBmdW5jdGlvbiB1c2VHZXRMYXRlc3Qob2JqKSB7XG4gICAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIHJlZi5jdXJyZW50ID0gb2JqO1xuICAgIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pO1xuICB9IC8vIFNTUiBoYXMgaXNzdWVzIHdpdGggdXNlTGF5b3V0RWZmZWN0IHN0aWxsLCBzbyB1c2UgdXNlRWZmZWN0IGR1cmluZyBTU1JcblxuICB2YXIgc2FmZVVzZUxheW91dEVmZmVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG4gIGZ1bmN0aW9uIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZm4sIGRlcHMpIHtcbiAgICB2YXIgbW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgc2FmZVVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9XG5cbiAgICAgIG1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIH0sIGRlcHMpO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUFzeW5jRGVib3VuY2UoZGVmYXVsdEZuLCBkZWZhdWx0V2FpdCkge1xuICAgIGlmIChkZWZhdWx0V2FpdCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0V2FpdCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRlYm91bmNlUmVmID0gUmVhY3QudXNlUmVmKHt9KTtcbiAgICB2YXIgZ2V0RGVmYXVsdEZuID0gdXNlR2V0TGF0ZXN0KGRlZmF1bHRGbik7XG4gICAgdmFyIGdldERlZmF1bHRXYWl0ID0gdXNlR2V0TGF0ZXN0KGRlZmF1bHRXYWl0KTtcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKFxuICAgICAgLyojX19QVVJFX18qL1xuICAgICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBfbGVuMixcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBfa2V5MixcbiAgICAgICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50cztcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGZvciAoX2xlbjIgPSBfYXJnczIubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IF9hcmdzMltfa2V5Ml07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFkZWJvdW5jZVJlZi5jdXJyZW50LnByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgIGRlYm91bmNlUmVmLmN1cnJlbnQucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2VSZWYuY3VycmVudC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2VSZWYuY3VycmVudC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVib3VuY2VSZWYuY3VycmVudC50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VSZWYuY3VycmVudC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkZWJvdW5jZVJlZi5jdXJyZW50LnRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAgICAgICBfYXN5bmNUb0dlbmVyYXRvcihcbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlYm91bmNlUmVmLmN1cnJlbnQudGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gZGVib3VuY2VSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXREZWZhdWx0Rm4oKS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MC5yZXNvbHZlLmNhbGwoX2NvbnRleHQudDAsIF9jb250ZXh0LnQxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MiA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYm91bmNlUmVmLmN1cnJlbnQucmVqZWN0KF9jb250ZXh0LnQyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGVib3VuY2VSZWYuY3VycmVudC5wcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDEyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgOSwgMTIsIDE1XV0pO1xuICAgICAgICAgICAgICAgIH0pKSwgZ2V0RGVmYXVsdFdhaXQoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZGVib3VuY2VSZWYuY3VycmVudC5wcm9taXNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0oKSwgW2dldERlZmF1bHRGbiwgZ2V0RGVmYXVsdFdhaXRdKTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlUmVuZGVyZXIoaW5zdGFuY2UsIGNvbHVtbiwgbWV0YSkge1xuICAgIGlmIChtZXRhID09PSB2b2lkIDApIHtcbiAgICAgIG1ldGEgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHR5cGUsIHVzZXJQcm9wcykge1xuICAgICAgaWYgKHVzZXJQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHVzZXJQcm9wcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgQ29tcCA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IGNvbHVtblt0eXBlXSA6IHR5cGU7XG5cbiAgICAgIGlmICh0eXBlb2YgQ29tcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKGNvbHVtbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZW5kZXJFcnIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmxleFJlbmRlcihDb21wLCBfZXh0ZW5kcyh7fSwgaW5zdGFuY2UsIHtcbiAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgIH0sIG1ldGEsIHt9LCB1c2VyUHJvcHMpKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZsZXhSZW5kZXIoQ29tcCwgcHJvcHMpIHtcbiAgICByZXR1cm4gaXNSZWFjdENvbXBvbmVudChDb21wKSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcCwgcHJvcHMpIDogQ29tcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVhY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB8fCB0eXBlb2YgY29tcG9uZW50ID09PSAnZnVuY3Rpb24nIHx8IGlzRXhvdGljQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiB0eXBlb2YgY29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21wb25lbnQpO1xuICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZSAmJiBwcm90by5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbiAgICB9KCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbXBvbmVudC4kJHR5cGVvZiA9PT0gJ3N5bWJvbCcgJiYgWydyZWFjdC5tZW1vJywgJ3JlYWN0LmZvcndhcmRfcmVmJ10uaW5jbHVkZXMoY29tcG9uZW50LiQkdHlwZW9mLmRlc2NyaXB0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmtDb2x1bW5TdHJ1Y3R1cmUoY29sdW1ucywgcGFyZW50LCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIGNvbHVtbiA9IF9leHRlbmRzKHt9LCBjb2x1bW4sIHtcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGRlcHRoOiBkZXB0aFxuICAgICAgfSk7XG4gICAgICBhc3NpZ25Db2x1bW5BY2Nlc3Nvcihjb2x1bW4pO1xuXG4gICAgICBpZiAoY29sdW1uLmNvbHVtbnMpIHtcbiAgICAgICAgY29sdW1uLmNvbHVtbnMgPSBsaW5rQ29sdW1uU3RydWN0dXJlKGNvbHVtbi5jb2x1bW5zLCBjb2x1bW4sIGRlcHRoICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZmxhdHRlbkNvbHVtbnMoY29sdW1ucykge1xuICAgIHJldHVybiBmbGF0dGVuQnkoY29sdW1ucywgJ2NvbHVtbnMnKTtcbiAgfVxuICBmdW5jdGlvbiBhc3NpZ25Db2x1bW5BY2Nlc3Nvcihjb2x1bW4pIHtcbiAgICAvLyBGaXJzdCBjaGVjayBmb3Igc3RyaW5nIGFjY2Vzc29yXG4gICAgdmFyIGlkID0gY29sdW1uLmlkLFxuICAgICAgICBhY2Nlc3NvciA9IGNvbHVtbi5hY2Nlc3NvcixcbiAgICAgICAgSGVhZGVyID0gY29sdW1uLkhlYWRlcjtcblxuICAgIGlmICh0eXBlb2YgYWNjZXNzb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZCA9IGlkIHx8IGFjY2Vzc29yO1xuICAgICAgdmFyIGFjY2Vzc29yUGF0aCA9IGFjY2Vzc29yLnNwbGl0KCcuJyk7XG5cbiAgICAgIGFjY2Vzc29yID0gZnVuY3Rpb24gYWNjZXNzb3Iocm93KSB7XG4gICAgICAgIHJldHVybiBnZXRCeShyb3csIGFjY2Vzc29yUGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghaWQgJiYgdHlwZW9mIEhlYWRlciA9PT0gJ3N0cmluZycgJiYgSGVhZGVyKSB7XG4gICAgICBpZCA9IEhlYWRlcjtcbiAgICB9XG5cbiAgICBpZiAoIWlkICYmIGNvbHVtbi5jb2x1bW5zKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGNvbHVtbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY29sdW1uIElEIChvciB1bmlxdWUgXCJIZWFkZXJcIiB2YWx1ZSkgaXMgcmVxdWlyZWQhJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpZCkge1xuICAgICAgY29uc29sZS5lcnJvcihjb2x1bW4pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGNvbHVtbiBJRCAob3Igc3RyaW5nIGFjY2Vzc29yKSBpcyByZXF1aXJlZCEnKTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKGNvbHVtbiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgYWNjZXNzb3I6IGFjY2Vzc29yXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbHVtbjtcbiAgfVxuICBmdW5jdGlvbiBkZWNvcmF0ZUNvbHVtbihjb2x1bW4sIHVzZXJEZWZhdWx0Q29sdW1uKSB7XG4gICAgaWYgKCF1c2VyRGVmYXVsdENvbHVtbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihjb2x1bW4sIF9leHRlbmRzKHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBhIGZhbGxiYWNrIGhlYWRlciwganVzdCBpbiBjYXNlXG4gICAgICBIZWFkZXI6IGVtcHR5UmVuZGVyZXIsXG4gICAgICBGb290ZXI6IGVtcHR5UmVuZGVyZXJcbiAgICB9LCBkZWZhdWx0Q29sdW1uLCB7fSwgdXNlckRlZmF1bHRDb2x1bW4sIHt9LCBjb2x1bW4pKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbHVtbiwge1xuICAgICAgb3JpZ2luYWxXaWR0aDogY29sdW1uLndpZHRoXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbHVtbjtcbiAgfSAvLyBCdWlsZCB0aGUgaGVhZGVyIGdyb3VwcyBmcm9tIHRoZSBib3R0b20gdXBcblxuICBmdW5jdGlvbiBtYWtlSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGRlZmF1bHRDb2x1bW4sIGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzKSB7XG4gICAgaWYgKGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzID09PSB2b2lkIDApIHtcbiAgICAgIGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gYWRkaXRpb25hbEhlYWRlclByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlckdyb3VwcyA9IFtdO1xuICAgIHZhciBzY2FuQ29sdW1ucyA9IGFsbENvbHVtbnM7XG4gICAgdmFyIHVpZCA9IDA7XG5cbiAgICB2YXIgZ2V0VUlEID0gZnVuY3Rpb24gZ2V0VUlEKCkge1xuICAgICAgcmV0dXJuIHVpZCsrO1xuICAgIH07XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIC8vIFRoZSBoZWFkZXIgZ3JvdXAgd2UgYXJlIGNyZWF0aW5nXG4gICAgICB2YXIgaGVhZGVyR3JvdXAgPSB7XG4gICAgICAgIGhlYWRlcnM6IFtdXG4gICAgICB9OyAvLyBUaGUgcGFyZW50IGNvbHVtbnMgd2UncmUgZ29pbmcgdG8gc2NhbiBuZXh0XG5cbiAgICAgIHZhciBwYXJlbnRDb2x1bW5zID0gW107XG4gICAgICB2YXIgaGFzUGFyZW50cyA9IHNjYW5Db2x1bW5zLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucGFyZW50O1xuICAgICAgfSk7IC8vIFNjYW4gZWFjaCBjb2x1bW4gZm9yIHBhcmVudHNcblxuICAgICAgc2NhbkNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIC8vIFdoYXQgaXMgdGhlIGxhdGVzdCAobGFzdCkgcGFyZW50IGNvbHVtbj9cbiAgICAgICAgdmFyIGxhdGVzdFBhcmVudENvbHVtbiA9IFtdLmNvbmNhdChwYXJlbnRDb2x1bW5zKS5yZXZlcnNlKClbMF07XG4gICAgICAgIHZhciBuZXdQYXJlbnQ7XG5cbiAgICAgICAgaWYgKGhhc1BhcmVudHMpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY29sdW1uIGhhcyBhIHBhcmVudCwgYWRkIGl0IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIGlmIChjb2x1bW4ucGFyZW50KSB7XG4gICAgICAgICAgICBuZXdQYXJlbnQgPSBfZXh0ZW5kcyh7fSwgY29sdW1uLnBhcmVudCwge1xuICAgICAgICAgICAgICBvcmlnaW5hbElkOiBjb2x1bW4ucGFyZW50LmlkLFxuICAgICAgICAgICAgICBpZDogY29sdW1uLnBhcmVudC5pZCArIFwiX1wiICsgZ2V0VUlEKCksXG4gICAgICAgICAgICAgIGhlYWRlcnM6IFtjb2x1bW5dXG4gICAgICAgICAgICB9LCBhZGRpdGlvbmFsSGVhZGVyUHJvcGVydGllcyhjb2x1bW4pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgb3RoZXIgY29sdW1ucyBoYXZlIHBhcmVudHMsIHdlJ2xsIG5lZWQgdG8gYWRkIGEgcGxhY2UgaG9sZGVyIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsSWQgPSBjb2x1bW4uaWQgKyBcIl9wbGFjZWhvbGRlclwiO1xuICAgICAgICAgICAgbmV3UGFyZW50ID0gZGVjb3JhdGVDb2x1bW4oX2V4dGVuZHMoe1xuICAgICAgICAgICAgICBvcmlnaW5hbElkOiBvcmlnaW5hbElkLFxuICAgICAgICAgICAgICBpZDogY29sdW1uLmlkICsgXCJfcGxhY2Vob2xkZXJfXCIgKyBnZXRVSUQoKSxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXJPZjogY29sdW1uLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBbY29sdW1uXVxuICAgICAgICAgICAgfSwgYWRkaXRpb25hbEhlYWRlclByb3BlcnRpZXMoY29sdW1uKSksIGRlZmF1bHRDb2x1bW4pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIHJlc3VsdGluZyBwYXJlbnQgY29sdW1ucyBhcmUgdGhlIHNhbWUsIGp1c3QgYWRkXG4gICAgICAgICAgLy8gdGhlIGNvbHVtbiBhbmQgaW5jcmVtZW50IHRoZSBoZWFkZXIgc3BhblxuXG5cbiAgICAgICAgICBpZiAobGF0ZXN0UGFyZW50Q29sdW1uICYmIGxhdGVzdFBhcmVudENvbHVtbi5vcmlnaW5hbElkID09PSBuZXdQYXJlbnQub3JpZ2luYWxJZCkge1xuICAgICAgICAgICAgbGF0ZXN0UGFyZW50Q29sdW1uLmhlYWRlcnMucHVzaChjb2x1bW4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRDb2x1bW5zLnB1c2gobmV3UGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkZXJHcm91cC5oZWFkZXJzLnB1c2goY29sdW1uKTtcbiAgICAgIH0pO1xuICAgICAgaGVhZGVyR3JvdXBzLnB1c2goaGVhZGVyR3JvdXApOyAvLyBTdGFydCBzY2FubmluZyB0aGUgcGFyZW50IGNvbHVtbnNcblxuICAgICAgc2NhbkNvbHVtbnMgPSBwYXJlbnRDb2x1bW5zO1xuICAgIH07XG5cbiAgICB3aGlsZSAoc2NhbkNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJHcm91cHMucmV2ZXJzZSgpO1xuICB9XG4gIHZhciBwYXRoT2JqQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGdldEJ5KG9iaiwgcGF0aCwgZGVmKSB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHZhciBjYWNoZUtleSA9IHR5cGVvZiBwYXRoID09PSAnZnVuY3Rpb24nID8gcGF0aCA6IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuXG4gICAgdmFyIHBhdGhPYmogPSBwYXRoT2JqQ2FjaGUuZ2V0KGNhY2hlS2V5KSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aE9iaiA9IG1ha2VQYXRoQXJyYXkocGF0aCk7XG4gICAgICBwYXRoT2JqQ2FjaGUuc2V0KGNhY2hlS2V5LCBwYXRoT2JqKTtcbiAgICAgIHJldHVybiBwYXRoT2JqO1xuICAgIH0oKTtcblxuICAgIHZhciB2YWw7XG5cbiAgICB0cnkge1xuICAgICAgdmFsID0gcGF0aE9iai5yZWR1Y2UoZnVuY3Rpb24gKGN1cnNvciwgcGF0aFBhcnQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvcltwYXRoUGFydF07XG4gICAgICB9LCBvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHsvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnID8gdmFsIDogZGVmO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZpcnN0RGVmaW5lZCgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmbGF0dGVuQnkoYXJyLCBrZXkpIHtcbiAgICB2YXIgZmxhdCA9IFtdO1xuXG4gICAgdmFyIHJlY3Vyc2UgPSBmdW5jdGlvbiByZWN1cnNlKGFycikge1xuICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgaWYgKCFkW2tleV0pIHtcbiAgICAgICAgICBmbGF0LnB1c2goZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzZShkW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmVjdXJzZShhcnIpO1xuICAgIHJldHVybiBmbGF0O1xuICB9XG4gIGZ1bmN0aW9uIGV4cGFuZFJvd3Mocm93cywgX3JlZikge1xuICAgIHZhciBtYW51YWxFeHBhbmRlZEtleSA9IF9yZWYubWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgIGV4cGFuZGVkID0gX3JlZi5leHBhbmRlZCxcbiAgICAgICAgX3JlZiRleHBhbmRTdWJSb3dzID0gX3JlZi5leHBhbmRTdWJSb3dzLFxuICAgICAgICBleHBhbmRTdWJSb3dzID0gX3JlZiRleHBhbmRTdWJSb3dzID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRleHBhbmRTdWJSb3dzO1xuICAgIHZhciBleHBhbmRlZFJvd3MgPSBbXTtcblxuICAgIHZhciBoYW5kbGVSb3cgPSBmdW5jdGlvbiBoYW5kbGVSb3cocm93LCBhZGRUb0V4cGFuZGVkUm93cykge1xuICAgICAgaWYgKGFkZFRvRXhwYW5kZWRSb3dzID09PSB2b2lkIDApIHtcbiAgICAgICAgYWRkVG9FeHBhbmRlZFJvd3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByb3cuaXNFeHBhbmRlZCA9IHJvdy5vcmlnaW5hbCAmJiByb3cub3JpZ2luYWxbbWFudWFsRXhwYW5kZWRLZXldIHx8IGV4cGFuZGVkW3Jvdy5pZF07XG4gICAgICByb3cuY2FuRXhwYW5kID0gcm93LnN1YlJvd3MgJiYgISFyb3cuc3ViUm93cy5sZW5ndGg7XG5cbiAgICAgIGlmIChhZGRUb0V4cGFuZGVkUm93cykge1xuICAgICAgICBleHBhbmRlZFJvd3MucHVzaChyb3cpO1xuICAgICAgfVxuXG4gICAgICBpZiAocm93LnN1YlJvd3MgJiYgcm93LnN1YlJvd3MubGVuZ3RoICYmIHJvdy5pc0V4cGFuZGVkKSB7XG4gICAgICAgIHJvdy5zdWJSb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVSb3cocm93LCBleHBhbmRTdWJSb3dzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaGFuZGxlUm93KHJvdyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4cGFuZGVkUm93cztcbiAgfVxuICBmdW5jdGlvbiBnZXRGaWx0ZXJNZXRob2QoZmlsdGVyLCB1c2VyRmlsdGVyVHlwZXMsIGZpbHRlclR5cGVzKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oZmlsdGVyKSB8fCB1c2VyRmlsdGVyVHlwZXNbZmlsdGVyXSB8fCBmaWx0ZXJUeXBlc1tmaWx0ZXJdIHx8IGZpbHRlclR5cGVzLnRleHQ7XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihhdXRvUmVtb3ZlLCB2YWx1ZSwgY29sdW1uKSB7XG4gICAgcmV0dXJuIGF1dG9SZW1vdmUgPyBhdXRvUmVtb3ZlKHZhbHVlLCBjb2x1bW4pIDogdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbiAgfVxuICBmdW5jdGlvbiB1bnByZXBhcmVkQWNjZXNzV2FybmluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0LVRhYmxlOiBZb3UgaGF2ZSBub3QgY2FsbGVkIHByZXBhcmVSb3cocm93KSBvbmUgb3IgbW9yZSByb3dzIHlvdSBhcmUgYXR0ZW1wdGluZyB0byByZW5kZXIuJyk7XG4gIH1cbiAgdmFyIHBhc3NpdmVTdXBwb3J0ZWQgPSBudWxsO1xuICBmdW5jdGlvbiBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSB7XG4gICAgLy8gbWVtb2l6ZSBzdXBwb3J0IHRvIGF2b2lkIGFkZGluZyBtdWx0aXBsZSB0ZXN0IGV2ZW50c1xuICAgIGlmICh0eXBlb2YgcGFzc2l2ZVN1cHBvcnRlZCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbiAgICB2YXIgc3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG4gICAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG4gIH0gLy9cblxuICB2YXIgcmVPcGVuQnJhY2tldCA9IC9cXFsvZztcbiAgdmFyIHJlQ2xvc2VCcmFja2V0ID0gL1xcXS9nO1xuXG4gIGZ1bmN0aW9uIG1ha2VQYXRoQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW5EZWVwKG9iaikgLy8gcmVtb3ZlIGFsbCBwZXJpb2RzIGluIHBhcnRzXG4gICAgLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIFN0cmluZyhkKS5yZXBsYWNlKCcuJywgJ18nKTtcbiAgICB9KSAvLyBqb2luIHBhcnRzIHVzaW5nIHBlcmlvZFxuICAgIC5qb2luKCcuJykgLy8gcmVwbGFjZSBicmFja2V0cyB3aXRoIHBlcmlvZHNcbiAgICAucmVwbGFjZShyZU9wZW5CcmFja2V0LCAnLicpLnJlcGxhY2UocmVDbG9zZUJyYWNrZXQsICcnKSAvLyBzcGxpdCBpdCBiYWNrIG91dCBvbiBwZXJpb2RzXG4gICAgLnNwbGl0KCcuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnIsIG5ld0Fycikge1xuICAgIGlmIChuZXdBcnIgPT09IHZvaWQgMCkge1xuICAgICAgbmV3QXJyID0gW107XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIG5ld0Fyci5wdXNoKGFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGZsYXR0ZW5EZWVwKGFycltpXSwgbmV3QXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3QXJyO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRHZXRUYWJsZVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRhYmxlUHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgcm9sZTogJ3RhYmxlJ1xuICAgIH0sIHByb3BzKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRhYmxlQm9keVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRhYmxlQm9keVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIHJvbGU6ICdyb3dncm91cCdcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRIZWFkZXJQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRIZWFkZXJQcm9wcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmLmNvbHVtbjtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImhlYWRlcl9cIiArIGNvbHVtbi5pZCxcbiAgICAgIGNvbFNwYW46IGNvbHVtbi50b3RhbFZpc2libGVIZWFkZXJDb3VudCxcbiAgICAgIHJvbGU6ICdjb2x1bW5oZWFkZXInXG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0Rm9vdGVyUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0Rm9vdGVyUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGNvbHVtbiA9IF9yZWYyLmNvbHVtbjtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImZvb3Rlcl9cIiArIGNvbHVtbi5pZCxcbiAgICAgIGNvbFNwYW46IGNvbHVtbi50b3RhbFZpc2libGVIZWFkZXJDb3VudFxuICAgIH0sIHByb3BzKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldEhlYWRlckdyb3VwUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0SGVhZGVyR3JvdXBQcm9wcyhwcm9wcywgX3JlZjMpIHtcbiAgICB2YXIgaW5kZXggPSBfcmVmMy5pbmRleDtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImhlYWRlckdyb3VwX1wiICsgaW5kZXgsXG4gICAgICByb2xlOiAncm93J1xuICAgIH0sIHByb3BzKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldEZvb3Rlckdyb3VwUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0Rm9vdGVyR3JvdXBQcm9wcyhwcm9wcywgX3JlZjQpIHtcbiAgICB2YXIgaW5kZXggPSBfcmVmNC5pbmRleDtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImZvb3Rlckdyb3VwX1wiICsgaW5kZXhcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRSb3dQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRSb3dQcm9wcyhwcm9wcywgX3JlZjUpIHtcbiAgICB2YXIgcm93ID0gX3JlZjUucm93O1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IFwicm93X1wiICsgcm93LmlkLFxuICAgICAgcm9sZTogJ3JvdydcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRDZWxsUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0Q2VsbFByb3BzKHByb3BzLCBfcmVmNikge1xuICAgIHZhciBjZWxsID0gX3JlZjYuY2VsbDtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcImNlbGxfXCIgKyBjZWxsLnJvdy5pZCArIFwiX1wiICsgY2VsbC5jb2x1bW4uaWQsXG4gICAgICByb2xlOiAnY2VsbCdcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZURlZmF1bHRQbHVnaW5Ib29rcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlT3B0aW9uczogW10sXG4gICAgICBzdGF0ZVJlZHVjZXJzOiBbXSxcbiAgICAgIHVzZUNvbnRyb2xsZWRTdGF0ZTogW10sXG4gICAgICBjb2x1bW5zOiBbXSxcbiAgICAgIGNvbHVtbnNEZXBzOiBbXSxcbiAgICAgIGFsbENvbHVtbnM6IFtdLFxuICAgICAgYWxsQ29sdW1uc0RlcHM6IFtdLFxuICAgICAgYWNjZXNzVmFsdWU6IFtdLFxuICAgICAgbWF0ZXJpYWxpemVkQ29sdW1uczogW10sXG4gICAgICBtYXRlcmlhbGl6ZWRDb2x1bW5zRGVwczogW10sXG4gICAgICB1c2VJbnN0YW5jZUFmdGVyRGF0YTogW10sXG4gICAgICB2aXNpYmxlQ29sdW1uczogW10sXG4gICAgICB2aXNpYmxlQ29sdW1uc0RlcHM6IFtdLFxuICAgICAgaGVhZGVyR3JvdXBzOiBbXSxcbiAgICAgIGhlYWRlckdyb3Vwc0RlcHM6IFtdLFxuICAgICAgdXNlSW5zdGFuY2VCZWZvcmVEaW1lbnNpb25zOiBbXSxcbiAgICAgIHVzZUluc3RhbmNlOiBbXSxcbiAgICAgIHByZXBhcmVSb3c6IFtdLFxuICAgICAgZ2V0VGFibGVQcm9wczogW2RlZmF1bHRHZXRUYWJsZVByb3BzXSxcbiAgICAgIGdldFRhYmxlQm9keVByb3BzOiBbZGVmYXVsdEdldFRhYmxlQm9keVByb3BzXSxcbiAgICAgIGdldEhlYWRlckdyb3VwUHJvcHM6IFtkZWZhdWx0R2V0SGVhZGVyR3JvdXBQcm9wc10sXG4gICAgICBnZXRGb290ZXJHcm91cFByb3BzOiBbZGVmYXVsdEdldEZvb3Rlckdyb3VwUHJvcHNdLFxuICAgICAgZ2V0SGVhZGVyUHJvcHM6IFtkZWZhdWx0R2V0SGVhZGVyUHJvcHNdLFxuICAgICAgZ2V0Rm9vdGVyUHJvcHM6IFtkZWZhdWx0R2V0Rm9vdGVyUHJvcHNdLFxuICAgICAgZ2V0Um93UHJvcHM6IFtkZWZhdWx0R2V0Um93UHJvcHNdLFxuICAgICAgZ2V0Q2VsbFByb3BzOiBbZGVmYXVsdEdldENlbGxQcm9wc10sXG4gICAgICB1c2VGaW5hbEluc3RhbmNlOiBbXVxuICAgIH07XG4gIH1cblxuICBhY3Rpb25zLnJlc2V0SGlkZGVuQ29sdW1ucyA9ICdyZXNldEhpZGRlbkNvbHVtbnMnO1xuICBhY3Rpb25zLnRvZ2dsZUhpZGVDb2x1bW4gPSAndG9nZ2xlSGlkZUNvbHVtbic7XG4gIGFjdGlvbnMuc2V0SGlkZGVuQ29sdW1ucyA9ICdzZXRIaWRkZW5Db2x1bW5zJztcbiAgYWN0aW9ucy50b2dnbGVIaWRlQWxsQ29sdW1ucyA9ICd0b2dnbGVIaWRlQWxsQ29sdW1ucyc7XG4gIHZhciB1c2VDb2x1bW5WaXNpYmlsaXR5ID0gZnVuY3Rpb24gdXNlQ29sdW1uVmlzaWJpbGl0eShob29rcykge1xuICAgIGhvb2tzLmdldFRvZ2dsZUhpZGRlblByb3BzID0gW2RlZmF1bHRHZXRUb2dnbGVIaWRkZW5Qcm9wc107XG4gICAgaG9va3MuZ2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcyA9IFtkZWZhdWx0R2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wc107XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucy5wdXNoKHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyk7XG4gICAgaG9va3MuaGVhZGVyR3JvdXBzRGVwcy5wdXNoKGZ1bmN0aW9uIChkZXBzLCBfcmVmKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1uc10pO1xuICAgIH0pO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UpO1xuICB9O1xuICB1c2VDb2x1bW5WaXNpYmlsaXR5LnBsdWdpbk5hbWUgPSAndXNlQ29sdW1uVmlzaWJpbGl0eSc7XG5cbiAgdmFyIGRlZmF1bHRHZXRUb2dnbGVIaWRkZW5Qcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVIaWRkZW5Qcm9wcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZjIuY29sdW1uO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGNvbHVtbi50b2dnbGVIaWRkZW4oIWUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgY2hlY2tlZDogY29sdW1uLmlzVmlzaWJsZSxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIENvbHVtbiBWaXNpYmxlJ1xuICAgIH1dO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVIaWRlQWxsQ29sdW1uc1Byb3BzKHByb3BzLCBfcmVmMykge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYzLmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGluc3RhbmNlLnRvZ2dsZUhpZGVBbGxDb2x1bW5zKCFlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6ICFpbnN0YW5jZS5hbGxDb2x1bW5zSGlkZGVuICYmICFpbnN0YW5jZS5zdGF0ZS5oaWRkZW5Db2x1bW5zLmxlbmd0aCxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIEFsbCBDb2x1bW5zIEhpZGRlbicsXG4gICAgICBpbmRldGVybWluYXRlOiAhaW5zdGFuY2UuYWxsQ29sdW1uc0hpZGRlbiAmJiBpbnN0YW5jZS5zdGF0ZS5oaWRkZW5Db2x1bW5zLmxlbmd0aFxuICAgIH1dO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgaGlkZGVuQ29sdW1uczogW11cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRIaWRkZW5Db2x1bW5zKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5oaWRkZW5Db2x1bW5zIHx8IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlSGlkZUNvbHVtbikge1xuICAgICAgdmFyIHNob3VsZCA9IHR5cGVvZiBhY3Rpb24udmFsdWUgIT09ICd1bmRlZmluZWQnID8gYWN0aW9uLnZhbHVlIDogIXN0YXRlLmhpZGRlbkNvbHVtbnMuaW5jbHVkZXMoYWN0aW9uLmNvbHVtbklkKTtcbiAgICAgIHZhciBoaWRkZW5Db2x1bW5zID0gc2hvdWxkID8gW10uY29uY2F0KHN0YXRlLmhpZGRlbkNvbHVtbnMsIFthY3Rpb24uY29sdW1uSWRdKSA6IHN0YXRlLmhpZGRlbkNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkICE9PSBhY3Rpb24uY29sdW1uSWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaGlkZGVuQ29sdW1uczogaGlkZGVuQ29sdW1uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldEhpZGRlbkNvbHVtbnMpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaGlkZGVuQ29sdW1uczogZnVuY3Rpb25hbFVwZGF0ZShhY3Rpb24udmFsdWUsIHN0YXRlLmhpZGRlbkNvbHVtbnMpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlSGlkZUFsbENvbHVtbnMpIHtcbiAgICAgIHZhciBzaG91bGRBbGwgPSB0eXBlb2YgYWN0aW9uLnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGFjdGlvbi52YWx1ZSA6ICFzdGF0ZS5oaWRkZW5Db2x1bW5zLmxlbmd0aDtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgaGlkZGVuQ29sdW1uczogc2hvdWxkQWxsID8gaW5zdGFuY2UuYWxsQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZDtcbiAgICAgICAgfSkgOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2VCZWZvcmVEaW1lbnNpb25zKGluc3RhbmNlKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBpbnN0YW5jZS5oZWFkZXJzLFxuICAgICAgICBoaWRkZW5Db2x1bW5zID0gaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1ucztcbiAgICB2YXIgaXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcblxuICAgIGlmICghaXNNb3VudGVkUmVmLmN1cnJlbnQpIDtcblxuICAgIHZhciBoYW5kbGVDb2x1bW4gPSBmdW5jdGlvbiBoYW5kbGVDb2x1bW4oY29sdW1uLCBwYXJlbnRWaXNpYmxlKSB7XG4gICAgICBjb2x1bW4uaXNWaXNpYmxlID0gcGFyZW50VmlzaWJsZSAmJiAhaGlkZGVuQ29sdW1ucy5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgICAgdmFyIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ID0gMDtcblxuICAgICAgaWYgKGNvbHVtbi5oZWFkZXJzICYmIGNvbHVtbi5oZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICBjb2x1bW4uaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJDb2x1bW4pIHtcbiAgICAgICAgICByZXR1cm4gdG90YWxWaXNpYmxlSGVhZGVyQ291bnQgKz0gaGFuZGxlQ29sdW1uKHN1YkNvbHVtbiwgY29sdW1uLmlzVmlzaWJsZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG90YWxWaXNpYmxlSGVhZGVyQ291bnQgPSBjb2x1bW4uaXNWaXNpYmxlID8gMSA6IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbHVtbi50b3RhbFZpc2libGVIZWFkZXJDb3VudCA9IHRvdGFsVmlzaWJsZUhlYWRlckNvdW50O1xuICAgICAgcmV0dXJuIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50O1xuICAgIH07XG5cbiAgICB2YXIgdG90YWxWaXNpYmxlSGVhZGVyQ291bnQgPSAwO1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViSGVhZGVyKSB7XG4gICAgICByZXR1cm4gdG90YWxWaXNpYmxlSGVhZGVyQ291bnQgKz0gaGFuZGxlQ29sdW1uKHN1YkhlYWRlciwgdHJ1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIHZhciBjb2x1bW5zID0gaW5zdGFuY2UuY29sdW1ucyxcbiAgICAgICAgZmxhdEhlYWRlcnMgPSBpbnN0YW5jZS5mbGF0SGVhZGVycyxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3MsXG4gICAgICAgIGhpZGRlbkNvbHVtbnMgPSBpbnN0YW5jZS5zdGF0ZS5oaWRkZW5Db2x1bW5zLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0SGkgPSBpbnN0YW5jZS5hdXRvUmVzZXRIaWRkZW5Db2x1bW5zLFxuICAgICAgICBhdXRvUmVzZXRIaWRkZW5Db2x1bW5zID0gX2luc3RhbmNlJGF1dG9SZXNldEhpID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldEhpO1xuICAgIHZhciBnZXRJbnN0YW5jZSA9IHVzZUdldExhdGVzdChpbnN0YW5jZSk7XG4gICAgdmFyIGFsbENvbHVtbnNIaWRkZW4gPSBhbGxDb2x1bW5zLmxlbmd0aCA9PT0gaGlkZGVuQ29sdW1ucy5sZW5ndGg7XG4gICAgdmFyIHRvZ2dsZUhpZGVDb2x1bW4gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29sdW1uSWQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUhpZGVDb2x1bW4sXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgc2V0SGlkZGVuQ29sdW1ucyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRIaWRkZW5Db2x1bW5zLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciB0b2dnbGVIaWRlQWxsQ29sdW1ucyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVIaWRlQWxsQ29sdW1ucyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgZ2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcywge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KTtcbiAgICBmbGF0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIGNvbHVtbi50b2dnbGVIaWRkZW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlSGlkZUNvbHVtbixcbiAgICAgICAgICBjb2x1bW5JZDogY29sdW1uLmlkLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbHVtbi5nZXRUb2dnbGVIaWRkZW5Qcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlSGlkZGVuUHJvcHMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgZ2V0QXV0b1Jlc2V0SGlkZGVuQ29sdW1ucyA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRIaWRkZW5Db2x1bW5zKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRIaWRkZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRIaWRkZW5Db2x1bW5zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgY29sdW1uc10pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIGFsbENvbHVtbnNIaWRkZW46IGFsbENvbHVtbnNIaWRkZW4sXG4gICAgICB0b2dnbGVIaWRlQ29sdW1uOiB0b2dnbGVIaWRlQ29sdW1uLFxuICAgICAgc2V0SGlkZGVuQ29sdW1uczogc2V0SGlkZGVuQ29sdW1ucyxcbiAgICAgIHRvZ2dsZUhpZGVBbGxDb2x1bW5zOiB0b2dnbGVIaWRlQWxsQ29sdW1ucyxcbiAgICAgIGdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHM6IGdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0SW5pdGlhbFN0YXRlID0ge307XG4gIHZhciBkZWZhdWx0Q29sdW1uSW5zdGFuY2UgPSB7fTtcblxuICB2YXIgZGVmYXVsdFJlZHVjZXIgPSBmdW5jdGlvbiBkZWZhdWx0UmVkdWNlcihzdGF0ZSwgYWN0aW9uLCBwcmV2U3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRTdWJSb3dzID0gZnVuY3Rpb24gZGVmYXVsdEdldFN1YlJvd3Mocm93LCBpbmRleCkge1xuICAgIHJldHVybiByb3cuc3ViUm93cyB8fCBbXTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFJvd0lkID0gZnVuY3Rpb24gZGVmYXVsdEdldFJvd0lkKHJvdywgaW5kZXgsIHBhcmVudCkge1xuICAgIHJldHVybiBcIlwiICsgKHBhcmVudCA/IFtwYXJlbnQuaWQsIGluZGV4XS5qb2luKCcuJykgOiBpbmRleCk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRVc2VDb250cm9sbGVkU3RhdGUgPSBmdW5jdGlvbiBkZWZhdWx0VXNlQ29udHJvbGxlZFN0YXRlKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcblxuICBmdW5jdGlvbiBhcHBseURlZmF1bHRzKHByb3BzKSB7XG4gICAgdmFyIF9wcm9wcyRpbml0aWFsU3RhdGUgPSBwcm9wcy5pbml0aWFsU3RhdGUsXG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IF9wcm9wcyRpbml0aWFsU3RhdGUgPT09IHZvaWQgMCA/IGRlZmF1bHRJbml0aWFsU3RhdGUgOiBfcHJvcHMkaW5pdGlhbFN0YXRlLFxuICAgICAgICBfcHJvcHMkZGVmYXVsdENvbHVtbiA9IHByb3BzLmRlZmF1bHRDb2x1bW4sXG4gICAgICAgIGRlZmF1bHRDb2x1bW4gPSBfcHJvcHMkZGVmYXVsdENvbHVtbiA9PT0gdm9pZCAwID8gZGVmYXVsdENvbHVtbkluc3RhbmNlIDogX3Byb3BzJGRlZmF1bHRDb2x1bW4sXG4gICAgICAgIF9wcm9wcyRnZXRTdWJSb3dzID0gcHJvcHMuZ2V0U3ViUm93cyxcbiAgICAgICAgZ2V0U3ViUm93cyA9IF9wcm9wcyRnZXRTdWJSb3dzID09PSB2b2lkIDAgPyBkZWZhdWx0R2V0U3ViUm93cyA6IF9wcm9wcyRnZXRTdWJSb3dzLFxuICAgICAgICBfcHJvcHMkZ2V0Um93SWQgPSBwcm9wcy5nZXRSb3dJZCxcbiAgICAgICAgZ2V0Um93SWQgPSBfcHJvcHMkZ2V0Um93SWQgPT09IHZvaWQgMCA/IGRlZmF1bHRHZXRSb3dJZCA6IF9wcm9wcyRnZXRSb3dJZCxcbiAgICAgICAgX3Byb3BzJHN0YXRlUmVkdWNlciA9IHByb3BzLnN0YXRlUmVkdWNlcixcbiAgICAgICAgc3RhdGVSZWR1Y2VyID0gX3Byb3BzJHN0YXRlUmVkdWNlciA9PT0gdm9pZCAwID8gZGVmYXVsdFJlZHVjZXIgOiBfcHJvcHMkc3RhdGVSZWR1Y2VyLFxuICAgICAgICBfcHJvcHMkdXNlQ29udHJvbGxlZFMgPSBwcm9wcy51c2VDb250cm9sbGVkU3RhdGUsXG4gICAgICAgIHVzZUNvbnRyb2xsZWRTdGF0ZSA9IF9wcm9wcyR1c2VDb250cm9sbGVkUyA9PT0gdm9pZCAwID8gZGVmYXVsdFVzZUNvbnRyb2xsZWRTdGF0ZSA6IF9wcm9wcyR1c2VDb250cm9sbGVkUyxcbiAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJpbml0aWFsU3RhdGVcIiwgXCJkZWZhdWx0Q29sdW1uXCIsIFwiZ2V0U3ViUm93c1wiLCBcImdldFJvd0lkXCIsIFwic3RhdGVSZWR1Y2VyXCIsIFwidXNlQ29udHJvbGxlZFN0YXRlXCJdKTtcblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgICBkZWZhdWx0Q29sdW1uOiBkZWZhdWx0Q29sdW1uLFxuICAgICAgZ2V0U3ViUm93czogZ2V0U3ViUm93cyxcbiAgICAgIGdldFJvd0lkOiBnZXRSb3dJZCxcbiAgICAgIHN0YXRlUmVkdWNlcjogc3RhdGVSZWR1Y2VyLFxuICAgICAgdXNlQ29udHJvbGxlZFN0YXRlOiB1c2VDb250cm9sbGVkU3RhdGVcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB1c2VUYWJsZSA9IGZ1bmN0aW9uIHVzZVRhYmxlKHByb3BzKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBsdWdpbnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGx1Z2luc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCBwcm9wc1xuICAgIHByb3BzID0gYXBwbHlEZWZhdWx0cyhwcm9wcyk7IC8vIEFkZCBjb3JlIHBsdWdpbnNcblxuICAgIHBsdWdpbnMgPSBbdXNlQ29sdW1uVmlzaWJpbGl0eV0uY29uY2F0KHBsdWdpbnMpOyAvLyBDcmVhdGUgdGhlIHRhYmxlIGluc3RhbmNlXG5cbiAgICB2YXIgaW5zdGFuY2VSZWYgPSBSZWFjdC51c2VSZWYoe30pOyAvLyBDcmVhdGUgYSBnZXR0ZXIgZm9yIHRoZSBpbnN0YW5jZSAoaGVscHMgYXZvaWQgYSBsb3Qgb2YgcG90ZW50aWFsIG1lbW9yeSBsZWFrcylcblxuICAgIHZhciBnZXRJbnN0YW5jZSA9IHVzZUdldExhdGVzdChpbnN0YW5jZVJlZi5jdXJyZW50KTsgLy8gQXNzaWduIHRoZSBwcm9wcywgcGx1Z2lucyBhbmQgaG9va3MgdG8gdGhlIGluc3RhbmNlXG5cbiAgICBPYmplY3QuYXNzaWduKGdldEluc3RhbmNlKCksIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcGx1Z2luczogcGx1Z2lucyxcbiAgICAgIGhvb2tzOiBtYWtlRGVmYXVsdFBsdWdpbkhvb2tzKClcbiAgICB9KSk7IC8vIEFsbG93IHBsdWdpbnMgdG8gcmVnaXN0ZXIgaG9va3MgYXMgZWFybHkgYXMgcG9zc2libGVcblxuICAgIHBsdWdpbnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgcGx1Z2luKGdldEluc3RhbmNlKCkuaG9va3MpO1xuICAgIH0pOyAvLyBDb25zdW1lIGFsbCBob29rcyBhbmQgbWFrZSBhIGdldHRlciBmb3IgdGhlbVxuXG4gICAgdmFyIGdldEhvb2tzID0gdXNlR2V0TGF0ZXN0KGdldEluc3RhbmNlKCkuaG9va3MpO1xuICAgIGdldEluc3RhbmNlKCkuZ2V0SG9va3MgPSBnZXRIb29rcztcbiAgICBkZWxldGUgZ2V0SW5zdGFuY2UoKS5ob29rczsgLy8gQWxsb3cgdXNlT3B0aW9ucyBob29rcyB0byBtb2RpZnkgdGhlIG9wdGlvbnMgY29taW5nIGludG8gdGhlIHRhYmxlXG5cbiAgICBPYmplY3QuYXNzaWduKGdldEluc3RhbmNlKCksIHJlZHVjZUhvb2tzKGdldEhvb2tzKCkudXNlT3B0aW9ucywgYXBwbHlEZWZhdWx0cyhwcm9wcykpKTtcblxuICAgIHZhciBfZ2V0SW5zdGFuY2UgPSBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBkYXRhID0gX2dldEluc3RhbmNlLmRhdGEsXG4gICAgICAgIHVzZXJDb2x1bW5zID0gX2dldEluc3RhbmNlLmNvbHVtbnMsXG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IF9nZXRJbnN0YW5jZS5pbml0aWFsU3RhdGUsXG4gICAgICAgIGRlZmF1bHRDb2x1bW4gPSBfZ2V0SW5zdGFuY2UuZGVmYXVsdENvbHVtbixcbiAgICAgICAgZ2V0U3ViUm93cyA9IF9nZXRJbnN0YW5jZS5nZXRTdWJSb3dzLFxuICAgICAgICBnZXRSb3dJZCA9IF9nZXRJbnN0YW5jZS5nZXRSb3dJZCxcbiAgICAgICAgc3RhdGVSZWR1Y2VyID0gX2dldEluc3RhbmNlLnN0YXRlUmVkdWNlcixcbiAgICAgICAgdXNlQ29udHJvbGxlZFN0YXRlID0gX2dldEluc3RhbmNlLnVzZUNvbnRyb2xsZWRTdGF0ZTsgLy8gU2V0dXAgdXNlciByZWR1Y2VyIHJlZlxuXG5cbiAgICB2YXIgZ2V0U3RhdGVSZWR1Y2VyID0gdXNlR2V0TGF0ZXN0KHN0YXRlUmVkdWNlcik7IC8vIEJ1aWxkIHRoZSByZWR1Y2VyXG5cbiAgICB2YXIgcmVkdWNlciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAvLyBEZXRlY3QgaW52YWxpZCBhY3Rpb25zXG4gICAgICBpZiAoIWFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBBY3Rpb24g8J+RhicpO1xuICAgICAgfSAvLyBSZWR1Y2UgdGhlIHN0YXRlIGZyb20gYWxsIHBsdWdpbiByZWR1Y2Vyc1xuXG5cbiAgICAgIHJldHVybiBbXS5jb25jYXQoZ2V0SG9va3MoKS5zdGF0ZVJlZHVjZXJzLCBBcnJheS5pc0FycmF5KGdldFN0YXRlUmVkdWNlcigpKSA/IGdldFN0YXRlUmVkdWNlcigpIDogW2dldFN0YXRlUmVkdWNlcigpXSkucmVkdWNlKGZ1bmN0aW9uIChzLCBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKHMsIGFjdGlvbiwgc3RhdGUsIGdldEluc3RhbmNlKCkpIHx8IHM7XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfSwgW2dldEhvb2tzLCBnZXRTdGF0ZVJlZHVjZXIsIGdldEluc3RhbmNlXSk7IC8vIFN0YXJ0IHRoZSByZWR1Y2VyXG5cbiAgICB2YXIgX1JlYWN0JHVzZVJlZHVjZXIgPSBSZWFjdC51c2VSZWR1Y2VyKHJlZHVjZXIsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlZHVjZXIoaW5pdGlhbFN0YXRlLCB7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuaW5pdFxuICAgICAgfSk7XG4gICAgfSksXG4gICAgICAgIHJlZHVjZXJTdGF0ZSA9IF9SZWFjdCR1c2VSZWR1Y2VyWzBdLFxuICAgICAgICBkaXNwYXRjaCA9IF9SZWFjdCR1c2VSZWR1Y2VyWzFdOyAvLyBBbGxvdyB0aGUgdXNlciB0byBjb250cm9sIHRoZSBmaW5hbCBzdGF0ZSB3aXRoIGhvb2tzXG5cblxuICAgIHZhciBzdGF0ZSA9IHJlZHVjZUhvb2tzKFtdLmNvbmNhdChnZXRIb29rcygpLnVzZUNvbnRyb2xsZWRTdGF0ZSwgW3VzZUNvbnRyb2xsZWRTdGF0ZV0pLCByZWR1Y2VyU3RhdGUsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihnZXRJbnN0YW5jZSgpLCB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBkaXNwYXRjaDogZGlzcGF0Y2hcbiAgICB9KTsgLy8gRGVjb3JhdGUgQWxsIHRoZSBjb2x1bW5zXG5cbiAgICB2YXIgY29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGxpbmtDb2x1bW5TdHJ1Y3R1cmUocmVkdWNlSG9va3MoZ2V0SG9va3MoKS5jb2x1bW5zLCB1c2VyQ29sdW1ucywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgICAgfSkpO1xuICAgIH0sIFtnZXRIb29rcywgZ2V0SW5zdGFuY2UsIHVzZXJDb2x1bW5zXS5jb25jYXQocmVkdWNlSG9va3MoZ2V0SG9va3MoKS5jb2x1bW5zRGVwcywgW10sIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSkpKTtcbiAgICBnZXRJbnN0YW5jZSgpLmNvbHVtbnMgPSBjb2x1bW5zOyAvLyBHZXQgdGhlIGZsYXQgbGlzdCBvZiBhbGwgY29sdW1ucyBhbmQgYWxsb3cgaG9va3MgdG8gZGVjb3JhdGVcbiAgICAvLyB0aG9zZSBjb2x1bW5zIChhbmQgdHJpZ2dlciB0aGlzIG1lbW9pemF0aW9uIHZpYSBkZXBzKVxuXG4gICAgdmFyIGFsbENvbHVtbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWR1Y2VIb29rcyhnZXRIb29rcygpLmFsbENvbHVtbnMsIGZsYXR0ZW5Db2x1bW5zKGNvbHVtbnMpLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgICB9KS5tYXAoYXNzaWduQ29sdW1uQWNjZXNzb3IpO1xuICAgIH0sIFtjb2x1bW5zLCBnZXRIb29rcywgZ2V0SW5zdGFuY2VdLmNvbmNhdChyZWR1Y2VIb29rcyhnZXRIb29rcygpLmFsbENvbHVtbnNEZXBzLCBbXSwge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KSkpO1xuICAgIGdldEluc3RhbmNlKCkuYWxsQ29sdW1ucyA9IGFsbENvbHVtbnM7IC8vIEFjY2VzcyB0aGUgcm93IG1vZGVsIHVzaW5nIGluaXRpYWwgY29sdW1uc1xuXG4gICAgdmFyIF9SZWFjdCR1c2VNZW1vID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgdmFyIGZsYXRSb3dzID0gW107XG4gICAgICB2YXIgcm93c0J5SWQgPSB7fTtcbiAgICAgIHZhciBhbGxDb2x1bW5zUXVldWUgPSBbXS5jb25jYXQoYWxsQ29sdW1ucyk7XG5cbiAgICAgIHdoaWxlIChhbGxDb2x1bW5zUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zUXVldWUuc2hpZnQoKTtcbiAgICAgICAgYWNjZXNzUm93c0ZvckNvbHVtbih7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICByb3dzOiByb3dzLFxuICAgICAgICAgIGZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgICAgICByb3dzQnlJZDogcm93c0J5SWQsXG4gICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgZ2V0Um93SWQ6IGdldFJvd0lkLFxuICAgICAgICAgIGdldFN1YlJvd3M6IGdldFN1YlJvd3MsXG4gICAgICAgICAgYWNjZXNzVmFsdWVIb29rczogZ2V0SG9va3MoKS5hY2Nlc3NWYWx1ZSxcbiAgICAgICAgICBnZXRJbnN0YW5jZTogZ2V0SW5zdGFuY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkXTtcbiAgICB9LCBbYWxsQ29sdW1ucywgZGF0YSwgZ2V0Um93SWQsIGdldFN1YlJvd3MsIGdldEhvb2tzLCBnZXRJbnN0YW5jZV0pLFxuICAgICAgICByb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIGZsYXRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMV0sXG4gICAgICAgIHJvd3NCeUlkID0gX1JlYWN0JHVzZU1lbW9bMl07XG5cbiAgICBPYmplY3QuYXNzaWduKGdldEluc3RhbmNlKCksIHtcbiAgICAgIHJvd3M6IHJvd3MsXG4gICAgICBpbml0aWFsUm93czogW10uY29uY2F0KHJvd3MpLFxuICAgICAgZmxhdFJvd3M6IGZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IHJvd3NCeUlkIC8vIG1hdGVyaWFsaXplZENvbHVtbnMsXG5cbiAgICB9KTtcbiAgICBsb29wSG9va3MoZ2V0SG9va3MoKS51c2VJbnN0YW5jZUFmdGVyRGF0YSwgZ2V0SW5zdGFuY2UoKSk7IC8vIEdldCB0aGUgZmxhdCBsaXN0IG9mIGFsbCBjb2x1bW5zIEFGVEVSIHRoZSByb3dzXG4gICAgLy8gaGF2ZSBiZWVuIGFjY2VzcywgYW5kIGFsbG93IGhvb2tzIHRvIGRlY29yYXRlXG4gICAgLy8gdGhvc2UgY29sdW1ucyAoYW5kIHRyaWdnZXIgdGhpcyBtZW1vaXphdGlvbiB2aWEgZGVwcylcblxuICAgIHZhciB2aXNpYmxlQ29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlZHVjZUhvb2tzKGdldEhvb2tzKCkudmlzaWJsZUNvbHVtbnMsIGFsbENvbHVtbnMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZGVjb3JhdGVDb2x1bW4oZCwgZGVmYXVsdENvbHVtbik7XG4gICAgICB9KTtcbiAgICB9LCBbZ2V0SG9va3MsIGFsbENvbHVtbnMsIGdldEluc3RhbmNlLCBkZWZhdWx0Q29sdW1uXS5jb25jYXQocmVkdWNlSG9va3MoZ2V0SG9va3MoKS52aXNpYmxlQ29sdW1uc0RlcHMsIFtdLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pKSk7IC8vIENvbWJpbmUgbmV3IHZpc2libGUgY29sdW1ucyB3aXRoIGFsbCBjb2x1bW5zXG5cbiAgICBhbGxDb2x1bW5zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29sdW1ucyA9IFtdLmNvbmNhdCh2aXNpYmxlQ29sdW1ucyk7XG4gICAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICBpZiAoIWNvbHVtbnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW4uaWQ7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgfSwgW2FsbENvbHVtbnMsIHZpc2libGVDb2x1bW5zXSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5hbGxDb2x1bW5zID0gYWxsQ29sdW1ucztcblxuICAgIHtcbiAgICAgIHZhciBkdXBsaWNhdGVDb2x1bW5zID0gYWxsQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGNvbHVtbiwgaSkge1xuICAgICAgICByZXR1cm4gYWxsQ29sdW1ucy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uLmlkO1xuICAgICAgICB9KSAhPT0gaTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZHVwbGljYXRlQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKGFsbENvbHVtbnMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgY29sdW1ucyB3ZXJlIGZvdW5kIHdpdGggaWRzOiBcXFwiXCIgKyBkdXBsaWNhdGVDb2x1bW5zLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLmlkO1xuICAgICAgICB9KS5qb2luKCcsICcpICsgXCJcXFwiIGluIHRoZSBjb2x1bW5zIGFycmF5IGFib3ZlXCIpO1xuICAgICAgfVxuICAgIH0gLy8gTWFrZSB0aGUgaGVhZGVyR3JvdXBzXG5cblxuICAgIHZhciBoZWFkZXJHcm91cHMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWR1Y2VIb29rcyhnZXRIb29rcygpLmhlYWRlckdyb3VwcywgbWFrZUhlYWRlckdyb3Vwcyh2aXNpYmxlQ29sdW1ucywgZGVmYXVsdENvbHVtbiksIGdldEluc3RhbmNlKCkpO1xuICAgIH0sIFtnZXRIb29rcywgdmlzaWJsZUNvbHVtbnMsIGRlZmF1bHRDb2x1bW4sIGdldEluc3RhbmNlXS5jb25jYXQocmVkdWNlSG9va3MoZ2V0SG9va3MoKS5oZWFkZXJHcm91cHNEZXBzLCBbXSwge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KSkpO1xuICAgIGdldEluc3RhbmNlKCkuaGVhZGVyR3JvdXBzID0gaGVhZGVyR3JvdXBzOyAvLyBHZXQgdGhlIGZpcnN0IGxldmVsIG9mIGhlYWRlcnNcblxuICAgIHZhciBoZWFkZXJzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzLmxlbmd0aCA/IGhlYWRlckdyb3Vwc1swXS5oZWFkZXJzIDogW107XG4gICAgfSwgW2hlYWRlckdyb3Vwc10pO1xuICAgIGdldEluc3RhbmNlKCkuaGVhZGVycyA9IGhlYWRlcnM7IC8vIFByb3ZpZGUgYSBmbGF0IGhlYWRlciBsaXN0IGZvciB1dGlsaXRpZXNcblxuICAgIGdldEluc3RhbmNlKCkuZmxhdEhlYWRlcnMgPSBoZWFkZXJHcm91cHMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIGhlYWRlckdyb3VwKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KGFsbCwgaGVhZGVyR3JvdXAuaGVhZGVycyk7XG4gICAgfSwgW10pO1xuICAgIGxvb3BIb29rcyhnZXRIb29rcygpLnVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucywgZ2V0SW5zdGFuY2UoKSk7IC8vIEZpbHRlciBjb2x1bW5zIGRvd24gdG8gdmlzaWJsZSBvbmVzXG5cbiAgICB2YXIgdmlzaWJsZUNvbHVtbnNEZXAgPSB2aXNpYmxlQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmlzVmlzaWJsZTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkLmlkO1xuICAgIH0pLnNvcnQoKS5qb2luKCdfJyk7XG4gICAgdmlzaWJsZUNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2aXNpYmxlQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaXNWaXNpYmxlO1xuICAgICAgfSk7XG4gICAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFt2aXNpYmxlQ29sdW1ucywgdmlzaWJsZUNvbHVtbnNEZXBdKTtcbiAgICBnZXRJbnN0YW5jZSgpLnZpc2libGVDb2x1bW5zID0gdmlzaWJsZUNvbHVtbnM7IC8vIEhlYWRlciBWaXNpYmlsaXR5IGlzIG5lZWRlZCBieSB0aGlzIHBvaW50XG5cbiAgICB2YXIgX2NhbGN1bGF0ZUhlYWRlcldpZHRoID0gY2FsY3VsYXRlSGVhZGVyV2lkdGhzKGhlYWRlcnMpLFxuICAgICAgICB0b3RhbENvbHVtbnNNaW5XaWR0aCA9IF9jYWxjdWxhdGVIZWFkZXJXaWR0aFswXSxcbiAgICAgICAgdG90YWxDb2x1bW5zV2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGhbMV0sXG4gICAgICAgIHRvdGFsQ29sdW1uc01heFdpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoWzJdO1xuXG4gICAgZ2V0SW5zdGFuY2UoKS50b3RhbENvbHVtbnNNaW5XaWR0aCA9IHRvdGFsQ29sdW1uc01pbldpZHRoO1xuICAgIGdldEluc3RhbmNlKCkudG90YWxDb2x1bW5zV2lkdGggPSB0b3RhbENvbHVtbnNXaWR0aDtcbiAgICBnZXRJbnN0YW5jZSgpLnRvdGFsQ29sdW1uc01heFdpZHRoID0gdG90YWxDb2x1bW5zTWF4V2lkdGg7XG4gICAgbG9vcEhvb2tzKGdldEhvb2tzKCkudXNlSW5zdGFuY2UsIGdldEluc3RhbmNlKCkpIC8vIEVhY2ggbWF0ZXJpYWxpemVkIGhlYWRlciBuZWVkcyB0byBiZSBhc3NpZ25lZCBhIHJlbmRlciBmdW5jdGlvbiBhbmQgb3RoZXJcbiAgICAvLyBwcm9wIGdldHRlciBwcm9wZXJ0aWVzIGhlcmUuXG4gICAgO1xuICAgIFtdLmNvbmNhdChnZXRJbnN0YW5jZSgpLmZsYXRIZWFkZXJzLCBnZXRJbnN0YW5jZSgpLmFsbENvbHVtbnMpLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgLy8gR2l2ZSBjb2x1bW5zL2hlYWRlcnMgcmVuZGVyaW5nIHBvd2VyXG4gICAgICBjb2x1bW4ucmVuZGVyID0gbWFrZVJlbmRlcmVyKGdldEluc3RhbmNlKCksIGNvbHVtbik7IC8vIEdpdmUgY29sdW1ucy9oZWFkZXJzIGEgZGVmYXVsdCBnZXRIZWFkZXJQcm9wc1xuXG4gICAgICBjb2x1bW4uZ2V0SGVhZGVyUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldEhlYWRlclByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgfSk7IC8vIEdpdmUgY29sdW1ucy9oZWFkZXJzIGEgZGVmYXVsdCBnZXRGb290ZXJQcm9wc1xuXG4gICAgICBjb2x1bW4uZ2V0Rm9vdGVyUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldEZvb3RlclByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5oZWFkZXJHcm91cHMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBoZWFkZXJHcm91cHMuZmlsdGVyKGZ1bmN0aW9uIChoZWFkZXJHcm91cCwgaSkge1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSBoZWFkZXJzIGFuZCBoZWFkZXJHcm91cHMgdGhhdCBkb24ndCBoYXZlIHZpc2libGUgY29sdW1uc1xuICAgICAgICBoZWFkZXJHcm91cC5oZWFkZXJzID0gaGVhZGVyR3JvdXAuaGVhZGVycy5maWx0ZXIoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgIHZhciByZWN1cnNlID0gZnVuY3Rpb24gcmVjdXJzZShoZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVycy5maWx0ZXIoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICBpZiAoY29sdW1uLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXJzZShjb2x1bW4uaGVhZGVycyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLmlzVmlzaWJsZTtcbiAgICAgICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGNvbHVtbi5oZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXJzZShjb2x1bW4uaGVhZGVycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbHVtbi5pc1Zpc2libGU7XG4gICAgICAgIH0pOyAvLyBHaXZlIGhlYWRlckdyb3VwcyBnZXRSb3dQcm9wc1xuXG4gICAgICAgIGlmIChoZWFkZXJHcm91cC5oZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGhlYWRlckdyb3VwLmdldEhlYWRlckdyb3VwUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldEhlYWRlckdyb3VwUHJvcHMsIHtcbiAgICAgICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICAgICAgaGVhZGVyR3JvdXA6IGhlYWRlckdyb3VwLFxuICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBoZWFkZXJHcm91cC5nZXRGb290ZXJHcm91cFByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRGb290ZXJHcm91cFByb3BzLCB7XG4gICAgICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICAgIGhlYWRlckdyb3VwOiBoZWFkZXJHcm91cCxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9LCBbaGVhZGVyR3JvdXBzLCBnZXRJbnN0YW5jZSwgZ2V0SG9va3NdKTtcbiAgICBnZXRJbnN0YW5jZSgpLmZvb3Rlckdyb3VwcyA9IFtdLmNvbmNhdChnZXRJbnN0YW5jZSgpLmhlYWRlckdyb3VwcykucmV2ZXJzZSgpOyAvLyBUaGUgcHJlcGFyZVJvdyBmdW5jdGlvbiBpcyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBhbmQgTVVTVCBiZSBjYWxsZWQgb25cbiAgICAvLyBhbnkgcm93cyB0aGUgdXNlciB3aXNoZXMgdG8gYmUgZGlzcGxheWVkLlxuXG4gICAgZ2V0SW5zdGFuY2UoKS5wcmVwYXJlUm93ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJvdykge1xuICAgICAgcm93LmdldFJvd1Byb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRSb3dQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgcm93OiByb3dcbiAgICAgIH0pOyAvLyBCdWlsZCB0aGUgdmlzaWJsZSBjZWxscyBmb3IgZWFjaCByb3dcblxuICAgICAgcm93LmFsbENlbGxzID0gYWxsQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgdmFsdWUgPSByb3cudmFsdWVzW2NvbHVtbi5pZF07XG4gICAgICAgIHZhciBjZWxsID0ge1xuICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9OyAvLyBHaXZlIGVhY2ggY2VsbCBhIGdldENlbGxQcm9wcyBiYXNlXG5cbiAgICAgICAgY2VsbC5nZXRDZWxsUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldENlbGxQcm9wcywge1xuICAgICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICAgIGNlbGw6IGNlbGxcbiAgICAgICAgfSk7IC8vIEdpdmUgZWFjaCBjZWxsIGEgcmVuZGVyZXIgZnVuY3Rpb24gKHN1cHBvcnRzIG11bHRpcGxlIHJlbmRlcmVycylcblxuICAgICAgICBjZWxsLnJlbmRlciA9IG1ha2VSZW5kZXJlcihnZXRJbnN0YW5jZSgpLCBjb2x1bW4sIHtcbiAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICBjZWxsOiBjZWxsLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICB9KTtcbiAgICAgIHJvdy5jZWxscyA9IHZpc2libGVDb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiByb3cuYWxsQ2VsbHMuZmluZChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgIHJldHVybiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uLmlkO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBuZWVkIHRvIGFwcGx5IGFueSByb3cgc3BlY2lmaWMgaG9va3MgKHVzZUV4cGFuZGVkIHJlcXVpcmVzIHRoaXMpXG5cbiAgICAgIGxvb3BIb29rcyhnZXRIb29rcygpLnByZXBhcmVSb3csIHJvdywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgICAgfSk7XG4gICAgfSwgW2dldEhvb2tzLCBnZXRJbnN0YW5jZSwgYWxsQ29sdW1ucywgdmlzaWJsZUNvbHVtbnNdKTtcbiAgICBnZXRJbnN0YW5jZSgpLmdldFRhYmxlUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRhYmxlUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5nZXRUYWJsZUJvZHlQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VGFibGVCb2R5UHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgbG9vcEhvb2tzKGdldEhvb2tzKCkudXNlRmluYWxJbnN0YW5jZSwgZ2V0SW5zdGFuY2UoKSk7XG4gICAgcmV0dXJuIGdldEluc3RhbmNlKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlSGVhZGVyV2lkdGhzKGhlYWRlcnMsIGxlZnQpIHtcbiAgICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7XG4gICAgICBsZWZ0ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgc3VtVG90YWxNaW5XaWR0aCA9IDA7XG4gICAgdmFyIHN1bVRvdGFsV2lkdGggPSAwO1xuICAgIHZhciBzdW1Ub3RhbE1heFdpZHRoID0gMDtcbiAgICB2YXIgc3VtVG90YWxGbGV4V2lkdGggPSAwO1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICB2YXIgc3ViSGVhZGVycyA9IGhlYWRlci5oZWFkZXJzO1xuICAgICAgaGVhZGVyLnRvdGFsTGVmdCA9IGxlZnQ7XG5cbiAgICAgIGlmIChzdWJIZWFkZXJzICYmIHN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfY2FsY3VsYXRlSGVhZGVyV2lkdGgyID0gY2FsY3VsYXRlSGVhZGVyV2lkdGhzKHN1YkhlYWRlcnMsIGxlZnQpLFxuICAgICAgICAgICAgdG90YWxNaW5XaWR0aCA9IF9jYWxjdWxhdGVIZWFkZXJXaWR0aDJbMF0sXG4gICAgICAgICAgICB0b3RhbFdpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoMlsxXSxcbiAgICAgICAgICAgIHRvdGFsTWF4V2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGgyWzJdLFxuICAgICAgICAgICAgdG90YWxGbGV4V2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGgyWzNdO1xuXG4gICAgICAgIGhlYWRlci50b3RhbE1pbldpZHRoID0gdG90YWxNaW5XaWR0aDtcbiAgICAgICAgaGVhZGVyLnRvdGFsV2lkdGggPSB0b3RhbFdpZHRoO1xuICAgICAgICBoZWFkZXIudG90YWxNYXhXaWR0aCA9IHRvdGFsTWF4V2lkdGg7XG4gICAgICAgIGhlYWRlci50b3RhbEZsZXhXaWR0aCA9IHRvdGFsRmxleFdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyLnRvdGFsTWluV2lkdGggPSBoZWFkZXIubWluV2lkdGg7XG4gICAgICAgIGhlYWRlci50b3RhbFdpZHRoID0gTWF0aC5taW4oTWF0aC5tYXgoaGVhZGVyLm1pbldpZHRoLCBoZWFkZXIud2lkdGgpLCBoZWFkZXIubWF4V2lkdGgpO1xuICAgICAgICBoZWFkZXIudG90YWxNYXhXaWR0aCA9IGhlYWRlci5tYXhXaWR0aDtcbiAgICAgICAgaGVhZGVyLnRvdGFsRmxleFdpZHRoID0gaGVhZGVyLmNhblJlc2l6ZSA/IGhlYWRlci50b3RhbFdpZHRoIDogMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWRlci5pc1Zpc2libGUpIHtcbiAgICAgICAgbGVmdCArPSBoZWFkZXIudG90YWxXaWR0aDtcbiAgICAgICAgc3VtVG90YWxNaW5XaWR0aCArPSBoZWFkZXIudG90YWxNaW5XaWR0aDtcbiAgICAgICAgc3VtVG90YWxXaWR0aCArPSBoZWFkZXIudG90YWxXaWR0aDtcbiAgICAgICAgc3VtVG90YWxNYXhXaWR0aCArPSBoZWFkZXIudG90YWxNYXhXaWR0aDtcbiAgICAgICAgc3VtVG90YWxGbGV4V2lkdGggKz0gaGVhZGVyLnRvdGFsRmxleFdpZHRoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbc3VtVG90YWxNaW5XaWR0aCwgc3VtVG90YWxXaWR0aCwgc3VtVG90YWxNYXhXaWR0aCwgc3VtVG90YWxGbGV4V2lkdGhdO1xuICB9XG5cbiAgZnVuY3Rpb24gYWNjZXNzUm93c0ZvckNvbHVtbihfcmVmKSB7XG4gICAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgIHJvd3MgPSBfcmVmLnJvd3MsXG4gICAgICAgIGZsYXRSb3dzID0gX3JlZi5mbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWQgPSBfcmVmLnJvd3NCeUlkLFxuICAgICAgICBjb2x1bW4gPSBfcmVmLmNvbHVtbixcbiAgICAgICAgZ2V0Um93SWQgPSBfcmVmLmdldFJvd0lkLFxuICAgICAgICBnZXRTdWJSb3dzID0gX3JlZi5nZXRTdWJSb3dzLFxuICAgICAgICBhY2Nlc3NWYWx1ZUhvb2tzID0gX3JlZi5hY2Nlc3NWYWx1ZUhvb2tzLFxuICAgICAgICBnZXRJbnN0YW5jZSA9IF9yZWYuZ2V0SW5zdGFuY2U7XG5cbiAgICAvLyBBY2Nlc3MgdGhlIHJvdydzIGRhdGEgY29sdW1uLWJ5LWNvbHVtblxuICAgIC8vIFdlIGRvIGl0IHRoaXMgd2F5IHNvIHdlIGNhbiBpbmNyZW1lbnRhbGx5IGFkZCBtYXRlcmlhbGl6ZWRcbiAgICAvLyBjb2x1bW5zIGFmdGVyIHRoZSBmaXJzdCBwYXNzIGFuZCBhdm9pZCBleGNlc3NpdmUgbG9vcGluZ1xuICAgIHZhciBhY2Nlc3NSb3cgPSBmdW5jdGlvbiBhY2Nlc3NSb3cob3JpZ2luYWxSb3csIHJvd0luZGV4LCBkZXB0aCwgcGFyZW50LCBwYXJlbnRSb3dzKSB7XG4gICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIHJlZmVyZW5jZSBhcm91bmRcbiAgICAgIHZhciBvcmlnaW5hbCA9IG9yaWdpbmFsUm93O1xuICAgICAgdmFyIGlkID0gZ2V0Um93SWQob3JpZ2luYWxSb3csIHJvd0luZGV4LCBwYXJlbnQpO1xuICAgICAgdmFyIHJvdyA9IHJvd3NCeUlkW2lkXTsgLy8gSWYgdGhlIHJvdyBoYXNuJ3QgYmVlbiBjcmVhdGVkLCBsZXQncyBtYWtlIGl0XG5cbiAgICAgIGlmICghcm93KSB7XG4gICAgICAgIHJvdyA9IHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgb3JpZ2luYWw6IG9yaWdpbmFsLFxuICAgICAgICAgIGluZGV4OiByb3dJbmRleCxcbiAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgY2VsbHM6IFt7fV0gLy8gVGhpcyBpcyBhIGR1bW15IGNlbGxcblxuICAgICAgICB9OyAvLyBPdmVycmlkZSBjb21tb24gYXJyYXkgZnVuY3Rpb25zIChhbmQgdGhlIGR1bW15IGNlbGwncyBnZXRDZWxsUHJvcHMgZnVuY3Rpb24pXG4gICAgICAgIC8vIHRvIHNob3cgYW4gZXJyb3IgaWYgaXQgaXMgYWNjZXNzZWQgd2l0aG91dCBjYWxsaW5nIHByZXBhcmVSb3dcblxuICAgICAgICByb3cuY2VsbHMubWFwID0gdW5wcmVwYXJlZEFjY2Vzc1dhcm5pbmc7XG4gICAgICAgIHJvdy5jZWxscy5maWx0ZXIgPSB1bnByZXBhcmVkQWNjZXNzV2FybmluZztcbiAgICAgICAgcm93LmNlbGxzLmZvckVhY2ggPSB1bnByZXBhcmVkQWNjZXNzV2FybmluZztcbiAgICAgICAgcm93LmNlbGxzWzBdLmdldENlbGxQcm9wcyA9IHVucHJlcGFyZWRBY2Nlc3NXYXJuaW5nOyAvLyBDcmVhdGUgdGhlIGNlbGxzIGFuZCB2YWx1ZXNcblxuICAgICAgICByb3cudmFsdWVzID0ge307IC8vIFB1c2ggdGhpcyByb3cgaW50byB0aGUgcGFyZW50Um93cyBhcnJheVxuXG4gICAgICAgIHBhcmVudFJvd3MucHVzaChyb3cpOyAvLyBLZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBpbiBhIGZsYXQgYXJyYXlcblxuICAgICAgICBmbGF0Um93cy5wdXNoKHJvdyk7IC8vIEFsc28ga2VlcCB0cmFjayBvZiBldmVyeSByb3cgYnkgaXRzIElEXG5cbiAgICAgICAgcm93c0J5SWRbaWRdID0gcm93OyAvLyBHZXQgdGhlIG9yaWdpbmFsIHN1YnJvd3NcblxuICAgICAgICByb3cub3JpZ2luYWxTdWJSb3dzID0gZ2V0U3ViUm93cyhvcmlnaW5hbFJvdywgcm93SW5kZXgpOyAvLyBUaGVuIHJlY3Vyc2l2ZWx5IGFjY2VzcyB0aGVtXG5cbiAgICAgICAgaWYgKHJvdy5vcmlnaW5hbFN1YlJvd3MpIHtcbiAgICAgICAgICB2YXIgc3ViUm93cyA9IFtdO1xuICAgICAgICAgIHJvdy5vcmlnaW5hbFN1YlJvd3MuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1JvdyhkLCBpLCBkZXB0aCArIDEsIHJvdywgc3ViUm93cyk7XG4gICAgICAgICAgfSk7IC8vIEtlZXAgdGhlIG5ldyBzdWJSb3dzIGFycmF5IG9uIHRoZSByb3dcblxuICAgICAgICAgIHJvdy5zdWJSb3dzID0gc3ViUm93cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyb3cuc3ViUm93cykge1xuICAgICAgICAvLyBJZiB0aGUgcm93IGV4aXN0cywgdGhlbiBpdCdzIGFscmVhZHkgYmVlbiBhY2Nlc3NlZFxuICAgICAgICAvLyBLZWVwIHJlY3Vyc2luZywgYnV0IGRvbid0IHdvcnJ5IGFib3V0IHBhc3NpbmcgdGhlXG4gICAgICAgIC8vIGFjY3VtbGF0b3IgYXJyYXkgKHRob3NlIHJvd3MgYWxyZWFkeSBleGlzdClcbiAgICAgICAgcm93Lm9yaWdpbmFsU3ViUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY2Vzc1JvdyhkLCBpLCBkZXB0aCArIDEsIHJvdyk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJZiB0aGUgY29sdW1uIGhhcyBhbiBhY2Nlc3NvciwgdXNlIGl0IHRvIGdldCBhIHZhbHVlXG5cblxuICAgICAgaWYgKGNvbHVtbi5hY2Nlc3Nvcikge1xuICAgICAgICByb3cudmFsdWVzW2NvbHVtbi5pZF0gPSBjb2x1bW4uYWNjZXNzb3Iob3JpZ2luYWxSb3csIHJvd0luZGV4LCByb3csIHBhcmVudFJvd3MsIGRhdGEpO1xuICAgICAgfSAvLyBBbGxvdyBwbHVnaW5zIHRvIG1hbmlwdWxhdGUgdGhlIGNvbHVtbiB2YWx1ZVxuXG5cbiAgICAgIHJvdy52YWx1ZXNbY29sdW1uLmlkXSA9IHJlZHVjZUhvb2tzKGFjY2Vzc1ZhbHVlSG9va3MsIHJvdy52YWx1ZXNbY29sdW1uLmlkXSwge1xuICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgICB9LCB0cnVlKTtcbiAgICB9O1xuXG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbFJvdywgcm93SW5kZXgpIHtcbiAgICAgIHJldHVybiBhY2Nlc3NSb3cob3JpZ2luYWxSb3csIHJvd0luZGV4LCAwLCB1bmRlZmluZWQsIHJvd3MpO1xuICAgIH0pO1xuICB9XG5cbiAgYWN0aW9ucy5yZXNldEV4cGFuZGVkID0gJ3Jlc2V0RXhwYW5kZWQnO1xuICBhY3Rpb25zLnRvZ2dsZVJvd0V4cGFuZGVkID0gJ3RvZ2dsZVJvd0V4cGFuZGVkJztcbiAgYWN0aW9ucy50b2dnbGVBbGxSb3dzRXhwYW5kZWQgPSAndG9nZ2xlQWxsUm93c0V4cGFuZGVkJztcbiAgdmFyIHVzZUV4cGFuZGVkID0gZnVuY3Rpb24gdXNlRXhwYW5kZWQoaG9va3MpIHtcbiAgICBob29rcy5nZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyA9IFtkZWZhdWx0R2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHNdO1xuICAgIGhvb2tzLmdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDEpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkMSk7XG4gICAgaG9va3MucHJlcGFyZVJvdy5wdXNoKHByZXBhcmVSb3cpO1xuICB9O1xuICB1c2VFeHBhbmRlZC5wbHVnaW5OYW1lID0gJ3VzZUV4cGFuZGVkJztcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgaW5zdGFuY2UudG9nZ2xlQWxsUm93c0V4cGFuZGVkKCk7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgIH0sXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBBbGwgUm93cyBFeHBhbmRlZCdcbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0VG9nZ2xlUm93RXhwYW5kZWRQcm9wcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgcm93ID0gX3JlZjIucm93O1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgIHJvdy50b2dnbGVSb3dFeHBhbmRlZCgpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgdGl0bGU6ICdUb2dnbGUgUm93IEV4cGFuZGVkJ1xuICAgIH1dO1xuICB9OyAvLyBSZWR1Y2VyXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDEoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgZXhwYW5kZWQ6IHt9XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0RXhwYW5kZWQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZXhwYW5kZWQ6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5leHBhbmRlZCB8fCB7fVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCkge1xuICAgICAgdmFyIHZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQ7XG4gICAgICB2YXIgaXNBbGxSb3dzRXhwYW5kZWQgPSBPYmplY3Qua2V5cyhyb3dzQnlJZCkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhzdGF0ZS5leHBhbmRlZCkubGVuZ3RoO1xuICAgICAgdmFyIGV4cGFuZEFsbCA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICFpc0FsbFJvd3NFeHBhbmRlZDtcblxuICAgICAgaWYgKGV4cGFuZEFsbCkge1xuICAgICAgICB2YXIgZXhwYW5kZWQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocm93c0J5SWQpLmZvckVhY2goZnVuY3Rpb24gKHJvd0lkKSB7XG4gICAgICAgICAgZXhwYW5kZWRbcm93SWRdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBleHBhbmRlZDogZXhwYW5kZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZXhwYW5kZWQ6IHt9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlUm93RXhwYW5kZWQpIHtcbiAgICAgIHZhciBpZCA9IGFjdGlvbi5pZCxcbiAgICAgICAgICBzZXRFeHBhbmRlZCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciBleGlzdHMgPSBzdGF0ZS5leHBhbmRlZFtpZF07XG4gICAgICB2YXIgc2hvdWxkRXhpc3QgPSB0eXBlb2Ygc2V0RXhwYW5kZWQgIT09ICd1bmRlZmluZWQnID8gc2V0RXhwYW5kZWQgOiAhZXhpc3RzO1xuXG4gICAgICBpZiAoIWV4aXN0cyAmJiBzaG91bGRFeGlzdCkge1xuICAgICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBleHBhbmRlZDogX2V4dGVuZHMoe30sIHN0YXRlLmV4cGFuZGVkLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltpZF0gPSB0cnVlLCBfZXh0ZW5kczIpKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RzICYmICFzaG91bGRFeGlzdCkge1xuICAgICAgICB2YXIgX3N0YXRlJGV4cGFuZGVkID0gc3RhdGUuZXhwYW5kZWQsXG4gICAgICAgICAgICBfID0gX3N0YXRlJGV4cGFuZGVkW2lkXSxcbiAgICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfc3RhdGUkZXhwYW5kZWQsIFtpZF0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG5cbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIGV4cGFuZGVkOiByZXN0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDEoaW5zdGFuY2UpIHtcbiAgICB2YXIgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIHJvd3MgPSBpbnN0YW5jZS5yb3dzLFxuICAgICAgICByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkLFxuICAgICAgICBfaW5zdGFuY2UkbWFudWFsRXhwYW4gPSBpbnN0YW5jZS5tYW51YWxFeHBhbmRlZEtleSxcbiAgICAgICAgbWFudWFsRXhwYW5kZWRLZXkgPSBfaW5zdGFuY2UkbWFudWFsRXhwYW4gPT09IHZvaWQgMCA/ICdleHBhbmRlZCcgOiBfaW5zdGFuY2UkbWFudWFsRXhwYW4sXG4gICAgICAgIF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCA9IGluc3RhbmNlLnBhZ2luYXRlRXhwYW5kZWRSb3dzLFxuICAgICAgICBwYWdpbmF0ZUV4cGFuZGVkUm93cyA9IF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCxcbiAgICAgICAgX2luc3RhbmNlJGV4cGFuZFN1YlJvID0gaW5zdGFuY2UuZXhwYW5kU3ViUm93cyxcbiAgICAgICAgZXhwYW5kU3ViUm93cyA9IF9pbnN0YW5jZSRleHBhbmRTdWJSbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRleHBhbmRTdWJSbyxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldEV4ID0gaW5zdGFuY2UuYXV0b1Jlc2V0RXhwYW5kZWQsXG4gICAgICAgIGF1dG9SZXNldEV4cGFuZGVkID0gX2luc3RhbmNlJGF1dG9SZXNldEV4ID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldEV4LFxuICAgICAgICBnZXRIb29rcyA9IGluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgZXhwYW5kZWQgPSBpbnN0YW5jZS5zdGF0ZS5leHBhbmRlZCxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaDtcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZVNvcnRCeScsICd1c2VHcm91cEJ5JywgJ3VzZVBpdm90Q29sdW1ucycsICd1c2VHbG9iYWxGaWx0ZXInXSwgJ3VzZUV4cGFuZGVkJyk7XG4gICAgdmFyIGdldEF1dG9SZXNldEV4cGFuZGVkID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldEV4cGFuZGVkKTtcbiAgICB2YXIgaXNBbGxSb3dzRXhwYW5kZWQgPSBCb29sZWFuKE9iamVjdC5rZXlzKHJvd3NCeUlkKS5sZW5ndGggJiYgT2JqZWN0LmtleXMoZXhwYW5kZWQpLmxlbmd0aCk7XG5cbiAgICBpZiAoaXNBbGxSb3dzRXhwYW5kZWQpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhyb3dzQnlJZCkuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuICFleHBhbmRlZFtpZF07XG4gICAgICB9KSkge1xuICAgICAgICBpc0FsbFJvd3NFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gLy8gQnlwYXNzIGFueSBlZmZlY3RzIGZyb20gZmlyaW5nIHdoZW4gdGhpcyBjaGFuZ2VzXG5cblxuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldEV4cGFuZGVkKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRFeHBhbmRlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIGRhdGFdKTtcbiAgICB2YXIgdG9nZ2xlUm93RXhwYW5kZWQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaWQsIHZhbHVlKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlUm93RXhwYW5kZWQsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgdG9nZ2xlQWxsUm93c0V4cGFuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgZXhwYW5kZWRSb3dzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZFJvd3Mocm93cywge1xuICAgICAgICAgIG1hbnVhbEV4cGFuZGVkS2V5OiBtYW51YWxFeHBhbmRlZEtleSxcbiAgICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQsXG4gICAgICAgICAgZXhwYW5kU3ViUm93czogZXhwYW5kU3ViUm93c1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfSwgW3BhZ2luYXRlRXhwYW5kZWRSb3dzLCByb3dzLCBtYW51YWxFeHBhbmRlZEtleSwgZXhwYW5kZWQsIGV4cGFuZFN1YlJvd3NdKTtcbiAgICB2YXIgZXhwYW5kZWREZXB0aCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZpbmRFeHBhbmRlZERlcHRoKGV4cGFuZGVkKTtcbiAgICB9LCBbZXhwYW5kZWRdKTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIHZhciBnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcHJlRXhwYW5kZWRSb3dzOiByb3dzLFxuICAgICAgZXhwYW5kZWRSb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgICByb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgICBleHBhbmRlZERlcHRoOiBleHBhbmRlZERlcHRoLFxuICAgICAgaXNBbGxSb3dzRXhwYW5kZWQ6IGlzQWxsUm93c0V4cGFuZGVkLFxuICAgICAgdG9nZ2xlUm93RXhwYW5kZWQ6IHRvZ2dsZVJvd0V4cGFuZGVkLFxuICAgICAgdG9nZ2xlQWxsUm93c0V4cGFuZGVkOiB0b2dnbGVBbGxSb3dzRXhwYW5kZWQsXG4gICAgICBnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wczogZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVSb3cocm93LCBfcmVmMykge1xuICAgIHZhciBnZXRIb29rcyA9IF9yZWYzLmluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBpbnN0YW5jZSA9IF9yZWYzLmluc3RhbmNlO1xuXG4gICAgcm93LnRvZ2dsZVJvd0V4cGFuZGVkID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnRvZ2dsZVJvd0V4cGFuZGVkKHJvdy5pZCwgc2V0KTtcbiAgICB9O1xuXG4gICAgcm93LmdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgIHJvdzogcm93XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRXhwYW5kZWREZXB0aChleHBhbmRlZCkge1xuICAgIHZhciBtYXhEZXB0aCA9IDA7XG4gICAgT2JqZWN0LmtleXMoZXhwYW5kZWQpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgc3BsaXRJZCA9IGlkLnNwbGl0KCcuJyk7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBzcGxpdElkLmxlbmd0aCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1heERlcHRoO1xuICB9XG5cbiAgdmFyIHRleHQgPSBmdW5jdGlvbiB0ZXh0KHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByb3dzID0gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhyb3dWYWx1ZSkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhTdHJpbmcoZmlsdGVyVmFsdWUpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG5cbiAgdGV4dC5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsO1xuICB9O1xuXG4gIHZhciBleGFjdFRleHQgPSBmdW5jdGlvbiBleGFjdFRleHQocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhyb3dWYWx1ZSkudG9Mb3dlckNhc2UoKSA9PT0gU3RyaW5nKGZpbHRlclZhbHVlKS50b0xvd2VyQ2FzZSgpIDogdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGV4YWN0VGV4dC5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsO1xuICB9O1xuXG4gIHZhciBleGFjdFRleHRDYXNlID0gZnVuY3Rpb24gZXhhY3RUZXh0Q2FzZShyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiByb3dWYWx1ZSAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKHJvd1ZhbHVlKSA9PT0gU3RyaW5nKGZpbHRlclZhbHVlKSA6IHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBleGFjdFRleHRDYXNlLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWw7XG4gIH07XG5cbiAgdmFyIGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUuaW5jbHVkZXMoZmlsdGVyVmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgaW5jbHVkZXMuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbCB8fCAhdmFsLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgaW5jbHVkZXNBbGwgPSBmdW5jdGlvbiBpbmNsdWRlc0FsbChyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiByb3dWYWx1ZSAmJiByb3dWYWx1ZS5sZW5ndGggJiYgZmlsdGVyVmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHJldHVybiByb3dWYWx1ZS5pbmNsdWRlcyh2YWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGluY2x1ZGVzQWxsLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgIXZhbC5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGluY2x1ZGVzU29tZSA9IGZ1bmN0aW9uIGluY2x1ZGVzU29tZShyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiByb3dWYWx1ZSAmJiByb3dWYWx1ZS5sZW5ndGggJiYgZmlsdGVyVmFsdWUuc29tZShmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHJvd1ZhbHVlLmluY2x1ZGVzKHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgaW5jbHVkZXNTb21lLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgIXZhbC5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGluY2x1ZGVzVmFsdWUgPSBmdW5jdGlvbiBpbmNsdWRlc1ZhbHVlKHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIGZpbHRlclZhbHVlLmluY2x1ZGVzKHJvd1ZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGluY2x1ZGVzVmFsdWUuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbCB8fCAhdmFsLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgZXhhY3QgPSBmdW5jdGlvbiBleGFjdChyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiByb3dWYWx1ZSA9PT0gZmlsdGVyVmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBleGFjdC5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbiAgfTtcblxuICB2YXIgZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG4gICAgICAgIHJldHVybiByb3dWYWx1ZSA9PSBmaWx0ZXJWYWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGVxdWFscy5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4ocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHZhciBfcmVmID0gZmlsdGVyVmFsdWUgfHwgW10sXG4gICAgICAgIG1pbiA9IF9yZWZbMF0sXG4gICAgICAgIG1heCA9IF9yZWZbMV07XG5cbiAgICBtaW4gPSB0eXBlb2YgbWluID09PSAnbnVtYmVyJyA/IG1pbiA6IC1JbmZpbml0eTtcbiAgICBtYXggPSB0eXBlb2YgbWF4ID09PSAnbnVtYmVyJyA/IG1heCA6IEluZmluaXR5O1xuXG4gICAgaWYgKG1pbiA+IG1heCkge1xuICAgICAgdmFyIHRlbXAgPSBtaW47XG4gICAgICBtaW4gPSBtYXg7XG4gICAgICBtYXggPSB0ZW1wO1xuICAgIH1cblxuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgPj0gbWluICYmIHJvd1ZhbHVlIDw9IG1heDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGJldHdlZW4uYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbCB8fCB0eXBlb2YgdmFsWzBdICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsWzFdICE9PSAnbnVtYmVyJztcbiAgfTtcblxuICB2YXIgZmlsdGVyVHlwZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHRleHQ6IHRleHQsXG4gICAgZXhhY3RUZXh0OiBleGFjdFRleHQsXG4gICAgZXhhY3RUZXh0Q2FzZTogZXhhY3RUZXh0Q2FzZSxcbiAgICBpbmNsdWRlczogaW5jbHVkZXMsXG4gICAgaW5jbHVkZXNBbGw6IGluY2x1ZGVzQWxsLFxuICAgIGluY2x1ZGVzU29tZTogaW5jbHVkZXNTb21lLFxuICAgIGluY2x1ZGVzVmFsdWU6IGluY2x1ZGVzVmFsdWUsXG4gICAgZXhhY3Q6IGV4YWN0LFxuICAgIGVxdWFsczogZXF1YWxzLFxuICAgIGJldHdlZW46IGJldHdlZW5cbiAgfSk7XG5cbiAgYWN0aW9ucy5yZXNldEZpbHRlcnMgPSAncmVzZXRGaWx0ZXJzJztcbiAgYWN0aW9ucy5zZXRGaWx0ZXIgPSAnc2V0RmlsdGVyJztcbiAgYWN0aW9ucy5zZXRBbGxGaWx0ZXJzID0gJ3NldEFsbEZpbHRlcnMnO1xuICB2YXIgdXNlRmlsdGVycyA9IGZ1bmN0aW9uIHVzZUZpbHRlcnMoaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQyKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDIpO1xuICB9O1xuICB1c2VGaWx0ZXJzLnBsdWdpbk5hbWUgPSAndXNlRmlsdGVycyc7XG5cbiAgZnVuY3Rpb24gcmVkdWNlciQyKHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGZpbHRlcnM6IFtdXG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0RmlsdGVycykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBmaWx0ZXJzOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuZmlsdGVycyB8fCBbXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldEZpbHRlcikge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIGZpbHRlclZhbHVlID0gYWN0aW9uLmZpbHRlclZhbHVlO1xuICAgICAgdmFyIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICAgIHVzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLmZpbHRlclR5cGVzO1xuICAgICAgdmFyIGNvbHVtbiA9IGFsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QtVGFibGU6IENvdWxkIG5vdCBmaW5kIGEgY29sdW1uIHdpdGggaWQ6IFwiICsgY29sdW1uSWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsdGVyTWV0aG9kID0gZ2V0RmlsdGVyTWV0aG9kKGNvbHVtbi5maWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuICAgICAgdmFyIHByZXZpb3VzZmlsdGVyID0gc3RhdGUuZmlsdGVycy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pO1xuICAgICAgdmFyIG5ld0ZpbHRlciA9IGZ1bmN0aW9uYWxVcGRhdGUoZmlsdGVyVmFsdWUsIHByZXZpb3VzZmlsdGVyICYmIHByZXZpb3VzZmlsdGVyLnZhbHVlKTsgLy9cblxuICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyTWV0aG9kLmF1dG9SZW1vdmUsIG5ld0ZpbHRlciwgY29sdW1uKSkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmlkICE9PSBjb2x1bW5JZDtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZpb3VzZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbklkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGNvbHVtbklkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdGaWx0ZXJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZmlsdGVyczogW10uY29uY2F0KHN0YXRlLmZpbHRlcnMsIFt7XG4gICAgICAgICAgaWQ6IGNvbHVtbklkLFxuICAgICAgICAgIHZhbHVlOiBuZXdGaWx0ZXJcbiAgICAgICAgfV0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0QWxsRmlsdGVycykge1xuICAgICAgdmFyIGZpbHRlcnMgPSBhY3Rpb24uZmlsdGVycztcbiAgICAgIHZhciBfYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgICAgX3VzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLmZpbHRlclR5cGVzO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgZmlsdGVyczogZnVuY3Rpb25hbFVwZGF0ZShmaWx0ZXJzLCBzdGF0ZS5maWx0ZXJzKS5maWx0ZXIoZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgIHZhciBjb2x1bW4gPSBfYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gZmlsdGVyLmlkO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGZpbHRlck1ldGhvZCA9IGdldEZpbHRlck1ldGhvZChjb2x1bW4uZmlsdGVyLCBfdXNlckZpbHRlclR5cGVzIHx8IHt9LCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJNZXRob2QuYXV0b1JlbW92ZSwgZmlsdGVyLnZhbHVlLCBjb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQyKGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgZmxhdFJvd3MgPSBpbnN0YW5jZS5mbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIHVzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLmZpbHRlclR5cGVzLFxuICAgICAgICBtYW51YWxGaWx0ZXJzID0gaW5zdGFuY2UubWFudWFsRmlsdGVycyxcbiAgICAgICAgX2luc3RhbmNlJGRlZmF1bHRDYW5GID0gaW5zdGFuY2UuZGVmYXVsdENhbkZpbHRlcixcbiAgICAgICAgZGVmYXVsdENhbkZpbHRlciA9IF9pbnN0YW5jZSRkZWZhdWx0Q2FuRiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaW5zdGFuY2UkZGVmYXVsdENhbkYsXG4gICAgICAgIGRpc2FibGVGaWx0ZXJzID0gaW5zdGFuY2UuZGlzYWJsZUZpbHRlcnMsXG4gICAgICAgIGZpbHRlcnMgPSBpbnN0YW5jZS5zdGF0ZS5maWx0ZXJzLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0RmkgPSBpbnN0YW5jZS5hdXRvUmVzZXRGaWx0ZXJzLFxuICAgICAgICBhdXRvUmVzZXRGaWx0ZXJzID0gX2luc3RhbmNlJGF1dG9SZXNldEZpID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldEZpO1xuICAgIHZhciBzZXRGaWx0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29sdW1uSWQsIGZpbHRlclZhbHVlKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0RmlsdGVyLFxuICAgICAgICBjb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgIGZpbHRlclZhbHVlOiBmaWx0ZXJWYWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHNldEFsbEZpbHRlcnMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZmlsdGVycykge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldEFsbEZpbHRlcnMsXG4gICAgICAgIGZpbHRlcnM6IGZpbHRlcnNcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICB2YXIgaWQgPSBjb2x1bW4uaWQsXG4gICAgICAgICAgYWNjZXNzb3IgPSBjb2x1bW4uYWNjZXNzb3IsXG4gICAgICAgICAgY29sdW1uRGVmYXVsdENhbkZpbHRlciA9IGNvbHVtbi5kZWZhdWx0Q2FuRmlsdGVyLFxuICAgICAgICAgIGNvbHVtbkRpc2FibGVGaWx0ZXJzID0gY29sdW1uLmRpc2FibGVGaWx0ZXJzOyAvLyBEZXRlcm1pbmUgaWYgYSBjb2x1bW4gaXMgZmlsdGVyYWJsZVxuXG4gICAgICBjb2x1bW4uY2FuRmlsdGVyID0gYWNjZXNzb3IgPyBnZXRGaXJzdERlZmluZWQoY29sdW1uRGlzYWJsZUZpbHRlcnMgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgZGlzYWJsZUZpbHRlcnMgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgdHJ1ZSkgOiBnZXRGaXJzdERlZmluZWQoY29sdW1uRGVmYXVsdENhbkZpbHRlciwgZGVmYXVsdENhbkZpbHRlciwgZmFsc2UpOyAvLyBQcm92aWRlIHRoZSBjb2x1bW4gYSB3YXkgb2YgdXBkYXRpbmcgdGhlIGZpbHRlciB2YWx1ZVxuXG4gICAgICBjb2x1bW4uc2V0RmlsdGVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gc2V0RmlsdGVyKGNvbHVtbi5pZCwgdmFsKTtcbiAgICAgIH07IC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgZmlsdGVyIHZhbHVlIHRvIHRoZSBjb2x1bW4gZm9yXG4gICAgICAvLyBjb252ZW5pZW5jZVxuXG5cbiAgICAgIHZhciBmb3VuZCA9IGZpbHRlcnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gaWQ7XG4gICAgICB9KTtcbiAgICAgIGNvbHVtbi5maWx0ZXJWYWx1ZSA9IGZvdW5kICYmIGZvdW5kLnZhbHVlO1xuICAgIH0pO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VNZW1vID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWFudWFsRmlsdGVycyB8fCAhZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtyb3dzLCBmbGF0Um93cywgcm93c0J5SWRdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlsdGVyZWRGbGF0Um93cyA9IFtdO1xuICAgICAgdmFyIGZpbHRlcmVkUm93c0J5SWQgPSB7fTsgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG5cbiAgICAgIHZhciBmaWx0ZXJSb3dzID0gZnVuY3Rpb24gZmlsdGVyUm93cyhyb3dzLCBkZXB0aCkge1xuICAgICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlcHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWx0ZXJlZFJvd3MgPSByb3dzO1xuICAgICAgICBmaWx0ZXJlZFJvd3MgPSBmaWx0ZXJzLnJlZHVjZShmdW5jdGlvbiAoZmlsdGVyZWRTb0ZhciwgX3JlZikge1xuICAgICAgICAgIHZhciBjb2x1bW5JZCA9IF9yZWYuaWQsXG4gICAgICAgICAgICAgIGZpbHRlclZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaWx0ZXJzIGNvbHVtblxuICAgICAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRTb0ZhcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbHVtbi5wcmVGaWx0ZXJlZFJvd3MgPSBmaWx0ZXJlZFNvRmFyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmaWx0ZXJNZXRob2QgPSBnZXRGaWx0ZXJNZXRob2QoY29sdW1uLmZpbHRlciwgdXNlckZpbHRlclR5cGVzIHx8IHt9LCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAgICAgICBpZiAoIWZpbHRlck1ldGhvZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgYSB2YWxpZCAnY29sdW1uLmZpbHRlcicgZm9yIGNvbHVtbiB3aXRoIHRoZSBJRDogXCIgKyBjb2x1bW4uaWQgKyBcIi5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRTb0ZhcjtcbiAgICAgICAgICB9IC8vIFBhc3MgdGhlIHJvd3MsIGlkLCBmaWx0ZXJWYWx1ZSBhbmQgY29sdW1uIHRvIHRoZSBmaWx0ZXJNZXRob2RcbiAgICAgICAgICAvLyB0byBnZXQgdGhlIGZpbHRlcmVkIHJvd3MgYmFja1xuXG5cbiAgICAgICAgICBjb2x1bW4uZmlsdGVyZWRSb3dzID0gZmlsdGVyTWV0aG9kKGZpbHRlcmVkU29GYXIsIFtjb2x1bW5JZF0sIGZpbHRlclZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gY29sdW1uLmZpbHRlcmVkUm93cztcbiAgICAgICAgfSwgcm93cyk7IC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gYW55IHN1YlJvd3NcbiAgICAgICAgLy8gV2UgdGVjaG5pY2FsbHkgY291bGQgZG8gdGhpcyByZWN1cnNpdmVseSBpbiB0aGUgYWJvdmUgbG9vcCxcbiAgICAgICAgLy8gYnV0IHRoYXQgd291bGQgc2V2ZXJlbHkgaGluZGVyIHRoZSBBUEkgZm9yIHRoZSB1c2VyLCBzaW5jZSB0aGV5XG4gICAgICAgIC8vIHdvdWxkIGJlIHJlcXVpcmVkIHRvIGRvIHRoYXQgcmVjdXJzaW9uIGluIHNvbWUgc2NlbmFyaW9zXG5cbiAgICAgICAgZmlsdGVyZWRSb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgIGZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcblxuICAgICAgICAgIGlmICghcm93LnN1YlJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cuc3ViUm93cyA9IHJvdy5zdWJSb3dzICYmIHJvdy5zdWJSb3dzLmxlbmd0aCA+IDAgPyBmaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpIDogcm93LnN1YlJvd3M7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWRSb3dzO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFtmaWx0ZXJSb3dzKHJvd3MpLCBmaWx0ZXJlZEZsYXRSb3dzLCBmaWx0ZXJlZFJvd3NCeUlkXTtcbiAgICB9LCBbbWFudWFsRmlsdGVycywgZmlsdGVycywgcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkLCBhbGxDb2x1bW5zLCB1c2VyRmlsdGVyVHlwZXNdKSxcbiAgICAgICAgZmlsdGVyZWRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIGZpbHRlcmVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1sxXSxcbiAgICAgICAgZmlsdGVyZWRSb3dzQnlJZCA9IF9SZWFjdCR1c2VNZW1vWzJdO1xuXG4gICAgUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBOb3cgdGhhdCBlYWNoIGZpbHRlcmVkIGNvbHVtbiBoYXMgaXQncyBwYXJ0aWFsbHkgZmlsdGVyZWQgcm93cyxcbiAgICAgIC8vIGxldHMgYXNzaWduIHRoZSBmaW5hbCBmaWx0ZXJlZCByb3dzIHRvIGFsbCBvZiB0aGUgb3RoZXIgY29sdW1uc1xuICAgICAgdmFyIG5vbkZpbHRlcmVkQ29sdW1ucyA9IGFsbENvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuICFmaWx0ZXJzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uLmlkO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBUaGlzIGVzc2VudGlhbGx5IGVuYWJsZXMgZmFjZXRlZCBmaWx0ZXIgb3B0aW9ucyB0byBiZSBidWlsdCBlYXNpbHlcbiAgICAgIC8vIHVzaW5nIGV2ZXJ5IGNvbHVtbidzIHByZUZpbHRlcmVkUm93cyB2YWx1ZVxuXG4gICAgICBub25GaWx0ZXJlZENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIGNvbHVtbi5wcmVGaWx0ZXJlZFJvd3MgPSBmaWx0ZXJlZFJvd3M7XG4gICAgICAgIGNvbHVtbi5maWx0ZXJlZFJvd3MgPSBmaWx0ZXJlZFJvd3M7XG4gICAgICB9KTtcbiAgICB9LCBbZmlsdGVyZWRSb3dzLCBmaWx0ZXJzLCBhbGxDb2x1bW5zXSk7XG4gICAgdmFyIGdldEF1dG9SZXNldEZpbHRlcnMgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0RmlsdGVycyk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0RmlsdGVycygpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0RmlsdGVyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIG1hbnVhbEZpbHRlcnMgPyBudWxsIDogZGF0YV0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHByZUZpbHRlcmVkUm93czogcm93cyxcbiAgICAgIHByZUZpbHRlcmVkRmxhdFJvd3M6IGZsYXRSb3dzLFxuICAgICAgcHJlRmlsdGVyZWRSb3dzQnlJZDogcm93c0J5SWQsXG4gICAgICBmaWx0ZXJlZFJvd3M6IGZpbHRlcmVkUm93cyxcbiAgICAgIGZpbHRlcmVkRmxhdFJvd3M6IGZpbHRlcmVkRmxhdFJvd3MsXG4gICAgICBmaWx0ZXJlZFJvd3NCeUlkOiBmaWx0ZXJlZFJvd3NCeUlkLFxuICAgICAgcm93czogZmlsdGVyZWRSb3dzLFxuICAgICAgZmxhdFJvd3M6IGZpbHRlcmVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogZmlsdGVyZWRSb3dzQnlJZCxcbiAgICAgIHNldEZpbHRlcjogc2V0RmlsdGVyLFxuICAgICAgc2V0QWxsRmlsdGVyczogc2V0QWxsRmlsdGVyc1xuICAgIH0pO1xuICB9XG5cbiAgYWN0aW9ucy5yZXNldEdsb2JhbEZpbHRlciA9ICdyZXNldEdsb2JhbEZpbHRlcic7XG4gIGFjdGlvbnMuc2V0R2xvYmFsRmlsdGVyID0gJ3NldEdsb2JhbEZpbHRlcic7XG4gIHZhciB1c2VHbG9iYWxGaWx0ZXIgPSBmdW5jdGlvbiB1c2VHbG9iYWxGaWx0ZXIoaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQzKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDMpO1xuICB9O1xuICB1c2VHbG9iYWxGaWx0ZXIucGx1Z2luTmFtZSA9ICd1c2VHbG9iYWxGaWx0ZXInO1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkMyhzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldEdsb2JhbEZpbHRlcikge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBnbG9iYWxGaWx0ZXI6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5nbG9iYWxGaWx0ZXIgfHwgdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0R2xvYmFsRmlsdGVyKSB7XG4gICAgICB2YXIgZmlsdGVyVmFsdWUgPSBhY3Rpb24uZmlsdGVyVmFsdWU7XG4gICAgICB2YXIgdXNlckZpbHRlclR5cGVzID0gaW5zdGFuY2UudXNlckZpbHRlclR5cGVzO1xuICAgICAgdmFyIGZpbHRlck1ldGhvZCA9IGdldEZpbHRlck1ldGhvZChpbnN0YW5jZS5nbG9iYWxGaWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuICAgICAgdmFyIG5ld0ZpbHRlciA9IGZ1bmN0aW9uYWxVcGRhdGUoZmlsdGVyVmFsdWUsIHN0YXRlLmdsb2JhbEZpbHRlcik7IC8vXG5cbiAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlck1ldGhvZC5hdXRvUmVtb3ZlLCBuZXdGaWx0ZXIpKSB7XG4gICAgICAgIHZhciBnbG9iYWxGaWx0ZXIgPSBzdGF0ZS5nbG9iYWxGaWx0ZXIsXG4gICAgICAgICAgICBzdGF0ZVdpdGhvdXRHbG9iYWxGaWx0ZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzdGF0ZSwgW1wiZ2xvYmFsRmlsdGVyXCJdKTtcblxuICAgICAgICByZXR1cm4gc3RhdGVXaXRob3V0R2xvYmFsRmlsdGVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdsb2JhbEZpbHRlcjogbmV3RmlsdGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQzKGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgZmxhdFJvd3MgPSBpbnN0YW5jZS5mbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIHVzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLmZpbHRlclR5cGVzLFxuICAgICAgICBnbG9iYWxGaWx0ZXIgPSBpbnN0YW5jZS5nbG9iYWxGaWx0ZXIsXG4gICAgICAgIG1hbnVhbEdsb2JhbEZpbHRlciA9IGluc3RhbmNlLm1hbnVhbEdsb2JhbEZpbHRlcixcbiAgICAgICAgZ2xvYmFsRmlsdGVyVmFsdWUgPSBpbnN0YW5jZS5zdGF0ZS5nbG9iYWxGaWx0ZXIsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRHbCA9IGluc3RhbmNlLmF1dG9SZXNldEdsb2JhbEZpbHRlcixcbiAgICAgICAgYXV0b1Jlc2V0R2xvYmFsRmlsdGVyID0gX2luc3RhbmNlJGF1dG9SZXNldEdsID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldEdsLFxuICAgICAgICBkaXNhYmxlR2xvYmFsRmlsdGVyID0gaW5zdGFuY2UuZGlzYWJsZUdsb2JhbEZpbHRlcjtcbiAgICB2YXIgc2V0R2xvYmFsRmlsdGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGZpbHRlclZhbHVlKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0R2xvYmFsRmlsdGVyLFxuICAgICAgICBmaWx0ZXJWYWx1ZTogZmlsdGVyVmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pOyAvLyBUT0RPOiBDcmVhdGUgYSBmaWx0ZXIgY2FjaGUgZm9yIGluY3JlbWVudGFsIGhpZ2ggc3BlZWQgbXVsdGktZmlsdGVyaW5nXG4gICAgLy8gVGhpcyBnZXRzIHByZXR0eSBjb21wbGljYXRlZCBwcmV0dHkgZmFzdCwgc2luY2UgeW91IGhhdmUgdG8gbWFpbnRhaW4gYVxuICAgIC8vIGNhY2hlIGZvciBlYWNoIHJvdyBncm91cCAodG9wLWxldmVsIHJvd3MsIGFuZCBlYWNoIHJvdydzIHJlY3Vyc2l2ZSBzdWJyb3dzKVxuICAgIC8vIFRoaXMgd291bGQgbWFrZSBtdWx0aS1maWx0ZXJpbmcgYSBsb3QgZmFzdGVyIHRob3VnaC4gVG9vIGZhcj9cblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1hbnVhbEdsb2JhbEZpbHRlciB8fCB0eXBlb2YgZ2xvYmFsRmlsdGVyVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHZhciBmaWx0ZXJlZFJvd3NCeUlkID0ge307XG4gICAgICB2YXIgZmlsdGVyTWV0aG9kID0gZ2V0RmlsdGVyTWV0aG9kKGdsb2JhbEZpbHRlciwgdXNlckZpbHRlclR5cGVzIHx8IHt9LCBmaWx0ZXJUeXBlcyk7XG5cbiAgICAgIGlmICghZmlsdGVyTWV0aG9kKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgJ2dsb2JhbEZpbHRlcicgb3B0aW9uLlwiKTtcbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICB9XG5cbiAgICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHZhciBjb2x1bW5EaXNhYmxlR2xvYmFsRmlsdGVyID0gY29sdW1uLmRpc2FibGVHbG9iYWxGaWx0ZXI7XG4gICAgICAgIGNvbHVtbi5jYW5GaWx0ZXIgPSBnZXRGaXJzdERlZmluZWQoY29sdW1uRGlzYWJsZUdsb2JhbEZpbHRlciA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCBkaXNhYmxlR2xvYmFsRmlsdGVyID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmlsdGVyYWJsZUNvbHVtbnMgPSBhbGxDb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5jYW5GaWx0ZXIgPT09IHRydWU7XG4gICAgICB9KTsgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG5cbiAgICAgIHZhciBmaWx0ZXJSb3dzID0gZnVuY3Rpb24gZmlsdGVyUm93cyhmaWx0ZXJlZFJvd3MpIHtcbiAgICAgICAgZmlsdGVyZWRSb3dzID0gZmlsdGVyTWV0aG9kKGZpbHRlcmVkUm93cywgZmlsdGVyYWJsZUNvbHVtbnMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQ7XG4gICAgICAgIH0pLCBnbG9iYWxGaWx0ZXJWYWx1ZSk7XG4gICAgICAgIGZpbHRlcmVkUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICBmaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBmaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgcm93LnN1YlJvd3MgPSByb3cuc3ViUm93cyAmJiByb3cuc3ViUm93cy5sZW5ndGggPyBmaWx0ZXJSb3dzKHJvdy5zdWJSb3dzKSA6IHJvdy5zdWJSb3dzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkUm93cztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBbZmlsdGVyUm93cyhyb3dzKSwgZmlsdGVyZWRGbGF0Um93cywgZmlsdGVyZWRSb3dzQnlJZF07XG4gICAgfSwgW21hbnVhbEdsb2JhbEZpbHRlciwgZ2xvYmFsRmlsdGVyVmFsdWUsIGdsb2JhbEZpbHRlciwgdXNlckZpbHRlclR5cGVzLCBhbGxDb2x1bW5zLCByb3dzLCBmbGF0Um93cywgcm93c0J5SWQsIGRpc2FibGVHbG9iYWxGaWx0ZXJdKSxcbiAgICAgICAgZ2xvYmFsRmlsdGVyZWRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIGdsb2JhbEZpbHRlcmVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1sxXSxcbiAgICAgICAgZ2xvYmFsRmlsdGVyZWRSb3dzQnlJZCA9IF9SZWFjdCR1c2VNZW1vWzJdO1xuXG4gICAgdmFyIGdldEF1dG9SZXNldEdsb2JhbEZpbHRlciA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRHbG9iYWxGaWx0ZXIpO1xuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldEdsb2JhbEZpbHRlcigpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0R2xvYmFsRmlsdGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgbWFudWFsR2xvYmFsRmlsdGVyID8gbnVsbCA6IGRhdGFdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3M6IHJvd3MsXG4gICAgICBwcmVHbG9iYWxGaWx0ZXJlZEZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgIHByZUdsb2JhbEZpbHRlcmVkUm93c0J5SWQ6IHJvd3NCeUlkLFxuICAgICAgZ2xvYmFsRmlsdGVyZWRSb3dzOiBnbG9iYWxGaWx0ZXJlZFJvd3MsXG4gICAgICBnbG9iYWxGaWx0ZXJlZEZsYXRSb3dzOiBnbG9iYWxGaWx0ZXJlZEZsYXRSb3dzLFxuICAgICAgZ2xvYmFsRmlsdGVyZWRSb3dzQnlJZDogZ2xvYmFsRmlsdGVyZWRSb3dzQnlJZCxcbiAgICAgIHJvd3M6IGdsb2JhbEZpbHRlcmVkUm93cyxcbiAgICAgIGZsYXRSb3dzOiBnbG9iYWxGaWx0ZXJlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGdsb2JhbEZpbHRlcmVkUm93c0J5SWQsXG4gICAgICBzZXRHbG9iYWxGaWx0ZXI6IHNldEdsb2JhbEZpbHRlcixcbiAgICAgIGRpc2FibGVHbG9iYWxGaWx0ZXI6IGRpc2FibGVHbG9iYWxGaWx0ZXJcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN1bSh2YWx1ZXMsIGFnZ3JlZ2F0ZWRWYWx1ZXMpIHtcbiAgICAvLyBJdCdzIGZhc3RlciB0byBqdXN0IGFkZCB0aGUgYWdncmVnYXRpb25zIHRvZ2V0aGVyIGluc3RlYWQgb2ZcbiAgICAvLyBwcm9jZXNzIGxlYWYgbm9kZXMgaW5kaXZpZHVhbGx5XG4gICAgcmV0dXJuIGFnZ3JlZ2F0ZWRWYWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIG5leHQpIHtcbiAgICAgIHJldHVybiBzdW0gKyAodHlwZW9mIG5leHQgPT09ICdudW1iZXInID8gbmV4dCA6IDApO1xuICAgIH0sIDApO1xuICB9XG4gIGZ1bmN0aW9uIG1pbih2YWx1ZXMpIHtcbiAgICB2YXIgbWluID0gdmFsdWVzWzBdIHx8IDA7XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWluO1xuICB9XG4gIGZ1bmN0aW9uIG1heCh2YWx1ZXMpIHtcbiAgICB2YXIgbWF4ID0gdmFsdWVzWzBdIHx8IDA7XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIGZ1bmN0aW9uIG1pbk1heCh2YWx1ZXMpIHtcbiAgICB2YXIgbWluID0gdmFsdWVzWzBdIHx8IDA7XG4gICAgdmFyIG1heCA9IHZhbHVlc1swXSB8fCAwO1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCB2YWx1ZSk7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtaW4gKyBcIi4uXCIgKyBtYXg7XG4gIH1cbiAgZnVuY3Rpb24gYXZlcmFnZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gc3VtKG51bGwsIHZhbHVlcykgLyB2YWx1ZXMubGVuZ3RoO1xuICB9XG4gIGZ1bmN0aW9uIG1lZGlhbih2YWx1ZXMpIHtcbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcbiAgICB2YXIgbnVtcyA9IFtdLmNvbmNhdCh2YWx1ZXMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCAlIDIgIT09IDAgPyBudW1zW21pZF0gOiAobnVtc1ttaWQgLSAxXSArIG51bXNbbWlkXSkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIHVuaXF1ZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykudmFsdWVzKCkpO1xuICB9XG4gIGZ1bmN0aW9uIHVuaXF1ZUNvdW50KHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcykuc2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBjb3VudCh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBhZ2dyZWdhdGlvbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHN1bTogc3VtLFxuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4LFxuICAgIG1pbk1heDogbWluTWF4LFxuICAgIGF2ZXJhZ2U6IGF2ZXJhZ2UsXG4gICAgbWVkaWFuOiBtZWRpYW4sXG4gICAgdW5pcXVlOiB1bmlxdWUsXG4gICAgdW5pcXVlQ291bnQ6IHVuaXF1ZUNvdW50LFxuICAgIGNvdW50OiBjb3VudFxuICB9KTtcblxuICB2YXIgZW1wdHlBcnJheSA9IFtdO1xuICB2YXIgZW1wdHlPYmplY3QgPSB7fTsgLy8gQWN0aW9uc1xuXG4gIGFjdGlvbnMucmVzZXRHcm91cEJ5ID0gJ3Jlc2V0R3JvdXBCeSc7XG4gIGFjdGlvbnMuc2V0R3JvdXBCeSA9ICdzZXRHcm91cEJ5JztcbiAgYWN0aW9ucy50b2dnbGVHcm91cEJ5ID0gJ3RvZ2dsZUdyb3VwQnknO1xuICB2YXIgdXNlR3JvdXBCeSA9IGZ1bmN0aW9uIHVzZUdyb3VwQnkoaG9va3MpIHtcbiAgICBob29rcy5nZXRHcm91cEJ5VG9nZ2xlUHJvcHMgPSBbZGVmYXVsdEdldEdyb3VwQnlUb2dnbGVQcm9wc107XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkNCk7XG4gICAgaG9va3MudmlzaWJsZUNvbHVtbnNEZXBzLnB1c2goZnVuY3Rpb24gKGRlcHMsIF9yZWYpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2U7XG4gICAgICByZXR1cm4gW10uY29uY2F0KGRlcHMsIFtpbnN0YW5jZS5zdGF0ZS5ncm91cEJ5XSk7XG4gICAgfSk7XG4gICAgaG9va3MudmlzaWJsZUNvbHVtbnMucHVzaCh2aXNpYmxlQ29sdW1ucyk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ0KTtcbiAgICBob29rcy5wcmVwYXJlUm93LnB1c2gocHJlcGFyZVJvdyQxKTtcbiAgfTtcbiAgdXNlR3JvdXBCeS5wbHVnaW5OYW1lID0gJ3VzZUdyb3VwQnknO1xuXG4gIHZhciBkZWZhdWx0R2V0R3JvdXBCeVRvZ2dsZVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldEdyb3VwQnlUb2dnbGVQcm9wcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgaGVhZGVyID0gX3JlZjIuaGVhZGVyO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2xpY2s6IGhlYWRlci5jYW5Hcm91cEJ5ID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wZXJzaXN0KCk7XG4gICAgICAgIGhlYWRlci50b2dnbGVHcm91cEJ5KCk7XG4gICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiBoZWFkZXIuY2FuR3JvdXBCeSA/ICdwb2ludGVyJyA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIEdyb3VwQnknXG4gICAgfV07XG4gIH07IC8vIFJlZHVjZXJcblxuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkNChzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBncm91cEJ5OiBbXVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldEdyb3VwQnkpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZ3JvdXBCeTogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLmdyb3VwQnkgfHwgW11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRHcm91cEJ5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY3Rpb24udmFsdWU7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyb3VwQnk6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlR3JvdXBCeSkge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIHNldEdyb3VwQnkgPSBhY3Rpb24udmFsdWU7XG4gICAgICB2YXIgcmVzb2x2ZWRHcm91cEJ5ID0gdHlwZW9mIHNldEdyb3VwQnkgIT09ICd1bmRlZmluZWQnID8gc2V0R3JvdXBCeSA6ICFzdGF0ZS5ncm91cEJ5LmluY2x1ZGVzKGNvbHVtbklkKTtcblxuICAgICAgaWYgKHJlc29sdmVkR3JvdXBCeSkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZ3JvdXBCeTogW10uY29uY2F0KHN0YXRlLmdyb3VwQnksIFtjb2x1bW5JZF0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyb3VwQnk6IHN0YXRlLmdyb3VwQnkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQgIT09IGNvbHVtbklkO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmlzaWJsZUNvbHVtbnMoY29sdW1ucywgX3JlZjMpIHtcbiAgICB2YXIgZ3JvdXBCeSA9IF9yZWYzLmluc3RhbmNlLnN0YXRlLmdyb3VwQnk7XG4gICAgLy8gU29ydCBncm91cGVkIGNvbHVtbnMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb2x1bW4gbGlzdFxuICAgIC8vIGJlZm9yZSB0aGUgaGVhZGVycyBhcmUgYnVpbHRcbiAgICB2YXIgZ3JvdXBCeUNvbHVtbnMgPSBncm91cEJ5Lm1hcChmdW5jdGlvbiAoZykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMuZmluZChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgIHJldHVybiBjb2wuaWQgPT09IGc7XG4gICAgICB9KTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgdmFyIG5vbkdyb3VwQnlDb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGNvbCkge1xuICAgICAgcmV0dXJuICFncm91cEJ5LmluY2x1ZGVzKGNvbC5pZCk7XG4gICAgfSk7XG4gICAgY29sdW1ucyA9IFtdLmNvbmNhdChncm91cEJ5Q29sdW1ucywgbm9uR3JvdXBCeUNvbHVtbnMpO1xuICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4uaXNHcm91cGVkID0gZ3JvdXBCeS5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgICAgY29sdW1uLmdyb3VwZWRJbmRleCA9IGdyb3VwQnkuaW5kZXhPZihjb2x1bW4uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW5zO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRVc2VyQWdncmVnYXRpb25zID0ge307XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkNChpbnN0YW5jZSkge1xuICAgIHZhciBkYXRhID0gaW5zdGFuY2UuZGF0YSxcbiAgICAgICAgcm93cyA9IGluc3RhbmNlLnJvd3MsXG4gICAgICAgIGZsYXRSb3dzID0gaW5zdGFuY2UuZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICBmbGF0SGVhZGVycyA9IGluc3RhbmNlLmZsYXRIZWFkZXJzLFxuICAgICAgICBfaW5zdGFuY2UkZ3JvdXBCeUZuID0gaW5zdGFuY2UuZ3JvdXBCeUZuLFxuICAgICAgICBncm91cEJ5Rm4gPSBfaW5zdGFuY2UkZ3JvdXBCeUZuID09PSB2b2lkIDAgPyBkZWZhdWx0R3JvdXBCeUZuIDogX2luc3RhbmNlJGdyb3VwQnlGbixcbiAgICAgICAgbWFudWFsR3JvdXBCeSA9IGluc3RhbmNlLm1hbnVhbEdyb3VwQnksXG4gICAgICAgIF9pbnN0YW5jZSRhZ2dyZWdhdGlvbiA9IGluc3RhbmNlLmFnZ3JlZ2F0aW9ucyxcbiAgICAgICAgdXNlckFnZ3JlZ2F0aW9ucyA9IF9pbnN0YW5jZSRhZ2dyZWdhdGlvbiA9PT0gdm9pZCAwID8gZGVmYXVsdFVzZXJBZ2dyZWdhdGlvbnMgOiBfaW5zdGFuY2UkYWdncmVnYXRpb24sXG4gICAgICAgIHBsdWdpbnMgPSBpbnN0YW5jZS5wbHVnaW5zLFxuICAgICAgICBncm91cEJ5ID0gaW5zdGFuY2Uuc3RhdGUuZ3JvdXBCeSxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldEdyID0gaW5zdGFuY2UuYXV0b1Jlc2V0R3JvdXBCeSxcbiAgICAgICAgYXV0b1Jlc2V0R3JvdXBCeSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRHciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRHcixcbiAgICAgICAgZGlzYWJsZUdyb3VwQnkgPSBpbnN0YW5jZS5kaXNhYmxlR3JvdXBCeSxcbiAgICAgICAgZGVmYXVsdENhbkdyb3VwQnkgPSBpbnN0YW5jZS5kZWZhdWx0Q2FuR3JvdXBCeSxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcztcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZUNvbHVtbk9yZGVyJywgJ3VzZUZpbHRlcnMnXSwgJ3VzZUdyb3VwQnknKTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICB2YXIgYWNjZXNzb3IgPSBjb2x1bW4uYWNjZXNzb3IsXG4gICAgICAgICAgZGVmYXVsdENvbHVtbkdyb3VwQnkgPSBjb2x1bW4uZGVmYXVsdEdyb3VwQnksXG4gICAgICAgICAgY29sdW1uRGlzYWJsZUdyb3VwQnkgPSBjb2x1bW4uZGlzYWJsZUdyb3VwQnk7XG4gICAgICBjb2x1bW4uY2FuR3JvdXBCeSA9IGFjY2Vzc29yID8gZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbi5jYW5Hcm91cEJ5LCBjb2x1bW5EaXNhYmxlR3JvdXBCeSA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCBkaXNhYmxlR3JvdXBCeSA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCB0cnVlKSA6IGdldEZpcnN0RGVmaW5lZChjb2x1bW4uY2FuR3JvdXBCeSwgZGVmYXVsdENvbHVtbkdyb3VwQnksIGRlZmF1bHRDYW5Hcm91cEJ5LCBmYWxzZSk7XG5cbiAgICAgIGlmIChjb2x1bW4uY2FuR3JvdXBCeSkge1xuICAgICAgICBjb2x1bW4udG9nZ2xlR3JvdXBCeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UudG9nZ2xlR3JvdXBCeShjb2x1bW4uaWQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb2x1bW4uQWdncmVnYXRlZCA9IGNvbHVtbi5BZ2dyZWdhdGVkIHx8IGNvbHVtbi5DZWxsO1xuICAgIH0pO1xuICAgIHZhciB0b2dnbGVHcm91cEJ5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbklkLCB2YWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUdyb3VwQnksXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgc2V0R3JvdXBCeSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldEdyb3VwQnksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgZmxhdEhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICBoZWFkZXIuZ2V0R3JvdXBCeVRvZ2dsZVByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRHcm91cEJ5VG9nZ2xlUHJvcHMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgIGhlYWRlcjogaGVhZGVyXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1hbnVhbEdyb3VwQnkgfHwgIWdyb3VwQnkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkLCBlbXB0eUFycmF5LCBlbXB0eU9iamVjdCwgZmxhdFJvd3MsIHJvd3NCeUlkXTtcbiAgICAgIH0gLy8gRW5zdXJlIHRoYXQgdGhlIGxpc3Qgb2YgZmlsdGVyZWQgY29sdW1ucyBleGlzdFxuXG5cbiAgICAgIHZhciBleGlzdGluZ0dyb3VwQnkgPSBncm91cEJ5LmZpbHRlcihmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgICByZXR1cm4gY29sLmlkID09PSBnO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBGaW5kIHRoZSBjb2x1bW5zIHRoYXQgY2FuIG9yIGFyZSBhZ2dyZWdhdGluZ1xuICAgICAgLy8gVXNlcyBlYWNoIGNvbHVtbiB0byBhZ2dyZWdhdGUgcm93cyBpbnRvIGEgc2luZ2xlIHZhbHVlXG5cbiAgICAgIHZhciBhZ2dyZWdhdGVSb3dzVG9WYWx1ZXMgPSBmdW5jdGlvbiBhZ2dyZWdhdGVSb3dzVG9WYWx1ZXMobGVhZlJvd3MsIGdyb3VwZWRSb3dzLCBkZXB0aCkge1xuICAgICAgICB2YXIgdmFsdWVzID0ge307XG4gICAgICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgYWdncmVnYXRlIGNvbHVtbnMgdGhhdCBhcmUgaW4gdGhlIGdyb3VwQnlcbiAgICAgICAgICBpZiAoZXhpc3RpbmdHcm91cEJ5LmluY2x1ZGVzKGNvbHVtbi5pZCkpIHtcbiAgICAgICAgICAgIHZhbHVlc1tjb2x1bW4uaWRdID0gZ3JvdXBlZFJvd3NbMF0gPyBncm91cGVkUm93c1swXS52YWx1ZXNbY29sdW1uLmlkXSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBBZ2dyZWdhdGUgdGhlIHZhbHVlc1xuXG5cbiAgICAgICAgICB2YXIgYWdncmVnYXRlRm4gPSB0eXBlb2YgY29sdW1uLmFnZ3JlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbHVtbi5hZ2dyZWdhdGUgOiB1c2VyQWdncmVnYXRpb25zW2NvbHVtbi5hZ2dyZWdhdGVdIHx8IGFnZ3JlZ2F0aW9uc1tjb2x1bW4uYWdncmVnYXRlXTtcblxuICAgICAgICAgIGlmIChhZ2dyZWdhdGVGbikge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBjb2x1bW5WYWx1ZXMgdG8gYWdncmVnYXRlXG4gICAgICAgICAgICB2YXIgZ3JvdXBlZFZhbHVlcyA9IGdyb3VwZWRSb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3cudmFsdWVzW2NvbHVtbi5pZF07XG4gICAgICAgICAgICB9KTsgLy8gR2V0IHRoZSBjb2x1bW5WYWx1ZXMgdG8gYWdncmVnYXRlXG5cbiAgICAgICAgICAgIHZhciBsZWFmVmFsdWVzID0gbGVhZlJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbHVtblZhbHVlID0gcm93LnZhbHVlc1tjb2x1bW4uaWRdO1xuXG4gICAgICAgICAgICAgIGlmICghZGVwdGggJiYgY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFnZ3JlZ2F0ZVZhbHVlRm4gPSB0eXBlb2YgY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlID09PSAnZnVuY3Rpb24nID8gY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlIDogdXNlckFnZ3JlZ2F0aW9uc1tjb2x1bW4uYWdncmVnYXRlVmFsdWVdIHx8IGFnZ3JlZ2F0aW9uc1tjb2x1bW4uYWdncmVnYXRlVmFsdWVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhZ2dyZWdhdGVWYWx1ZUZuKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oe1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBUYWJsZTogSW52YWxpZCBjb2x1bW4uYWdncmVnYXRlVmFsdWUgb3B0aW9uIGZvciBjb2x1bW4gbGlzdGVkIGFib3ZlXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbHVtblZhbHVlID0gYWdncmVnYXRlVmFsdWVGbihjb2x1bW5WYWx1ZSwgcm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtblZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZXNbY29sdW1uLmlkXSA9IGFnZ3JlZ2F0ZUZuKGxlYWZWYWx1ZXMsIGdyb3VwZWRWYWx1ZXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKHtcbiAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QgVGFibGU6IEludmFsaWQgY29sdW1uLmFnZ3JlZ2F0ZSBvcHRpb24gZm9yIGNvbHVtbiBsaXN0ZWQgYWJvdmVcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlc1tjb2x1bW4uaWRdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfTtcblxuICAgICAgdmFyIGdyb3VwZWRGbGF0Um93cyA9IFtdO1xuICAgICAgdmFyIGdyb3VwZWRSb3dzQnlJZCA9IHt9O1xuICAgICAgdmFyIG9ubHlHcm91cGVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHZhciBvbmx5R3JvdXBlZFJvd3NCeUlkID0ge307XG4gICAgICB2YXIgbm9uR3JvdXBlZEZsYXRSb3dzID0gW107XG4gICAgICB2YXIgbm9uR3JvdXBlZFJvd3NCeUlkID0ge307IC8vIFJlY3Vyc2l2ZWx5IGdyb3VwIHRoZSBkYXRhXG5cbiAgICAgIHZhciBncm91cFVwUmVjdXJzaXZlbHkgPSBmdW5jdGlvbiBncm91cFVwUmVjdXJzaXZlbHkocm93cywgZGVwdGgsIHBhcmVudElkKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVwdGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCBsZXZlbCwganVzdCByZXR1cm4gdGhlIHJvd3NcbiAgICAgICAgaWYgKGRlcHRoID09PSBleGlzdGluZ0dyb3VwQnkubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcm93LCB7XG4gICAgICAgICAgICAgIGRlcHRoOiBkZXB0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sdW1uSWQgPSBleGlzdGluZ0dyb3VwQnlbZGVwdGhdOyAvLyBHcm91cCB0aGUgcm93cyB0b2dldGhlciBmb3IgdGhpcyBsZXZlbFxuXG4gICAgICAgIHZhciByb3dHcm91cHNNYXAgPSBncm91cEJ5Rm4ocm93cywgY29sdW1uSWQpOyAvLyBQZWZvcm0gYWdncmVnYXRpb25zIGZvciBlYWNoIGdyb3VwXG5cbiAgICAgICAgdmFyIGFnZ3JlZ2F0ZWRHcm91cGVkUm93cyA9IE9iamVjdC5lbnRyaWVzKHJvd0dyb3Vwc01hcCkubWFwKGZ1bmN0aW9uIChfcmVmNCwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgZ3JvdXBCeVZhbCA9IF9yZWY0WzBdLFxuICAgICAgICAgICAgICBncm91cGVkUm93cyA9IF9yZWY0WzFdO1xuICAgICAgICAgIHZhciBpZCA9IGNvbHVtbklkICsgXCI6XCIgKyBncm91cEJ5VmFsO1xuICAgICAgICAgIGlkID0gcGFyZW50SWQgPyBwYXJlbnRJZCArIFwiPlwiICsgaWQgOiBpZDsgLy8gRmlyc3QsIFJlY3Vyc2UgdG8gZ3JvdXAgc3ViIHJvd3MgYmVmb3JlIGFnZ3JlZ2F0aW9uXG5cbiAgICAgICAgICB2YXIgc3ViUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShncm91cGVkUm93cywgZGVwdGggKyAxLCBpZCk7IC8vIEZsYXR0ZW4gdGhlIGxlYWYgcm93cyBvZiB0aGUgcm93cyBpbiB0aGlzIGdyb3VwXG5cbiAgICAgICAgICB2YXIgbGVhZlJvd3MgPSBkZXB0aCA/IGZsYXR0ZW5CeShncm91cGVkUm93cywgJ2xlYWZSb3dzJykgOiBncm91cGVkUm93cztcbiAgICAgICAgICB2YXIgdmFsdWVzID0gYWdncmVnYXRlUm93c1RvVmFsdWVzKGxlYWZSb3dzLCBncm91cGVkUm93cywgZGVwdGgpO1xuICAgICAgICAgIHZhciByb3cgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpc0dyb3VwZWQ6IHRydWUsXG4gICAgICAgICAgICBncm91cEJ5SUQ6IGNvbHVtbklkLFxuICAgICAgICAgICAgZ3JvdXBCeVZhbDogZ3JvdXBCeVZhbCxcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICAgICAgc3ViUm93czogc3ViUm93cyxcbiAgICAgICAgICAgIGxlYWZSb3dzOiBsZWFmUm93cyxcbiAgICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICAgICAgc3ViUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJSb3cpIHtcbiAgICAgICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgICBncm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcblxuICAgICAgICAgICAgaWYgKHN1YlJvdy5pc0dyb3VwZWQpIHtcbiAgICAgICAgICAgICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgICAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWdncmVnYXRlZEdyb3VwZWRSb3dzO1xuICAgICAgfTtcblxuICAgICAgdmFyIGdyb3VwZWRSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvd3MpO1xuICAgICAgZ3JvdXBlZFJvd3MuZm9yRWFjaChmdW5jdGlvbiAoc3ViUm93KSB7XG4gICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuXG4gICAgICAgIGlmIChzdWJSb3cuaXNHcm91cGVkKSB7XG4gICAgICAgICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgb25seUdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgbm9uR3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBBc3NpZ24gdGhlIG5ldyBkYXRhXG5cbiAgICAgIHJldHVybiBbZ3JvdXBlZFJvd3MsIGdyb3VwZWRGbGF0Um93cywgZ3JvdXBlZFJvd3NCeUlkLCBvbmx5R3JvdXBlZEZsYXRSb3dzLCBvbmx5R3JvdXBlZFJvd3NCeUlkLCBub25Hcm91cGVkRmxhdFJvd3MsIG5vbkdyb3VwZWRSb3dzQnlJZF07XG4gICAgfSwgW21hbnVhbEdyb3VwQnksIGdyb3VwQnksIHJvd3MsIGZsYXRSb3dzLCByb3dzQnlJZCwgYWxsQ29sdW1ucywgdXNlckFnZ3JlZ2F0aW9ucywgZ3JvdXBCeUZuXSksXG4gICAgICAgIGdyb3VwZWRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIGdyb3VwZWRGbGF0Um93cyA9IF9SZWFjdCR1c2VNZW1vWzFdLFxuICAgICAgICBncm91cGVkUm93c0J5SWQgPSBfUmVhY3QkdXNlTWVtb1syXSxcbiAgICAgICAgb25seUdyb3VwZWRGbGF0Um93cyA9IF9SZWFjdCR1c2VNZW1vWzNdLFxuICAgICAgICBvbmx5R3JvdXBlZFJvd3NCeUlkID0gX1JlYWN0JHVzZU1lbW9bNF0sXG4gICAgICAgIG5vbkdyb3VwZWRGbGF0Um93cyA9IF9SZWFjdCR1c2VNZW1vWzVdLFxuICAgICAgICBub25Hcm91cGVkUm93c0J5SWQgPSBfUmVhY3QkdXNlTWVtb1s2XTtcblxuICAgIHZhciBnZXRBdXRvUmVzZXRHcm91cEJ5ID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldEdyb3VwQnkpO1xuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldEdyb3VwQnkoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldEdyb3VwQnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBtYW51YWxHcm91cEJ5ID8gbnVsbCA6IGRhdGFdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBwcmVHcm91cGVkUm93czogcm93cyxcbiAgICAgIHByZUdyb3VwZWRGbGF0Um93OiBmbGF0Um93cyxcbiAgICAgIHByZUdyb3VwZWRSb3dzQnlJZDogcm93c0J5SWQsXG4gICAgICBncm91cGVkUm93czogZ3JvdXBlZFJvd3MsXG4gICAgICBncm91cGVkRmxhdFJvd3M6IGdyb3VwZWRGbGF0Um93cyxcbiAgICAgIGdyb3VwZWRSb3dzQnlJZDogZ3JvdXBlZFJvd3NCeUlkLFxuICAgICAgb25seUdyb3VwZWRGbGF0Um93czogb25seUdyb3VwZWRGbGF0Um93cyxcbiAgICAgIG9ubHlHcm91cGVkUm93c0J5SWQ6IG9ubHlHcm91cGVkUm93c0J5SWQsXG4gICAgICBub25Hcm91cGVkRmxhdFJvd3M6IG5vbkdyb3VwZWRGbGF0Um93cyxcbiAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZDogbm9uR3JvdXBlZFJvd3NCeUlkLFxuICAgICAgcm93czogZ3JvdXBlZFJvd3MsXG4gICAgICBmbGF0Um93czogZ3JvdXBlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGdyb3VwZWRSb3dzQnlJZCxcbiAgICAgIHRvZ2dsZUdyb3VwQnk6IHRvZ2dsZUdyb3VwQnksXG4gICAgICBzZXRHcm91cEJ5OiBzZXRHcm91cEJ5XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93JDEocm93KSB7XG4gICAgcm93LmFsbENlbGxzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3M7XG5cbiAgICAgIC8vIEdyb3VwZWQgY2VsbHMgYXJlIGluIHRoZSBncm91cEJ5IGFuZCB0aGUgcGl2b3QgY2VsbCBmb3IgdGhlIHJvd1xuICAgICAgY2VsbC5pc0dyb3VwZWQgPSBjZWxsLmNvbHVtbi5pc0dyb3VwZWQgJiYgY2VsbC5jb2x1bW4uaWQgPT09IHJvdy5ncm91cEJ5SUQ7IC8vIFBsYWNlaG9sZGVyIGNlbGxzIGFyZSBhbnkgY29sdW1ucyBpbiB0aGUgZ3JvdXBCeSB0aGF0IGFyZSBub3QgZ3JvdXBlZFxuXG4gICAgICBjZWxsLmlzUGxhY2Vob2xkZXIgPSAhY2VsbC5pc0dyb3VwZWQgJiYgY2VsbC5jb2x1bW4uaXNHcm91cGVkOyAvLyBBZ2dyZWdhdGVkIGNlbGxzIGFyZSBub3QgZ3JvdXBlZCwgbm90IHJlcGVhdGVkLCBidXQgc3RpbGwgaGF2ZSBzdWJSb3dzXG5cbiAgICAgIGNlbGwuaXNBZ2dyZWdhdGVkID0gIWNlbGwuaXNHcm91cGVkICYmICFjZWxsLmlzUGxhY2Vob2xkZXIgJiYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEdyb3VwQnlGbihyb3dzLCBjb2x1bW5JZCkge1xuICAgIHJldHVybiByb3dzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcm93LCBpKSB7XG4gICAgICAvLyBUT0RPOiBNaWdodCB3YW50IHRvIGltcGxlbWVudCBhIGtleSBzZXJpYWxpemVyIGhlcmUgc29cbiAgICAgIC8vIGlycmVndWxhciBjb2x1bW4gdmFsdWVzIGNhbiBzdGlsbCBiZSBncm91cGVkIGlmIG5lZWRlZD9cbiAgICAgIHZhciByZXNLZXkgPSBcIlwiICsgcm93LnZhbHVlc1tjb2x1bW5JZF07XG4gICAgICBwcmV2W3Jlc0tleV0gPSBBcnJheS5pc0FycmF5KHByZXZbcmVzS2V5XSkgPyBwcmV2W3Jlc0tleV0gOiBbXTtcbiAgICAgIHByZXZbcmVzS2V5XS5wdXNoKHJvdyk7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9LCB7fSk7XG4gIH1cblxuICB2YXIgcmVTcGxpdEFscGhhTnVtZXJpYyA9IC8oWzAtOV0rKS9nbTsgLy8gTWl4ZWQgc29ydGluZyBpcyBzbG93LCBidXQgdmVyeSBpbmNsdXNpdmUgb2YgbWFueSBlZGdlIGNhc2VzLlxuICAvLyBJdCBoYW5kbGVzIG51bWJlcnMsIG1peGVkIGFscGhhbnVtZXJpYyBjb21iaW5hdGlvbnMsIGFuZCBldmVuXG4gIC8vIG51bGwsIHVuZGVmaW5lZCwgYW5kIEluZmluaXR5XG5cbiAgdmFyIGFscGhhbnVtZXJpYyA9IGZ1bmN0aW9uIGFscGhhbnVtZXJpYyhyb3dBLCByb3dCLCBjb2x1bW5JZCkge1xuICAgIHZhciBfZ2V0Um93VmFsdWVzQnlDb2x1bW4gPSBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvd0EsIHJvd0IsIGNvbHVtbklkKSxcbiAgICAgICAgYSA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtblswXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtblsxXTsgLy8gRm9yY2UgdG8gc3RyaW5ncyAob3IgXCJcIiBmb3IgdW5zdXBwb3J0ZWQgdHlwZXMpXG5cblxuICAgIGEgPSB0b1N0cmluZyhhKTtcbiAgICBiID0gdG9TdHJpbmcoYik7IC8vIFNwbGl0IG9uIG51bWJlciBncm91cHMsIGJ1dCBrZWVwIHRoZSBkZWxpbWl0ZXJcbiAgICAvLyBUaGVuIHJlbW92ZSBmYWxzZXkgc3BsaXQgdmFsdWVzXG5cbiAgICBhID0gYS5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgYiA9IGIuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pOyAvLyBXaGlsZVxuXG4gICAgd2hpbGUgKGEubGVuZ3RoICYmIGIubGVuZ3RoKSB7XG4gICAgICB2YXIgYWEgPSBhLnNoaWZ0KCk7XG4gICAgICB2YXIgYmIgPSBiLnNoaWZ0KCk7XG4gICAgICB2YXIgYW4gPSBwYXJzZUludChhYSwgMTApO1xuICAgICAgdmFyIGJuID0gcGFyc2VJbnQoYmIsIDEwKTtcbiAgICAgIHZhciBjb21ibyA9IFthbiwgYm5dLnNvcnQoKTsgLy8gQm90aCBhcmUgc3RyaW5nXG5cbiAgICAgIGlmIChpc05hTihjb21ib1swXSkpIHtcbiAgICAgICAgaWYgKGFhID4gYmIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYiA+IGFhKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIE9uZSBpcyBhIHN0cmluZywgb25lIGlzIGEgbnVtYmVyXG5cblxuICAgICAgaWYgKGlzTmFOKGNvbWJvWzFdKSkge1xuICAgICAgICByZXR1cm4gaXNOYU4oYW4pID8gLTEgOiAxO1xuICAgICAgfSAvLyBCb3RoIGFyZSBudW1iZXJzXG5cblxuICAgICAgaWYgKGFuID4gYm4pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChibiA+IGFuKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgfTtcbiAgZnVuY3Rpb24gZGF0ZXRpbWUocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uMiA9IGdldFJvd1ZhbHVlc0J5Q29sdW1uSUQocm93QSwgcm93QiwgY29sdW1uSWQpLFxuICAgICAgICBhID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uMlswXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjJbMV07XG5cbiAgICBhID0gYS5nZXRUaW1lKCk7XG4gICAgYiA9IGIuZ2V0VGltZSgpO1xuICAgIHJldHVybiBjb21wYXJlQmFzaWMoYSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gYmFzaWMocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uMyA9IGdldFJvd1ZhbHVlc0J5Q29sdW1uSUQocm93QSwgcm93QiwgY29sdW1uSWQpLFxuICAgICAgICBhID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uM1swXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjNbMV07XG5cbiAgICByZXR1cm4gY29tcGFyZUJhc2ljKGEsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZyhyb3dBLCByb3dCLCBjb2x1bW5JZCkge1xuICAgIHZhciBfZ2V0Um93VmFsdWVzQnlDb2x1bW40ID0gZ2V0Um93VmFsdWVzQnlDb2x1bW5JRChyb3dBLCByb3dCLCBjb2x1bW5JZCksXG4gICAgICAgIGEgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW40WzBdLFxuICAgICAgICBiID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uNFsxXTtcblxuICAgIGEgPSBhLnNwbGl0KCcnKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgYiA9IGIuc3BsaXQoJycpLmZpbHRlcihCb29sZWFuKTtcblxuICAgIHdoaWxlIChhLmxlbmd0aCAmJiBiLmxlbmd0aCkge1xuICAgICAgdmFyIGFhID0gYS5zaGlmdCgpO1xuICAgICAgdmFyIGJiID0gYi5zaGlmdCgpO1xuICAgICAgdmFyIGFsb3dlciA9IGFhLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgYmxvd2VyID0gYmIudG9Mb3dlckNhc2UoKTsgLy8gQ2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uIHVudGlsIGNoYXJhY3RlcnMgbWF0Y2hcblxuICAgICAgaWYgKGFsb3dlciA+IGJsb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb3dlciA+IGFsb3dlcikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IC8vIElmIGxvd2VyY2FzZSBjaGFyYWN0ZXJzIGFyZSBpZGVudGljYWxcblxuXG4gICAgICBpZiAoYWEgPiBiYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJiID4gYWEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBudW1iZXIocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uNSA9IGdldFJvd1ZhbHVlc0J5Q29sdW1uSUQocm93QSwgcm93QiwgY29sdW1uSWQpLFxuICAgICAgICBhID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uNVswXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjVbMV07XG5cbiAgICB2YXIgcmVwbGFjZU5vbk51bWVyaWMgPSAvW14wLTkuXS9naTtcbiAgICBhID0gTnVtYmVyKFN0cmluZyhhKS5yZXBsYWNlKHJlcGxhY2VOb25OdW1lcmljLCAnJykpO1xuICAgIGIgPSBOdW1iZXIoU3RyaW5nKGIpLnJlcGxhY2UocmVwbGFjZU5vbk51bWVyaWMsICcnKSk7XG4gICAgcmV0dXJuIGNvbXBhcmVCYXNpYyhhLCBiKTtcbiAgfSAvLyBVdGlsc1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVCYXNpYyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvdzEsIHJvdzIsIGNvbHVtbklkKSB7XG4gICAgcmV0dXJuIFtyb3cxLnZhbHVlc1tjb2x1bW5JZF0sIHJvdzIudmFsdWVzW2NvbHVtbklkXV07XG4gIH1cblxuICBmdW5jdGlvbiB0b1N0cmluZyhhKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKGEpIHx8IGEgPT09IEluZmluaXR5IHx8IGEgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTdHJpbmcoYSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIHNvcnRUeXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYWxwaGFudW1lcmljOiBhbHBoYW51bWVyaWMsXG4gICAgZGF0ZXRpbWU6IGRhdGV0aW1lLFxuICAgIGJhc2ljOiBiYXNpYyxcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBudW1iZXI6IG51bWJlclxuICB9KTtcblxuICBhY3Rpb25zLnJlc2V0U29ydEJ5ID0gJ3Jlc2V0U29ydEJ5JztcbiAgYWN0aW9ucy5zZXRTb3J0QnkgPSAnc2V0U29ydEJ5JztcbiAgYWN0aW9ucy50b2dnbGVTb3J0QnkgPSAndG9nZ2xlU29ydEJ5JztcbiAgYWN0aW9ucy5jbGVhclNvcnRCeSA9ICdjbGVhclNvcnRCeSc7XG4gIGRlZmF1bHRDb2x1bW4uc29ydFR5cGUgPSAnYWxwaGFudW1lcmljJztcbiAgZGVmYXVsdENvbHVtbi5zb3J0RGVzY0ZpcnN0ID0gZmFsc2U7XG4gIHZhciB1c2VTb3J0QnkgPSBmdW5jdGlvbiB1c2VTb3J0QnkoaG9va3MpIHtcbiAgICBob29rcy5nZXRTb3J0QnlUb2dnbGVQcm9wcyA9IFtkZWZhdWx0R2V0U29ydEJ5VG9nZ2xlUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDUpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkNSk7XG4gIH07XG4gIHVzZVNvcnRCeS5wbHVnaW5OYW1lID0gJ3VzZVNvcnRCeSc7XG5cbiAgdmFyIGRlZmF1bHRHZXRTb3J0QnlUb2dnbGVQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRTb3J0QnlUb2dnbGVQcm9wcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICAgIGNvbHVtbiA9IF9yZWYuY29sdW1uO1xuICAgIHZhciBfaW5zdGFuY2UkaXNNdWx0aVNvcnQgPSBpbnN0YW5jZS5pc011bHRpU29ydEV2ZW50LFxuICAgICAgICBpc011bHRpU29ydEV2ZW50ID0gX2luc3RhbmNlJGlzTXVsdGlTb3J0ID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGUuc2hpZnRLZXk7XG4gICAgfSA6IF9pbnN0YW5jZSRpc011bHRpU29ydDtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNsaWNrOiBjb2x1bW4uY2FuU29ydCA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydEJ5KHVuZGVmaW5lZCwgIWluc3RhbmNlLmRpc2FibGVNdWx0aVNvcnQgJiYgaXNNdWx0aVNvcnRFdmVudChlKSk7XG4gICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiBjb2x1bW4uY2FuU29ydCA/ICdwb2ludGVyJyA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiBjb2x1bW4uY2FuU29ydCA/ICdUb2dnbGUgU29ydEJ5JyA6IHVuZGVmaW5lZFxuICAgIH1dO1xuICB9OyAvLyBSZWR1Y2VyXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDUoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgc29ydEJ5OiBbXVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFNvcnRCeSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzb3J0Qnk6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5zb3J0QnkgfHwgW11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jbGVhclNvcnRCeSkge1xuICAgICAgdmFyIHNvcnRCeSA9IHN0YXRlLnNvcnRCeTtcbiAgICAgIHZhciBuZXdTb3J0QnkgPSBzb3J0QnkuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkICE9PSBhY3Rpb24uY29sdW1uSWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc29ydEJ5OiBuZXdTb3J0QnlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRTb3J0QnkpIHtcbiAgICAgIHZhciBfc29ydEJ5ID0gYWN0aW9uLnNvcnRCeTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc29ydEJ5OiBfc29ydEJ5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlU29ydEJ5KSB7XG4gICAgICB2YXIgY29sdW1uSWQgPSBhY3Rpb24uY29sdW1uSWQsXG4gICAgICAgICAgZGVzYyA9IGFjdGlvbi5kZXNjLFxuICAgICAgICAgIG11bHRpID0gYWN0aW9uLm11bHRpO1xuICAgICAgdmFyIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICAgIGRpc2FibGVNdWx0aVNvcnQgPSBpbnN0YW5jZS5kaXNhYmxlTXVsdGlTb3J0LFxuICAgICAgICAgIGRpc2FibGVTb3J0UmVtb3ZlID0gaW5zdGFuY2UuZGlzYWJsZVNvcnRSZW1vdmUsXG4gICAgICAgICAgZGlzYWJsZU11bHRpUmVtb3ZlID0gaW5zdGFuY2UuZGlzYWJsZU11bHRpUmVtb3ZlLFxuICAgICAgICAgIF9pbnN0YW5jZSRtYXhNdWx0aVNvciA9IGluc3RhbmNlLm1heE11bHRpU29ydENvbENvdW50LFxuICAgICAgICAgIG1heE11bHRpU29ydENvbENvdW50ID0gX2luc3RhbmNlJG1heE11bHRpU29yID09PSB2b2lkIDAgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IF9pbnN0YW5jZSRtYXhNdWx0aVNvcjtcbiAgICAgIHZhciBfc29ydEJ5MiA9IHN0YXRlLnNvcnRCeTsgLy8gRmluZCB0aGUgY29sdW1uIGZvciB0aGlzIGNvbHVtbklkXG5cbiAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbklkO1xuICAgICAgfSk7XG4gICAgICB2YXIgc29ydERlc2NGaXJzdCA9IGNvbHVtbi5zb3J0RGVzY0ZpcnN0OyAvLyBGaW5kIGFueSBleGlzdGluZyBzb3J0QnkgZm9yIHRoaXMgY29sdW1uXG5cbiAgICAgIHZhciBleGlzdGluZ1NvcnRCeSA9IF9zb3J0QnkyLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbklkO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBleGlzdGluZ0luZGV4ID0gX3NvcnRCeTIuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgaGFzRGVzY0RlZmluZWQgPSB0eXBlb2YgZGVzYyAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVzYyAhPT0gbnVsbDtcbiAgICAgIHZhciBfbmV3U29ydEJ5ID0gW107IC8vIFdoYXQgc2hvdWxkIHdlIGRvIHdpdGggdGhpcyBzb3J0IGFjdGlvbj9cblxuICAgICAgdmFyIHNvcnRBY3Rpb247XG5cbiAgICAgIGlmICghZGlzYWJsZU11bHRpU29ydCAmJiBtdWx0aSkge1xuICAgICAgICBpZiAoZXhpc3RpbmdTb3J0QnkpIHtcbiAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc29ydEFjdGlvbiA9ICdhZGQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgbW9kZVxuICAgICAgICBpZiAoZXhpc3RpbmdJbmRleCAhPT0gX3NvcnRCeTIubGVuZ3RoIC0gMSB8fCBfc29ydEJ5Mi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU29ydEJ5KSB7XG4gICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVwbGFjZSc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSGFuZGxlIHRvZ2dsZSBzdGF0ZXMgdGhhdCB3aWxsIHJlbW92ZSB0aGUgc29ydEJ5XG5cblxuICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnICYmIC8vIE11c3QgYmUgdG9nZ2xpbmdcbiAgICAgICFkaXNhYmxlU29ydFJlbW92ZSAmJiAvLyBJZiBkaXNhYmxlU29ydFJlbW92ZSwgZGlzYWJsZSBpbiBnZW5lcmFsXG4gICAgICAhaGFzRGVzY0RlZmluZWQgJiYgKCAvLyBNdXN0IG5vdCBiZSBzZXR0aW5nIGRlc2NcbiAgICAgIG11bHRpID8gIWRpc2FibGVNdWx0aVJlbW92ZSA6IHRydWUpICYmICggLy8gSWYgbXVsdGksIGRvbid0IGFsbG93IGlmIGRpc2FibGVNdWx0aVJlbW92ZVxuICAgICAgZXhpc3RpbmdTb3J0QnkgJiYgLy8gRmluYWxseSwgZGV0ZWN0IGlmIGl0IHNob3VsZCBpbmRlZWQgYmUgcmVtb3ZlZFxuICAgICAgZXhpc3RpbmdTb3J0QnkuZGVzYyAmJiAhc29ydERlc2NGaXJzdCB8fCAhZXhpc3RpbmdTb3J0QnkuZGVzYyAmJiBzb3J0RGVzY0ZpcnN0KSkge1xuICAgICAgICBzb3J0QWN0aW9uID0gJ3JlbW92ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3J0QWN0aW9uID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgX25ld1NvcnRCeSA9IFt7XG4gICAgICAgICAgaWQ6IGNvbHVtbklkLFxuICAgICAgICAgIGRlc2M6IGhhc0Rlc2NEZWZpbmVkID8gZGVzYyA6IHNvcnREZXNjRmlyc3RcbiAgICAgICAgfV07XG4gICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICdhZGQnKSB7XG4gICAgICAgIF9uZXdTb3J0QnkgPSBbXS5jb25jYXQoX3NvcnRCeTIsIFt7XG4gICAgICAgICAgaWQ6IGNvbHVtbklkLFxuICAgICAgICAgIGRlc2M6IGhhc0Rlc2NEZWZpbmVkID8gZGVzYyA6IHNvcnREZXNjRmlyc3RcbiAgICAgICAgfV0pOyAvLyBUYWtlIGxhdGVzdCBuIGNvbHVtbnNcblxuICAgICAgICBfbmV3U29ydEJ5LnNwbGljZSgwLCBfbmV3U29ydEJ5Lmxlbmd0aCAtIG1heE11bHRpU29ydENvbENvdW50KTtcbiAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgLy8gVGhpcyBmbGlwcyAob3Igc2V0cykgdGhlXG4gICAgICAgIF9uZXdTb3J0QnkgPSBfc29ydEJ5Mi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBpZiAoZC5pZCA9PT0gY29sdW1uSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZCwge1xuICAgICAgICAgICAgICBkZXNjOiBoYXNEZXNjRGVmaW5lZCA/IGRlc2MgOiAhZXhpc3RpbmdTb3J0QnkuZGVzY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICBfbmV3U29ydEJ5ID0gX3NvcnRCeTIuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQgIT09IGNvbHVtbklkO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzb3J0Qnk6IF9uZXdTb3J0QnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDUoaW5zdGFuY2UpIHtcbiAgICB2YXIgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIHJvd3MgPSBpbnN0YW5jZS5yb3dzLFxuICAgICAgICBmbGF0Um93cyA9IGluc3RhbmNlLmZsYXRSb3dzLFxuICAgICAgICBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgX2luc3RhbmNlJG9yZGVyQnlGbiA9IGluc3RhbmNlLm9yZGVyQnlGbixcbiAgICAgICAgb3JkZXJCeUZuID0gX2luc3RhbmNlJG9yZGVyQnlGbiA9PT0gdm9pZCAwID8gZGVmYXVsdE9yZGVyQnlGbiA6IF9pbnN0YW5jZSRvcmRlckJ5Rm4sXG4gICAgICAgIHVzZXJTb3J0VHlwZXMgPSBpbnN0YW5jZS5zb3J0VHlwZXMsXG4gICAgICAgIG1hbnVhbFNvcnRCeSA9IGluc3RhbmNlLm1hbnVhbFNvcnRCeSxcbiAgICAgICAgZGVmYXVsdENhblNvcnQgPSBpbnN0YW5jZS5kZWZhdWx0Q2FuU29ydCxcbiAgICAgICAgZGlzYWJsZVNvcnRCeSA9IGluc3RhbmNlLmRpc2FibGVTb3J0QnksXG4gICAgICAgIGZsYXRIZWFkZXJzID0gaW5zdGFuY2UuZmxhdEhlYWRlcnMsXG4gICAgICAgIHNvcnRCeSA9IGluc3RhbmNlLnN0YXRlLnNvcnRCeSxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3MsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRTbyA9IGluc3RhbmNlLmF1dG9SZXNldFNvcnRCeSxcbiAgICAgICAgYXV0b1Jlc2V0U29ydEJ5ID0gX2luc3RhbmNlJGF1dG9SZXNldFNvID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGF1dG9SZXNldFNvO1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlRmlsdGVycycsICd1c2VHbG9iYWxGaWx0ZXInLCAndXNlR3JvdXBCeScsICd1c2VQaXZvdENvbHVtbnMnXSwgJ3VzZVNvcnRCeScpO1xuICAgIHZhciBzZXRTb3J0QnkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoc29ydEJ5KSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0U29ydEJ5LFxuICAgICAgICBzb3J0Qnk6IHNvcnRCeVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7IC8vIFVwZGF0ZXMgc29ydGluZyBiYXNlZCBvbiBhIGNvbHVtbklkLCBkZXNjIGZsYWcgYW5kIG11bHRpIGZsYWdcblxuICAgIHZhciB0b2dnbGVTb3J0QnkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29sdW1uSWQsIGRlc2MsIG11bHRpKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlU29ydEJ5LFxuICAgICAgICBjb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgIGRlc2M6IGRlc2MsXG4gICAgICAgIG11bHRpOiBtdWx0aVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7IC8vIHVzZSByZWZlcmVuY2UgdG8gYXZvaWQgbWVtb3J5IGxlYWsgaW4gIzE2MDhcblxuICAgIHZhciBnZXRJbnN0YW5jZSA9IHVzZUdldExhdGVzdChpbnN0YW5jZSk7IC8vIEFkZCB0aGUgZ2V0U29ydEJ5VG9nZ2xlUHJvcHMgbWV0aG9kIHRvIGNvbHVtbnMgYW5kIGhlYWRlcnNcblxuICAgIGZsYXRIZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgdmFyIGFjY2Vzc29yID0gY29sdW1uLmFjY2Vzc29yLFxuICAgICAgICAgIGRlZmF1bHRDb2x1bW5DYW5Tb3J0ID0gY29sdW1uLmNhblNvcnQsXG4gICAgICAgICAgY29sdW1uRGlzYWJsZVNvcnRCeSA9IGNvbHVtbi5kaXNhYmxlU29ydEJ5LFxuICAgICAgICAgIGlkID0gY29sdW1uLmlkO1xuICAgICAgdmFyIGNhblNvcnQgPSBhY2Nlc3NvciA/IGdldEZpcnN0RGVmaW5lZChjb2x1bW5EaXNhYmxlU29ydEJ5ID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIGRpc2FibGVTb3J0QnkgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgdHJ1ZSkgOiBnZXRGaXJzdERlZmluZWQoZGVmYXVsdENhblNvcnQsIGRlZmF1bHRDb2x1bW5DYW5Tb3J0LCBmYWxzZSk7XG4gICAgICBjb2x1bW4uY2FuU29ydCA9IGNhblNvcnQ7XG5cbiAgICAgIGlmIChjb2x1bW4uY2FuU29ydCkge1xuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydEJ5ID0gZnVuY3Rpb24gKGRlc2MsIG11bHRpKSB7XG4gICAgICAgICAgcmV0dXJuIHRvZ2dsZVNvcnRCeShjb2x1bW4uaWQsIGRlc2MsIG11bHRpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb2x1bW4uY2xlYXJTb3J0QnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogYWN0aW9ucy5jbGVhclNvcnRCeSxcbiAgICAgICAgICAgIGNvbHVtbklkOiBjb2x1bW4uaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29sdW1uLmdldFNvcnRCeVRvZ2dsZVByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRTb3J0QnlUb2dnbGVQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgIH0pO1xuICAgICAgdmFyIGNvbHVtblNvcnQgPSBzb3J0QnkuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gaWQ7XG4gICAgICB9KTtcbiAgICAgIGNvbHVtbi5pc1NvcnRlZCA9ICEhY29sdW1uU29ydDtcbiAgICAgIGNvbHVtbi5zb3J0ZWRJbmRleCA9IHNvcnRCeS5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGlkO1xuICAgICAgfSk7XG4gICAgICBjb2x1bW4uaXNTb3J0ZWREZXNjID0gY29sdW1uLmlzU29ydGVkID8gY29sdW1uU29ydC5kZXNjIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VNZW1vID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobWFudWFsU29ydEJ5IHx8ICFzb3J0QnkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3NdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc29ydGVkRmxhdFJvd3MgPSBbXTsgLy8gRmlsdGVyIG91dCBzb3J0QnlzIHRoYXQgY29ycmVzcG9uZCB0byBub24gZXhpc3RpbmcgY29sdW1uc1xuXG4gICAgICB2YXIgYXZhaWxhYmxlU29ydEJ5ID0gc29ydEJ5LmZpbHRlcihmdW5jdGlvbiAoc29ydCkge1xuICAgICAgICByZXR1cm4gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgICByZXR1cm4gY29sLmlkID09PSBzb3J0LmlkO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc29ydERhdGEgPSBmdW5jdGlvbiBzb3J0RGF0YShyb3dzKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgb3JkZXJCeUZuIHRvIGNvbXBvc2UgbXVsdGlwbGUgc29ydEJ5J3MgdG9nZXRoZXIuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHBlcmZvcm0gYSBzdGFibGUgc29ydGluZyB1c2luZyB0aGUgcm93IGluZGV4XG4gICAgICAgIC8vIGlmIG5lZWRlZC5cbiAgICAgICAgdmFyIHNvcnRlZERhdGEgPSBvcmRlckJ5Rm4ocm93cywgYXZhaWxhYmxlU29ydEJ5Lm1hcChmdW5jdGlvbiAoc29ydCkge1xuICAgICAgICAgIC8vIFN1cHBvcnQgY3VzdG9tIHNvcnRpbmcgbWV0aG9kcyBmb3IgZWFjaCBjb2x1bW5cbiAgICAgICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gc29ydC5pZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC1UYWJsZTogQ291bGQgbm90IGZpbmQgYSBjb2x1bW4gd2l0aCBpZDogXCIgKyBzb3J0LmlkICsgXCIgd2hpbGUgc29ydGluZ1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc29ydFR5cGUgPSBjb2x1bW4uc29ydFR5cGU7IC8vIExvb2sgdXAgc29ydEJ5IGZ1bmN0aW9ucyBpbiB0aGlzIG9yZGVyOlxuICAgICAgICAgIC8vIGNvbHVtbiBmdW5jdGlvblxuICAgICAgICAgIC8vIGNvbHVtbiBzdHJpbmcgbG9va3VwIG9uIHVzZXIgc29ydFR5cGVcbiAgICAgICAgICAvLyBjb2x1bW4gc3RyaW5nIGxvb2t1cCBvbiBidWlsdC1pbiBzb3J0VHlwZVxuICAgICAgICAgIC8vIGRlZmF1bHQgZnVuY3Rpb25cbiAgICAgICAgICAvLyBkZWZhdWx0IHN0cmluZyBsb29rdXAgb24gdXNlciBzb3J0VHlwZVxuICAgICAgICAgIC8vIGRlZmF1bHQgc3RyaW5nIGxvb2t1cCBvbiBidWlsdC1pbiBzb3J0VHlwZVxuXG4gICAgICAgICAgdmFyIHNvcnRNZXRob2QgPSBpc0Z1bmN0aW9uKHNvcnRUeXBlKSB8fCAodXNlclNvcnRUeXBlcyB8fCB7fSlbc29ydFR5cGVdIHx8IHNvcnRUeXBlc1tzb3J0VHlwZV07XG5cbiAgICAgICAgICBpZiAoIXNvcnRNZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0LVRhYmxlOiBDb3VsZCBub3QgZmluZCBhIHZhbGlkIHNvcnRUeXBlIG9mICdcIiArIHNvcnRUeXBlICsgXCInIGZvciBjb2x1bW4gJ1wiICsgc29ydC5pZCArIFwiJy5cIik7XG4gICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGNvcnJlY3Qgc29ydEZuLlxuICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGFsd2F5cyByZXR1cm4gaW4gYXNjZW5kaW5nIG9yZGVyXG5cblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRNZXRob2QoYSwgYiwgc29ydC5pZCwgc29ydC5kZXNjKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSwgLy8gTWFwIHRoZSBkaXJlY3Rpb25zXG4gICAgICAgIGF2YWlsYWJsZVNvcnRCeS5tYXAoZnVuY3Rpb24gKHNvcnQpIHtcbiAgICAgICAgICAvLyBEZXRlY3QgYW5kIHVzZSB0aGUgc29ydEludmVydGVkIG9wdGlvblxuICAgICAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLmlkID09PSBzb3J0LmlkO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4uc29ydEludmVydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydC5kZXNjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAhc29ydC5kZXNjO1xuICAgICAgICB9KSk7IC8vIElmIHRoZXJlIGFyZSBzdWItcm93cywgc29ydCB0aGVtXG5cbiAgICAgICAgc29ydGVkRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICBzb3J0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XG5cbiAgICAgICAgICBpZiAoIXJvdy5zdWJSb3dzIHx8IHJvdy5zdWJSb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdy5zdWJSb3dzID0gc29ydERhdGEocm93LnN1YlJvd3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvcnRlZERhdGE7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gW3NvcnREYXRhKHJvd3MpLCBzb3J0ZWRGbGF0Um93c107XG4gICAgfSwgW21hbnVhbFNvcnRCeSwgc29ydEJ5LCByb3dzLCBmbGF0Um93cywgYWxsQ29sdW1ucywgb3JkZXJCeUZuLCB1c2VyU29ydFR5cGVzXSksXG4gICAgICAgIHNvcnRlZFJvd3MgPSBfUmVhY3QkdXNlTWVtb1swXSxcbiAgICAgICAgc29ydGVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1sxXTtcblxuICAgIHZhciBnZXRBdXRvUmVzZXRTb3J0QnkgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0U29ydEJ5KTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRTb3J0QnkoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFNvcnRCeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbbWFudWFsU29ydEJ5ID8gbnVsbCA6IGRhdGFdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBwcmVTb3J0ZWRSb3dzOiByb3dzLFxuICAgICAgcHJlU29ydGVkRmxhdFJvd3M6IGZsYXRSb3dzLFxuICAgICAgc29ydGVkUm93czogc29ydGVkUm93cyxcbiAgICAgIHNvcnRlZEZsYXRSb3dzOiBzb3J0ZWRGbGF0Um93cyxcbiAgICAgIHJvd3M6IHNvcnRlZFJvd3MsXG4gICAgICBmbGF0Um93czogc29ydGVkRmxhdFJvd3MsXG4gICAgICBzZXRTb3J0Qnk6IHNldFNvcnRCeSxcbiAgICAgIHRvZ2dsZVNvcnRCeTogdG9nZ2xlU29ydEJ5XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0T3JkZXJCeUZuKGFyciwgZnVuY3MsIGRpcnMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGFycikuc29ydChmdW5jdGlvbiAocm93QSwgcm93Qikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc29ydEZuID0gZnVuY3NbaV07XG4gICAgICAgIHZhciBkZXNjID0gZGlyc1tpXSA9PT0gZmFsc2UgfHwgZGlyc1tpXSA9PT0gJ2Rlc2MnO1xuICAgICAgICB2YXIgc29ydEludCA9IHNvcnRGbihyb3dBLCByb3dCKTtcblxuICAgICAgICBpZiAoc29ydEludCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBkZXNjID8gLXNvcnRJbnQgOiBzb3J0SW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXJzWzBdID8gcm93QS5pbmRleCAtIHJvd0IuaW5kZXggOiByb3dCLmluZGV4IC0gcm93QS5pbmRleDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwbHVnaW5OYW1lID0gJ3VzZVBhZ2luYXRpb24nOyAvLyBBY3Rpb25zXG5cbiAgYWN0aW9ucy5yZXNldFBhZ2UgPSAncmVzZXRQYWdlJztcbiAgYWN0aW9ucy5nb3RvUGFnZSA9ICdnb3RvUGFnZSc7XG4gIGFjdGlvbnMuc2V0UGFnZVNpemUgPSAnc2V0UGFnZVNpemUnO1xuICB2YXIgdXNlUGFnaW5hdGlvbiA9IGZ1bmN0aW9uIHVzZVBhZ2luYXRpb24oaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQ2KTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDYpO1xuICB9O1xuICB1c2VQYWdpbmF0aW9uLnBsdWdpbk5hbWUgPSBwbHVnaW5OYW1lO1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkNihzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBwYWdlU2l6ZTogMTAsXG4gICAgICAgIHBhZ2VJbmRleDogMFxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFBhZ2UpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGFnZUluZGV4OiBpbnN0YW5jZS5pbml0aWFsU3RhdGUucGFnZUluZGV4IHx8IDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5nb3RvUGFnZSkge1xuICAgICAgdmFyIHBhZ2VDb3VudCA9IGluc3RhbmNlLnBhZ2VDb3VudCxcbiAgICAgICAgICBwYWdlID0gaW5zdGFuY2UucGFnZTtcbiAgICAgIHZhciBuZXdQYWdlSW5kZXggPSBmdW5jdGlvbmFsVXBkYXRlKGFjdGlvbi5wYWdlSW5kZXgsIHN0YXRlLnBhZ2VJbmRleCk7XG4gICAgICB2YXIgY2FuTmF2aWdhdGUgPSBmYWxzZTtcblxuICAgICAgaWYgKG5ld1BhZ2VJbmRleCA+IHN0YXRlLnBhZ2VJbmRleCkge1xuICAgICAgICAvLyBuZXh0IHBhZ2VcbiAgICAgICAgY2FuTmF2aWdhdGUgPSBwYWdlQ291bnQgPT09IC0xID8gcGFnZS5sZW5ndGggPj0gc3RhdGUucGFnZVNpemUgOiBuZXdQYWdlSW5kZXggPCBwYWdlQ291bnQ7XG4gICAgICB9IGVsc2UgaWYgKG5ld1BhZ2VJbmRleCA8IHN0YXRlLnBhZ2VJbmRleCkge1xuICAgICAgICAvLyBwcmV2IHBhZ2VcbiAgICAgICAgY2FuTmF2aWdhdGUgPSBuZXdQYWdlSW5kZXggPiAtMTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5OYXZpZ2F0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGFnZUluZGV4OiBuZXdQYWdlSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRQYWdlU2l6ZSkge1xuICAgICAgdmFyIHBhZ2VTaXplID0gYWN0aW9uLnBhZ2VTaXplO1xuICAgICAgdmFyIHRvcFJvd0luZGV4ID0gc3RhdGUucGFnZVNpemUgKiBzdGF0ZS5wYWdlSW5kZXg7XG4gICAgICB2YXIgcGFnZUluZGV4ID0gTWF0aC5mbG9vcih0b3BSb3dJbmRleCAvIHBhZ2VTaXplKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkNihpbnN0YW5jZSkge1xuICAgIHZhciByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldFBhID0gaW5zdGFuY2UuYXV0b1Jlc2V0UGFnZSxcbiAgICAgICAgYXV0b1Jlc2V0UGFnZSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRQYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRQYSxcbiAgICAgICAgX2luc3RhbmNlJG1hbnVhbEV4cGFuID0gaW5zdGFuY2UubWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgIG1hbnVhbEV4cGFuZGVkS2V5ID0gX2luc3RhbmNlJG1hbnVhbEV4cGFuID09PSB2b2lkIDAgPyAnZXhwYW5kZWQnIDogX2luc3RhbmNlJG1hbnVhbEV4cGFuLFxuICAgICAgICBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgdXNlclBhZ2VDb3VudCA9IGluc3RhbmNlLnBhZ2VDb3VudCxcbiAgICAgICAgX2luc3RhbmNlJHBhZ2luYXRlRXhwID0gaW5zdGFuY2UucGFnaW5hdGVFeHBhbmRlZFJvd3MsXG4gICAgICAgIHBhZ2luYXRlRXhwYW5kZWRSb3dzID0gX2luc3RhbmNlJHBhZ2luYXRlRXhwID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJHBhZ2luYXRlRXhwLFxuICAgICAgICBfaW5zdGFuY2UkZXhwYW5kU3ViUm8gPSBpbnN0YW5jZS5leHBhbmRTdWJSb3dzLFxuICAgICAgICBleHBhbmRTdWJSb3dzID0gX2luc3RhbmNlJGV4cGFuZFN1YlJvID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJGV4cGFuZFN1YlJvLFxuICAgICAgICBfaW5zdGFuY2Ukc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgcGFnZVNpemUgPSBfaW5zdGFuY2Ukc3RhdGUucGFnZVNpemUsXG4gICAgICAgIHBhZ2VJbmRleCA9IF9pbnN0YW5jZSRzdGF0ZS5wYWdlSW5kZXgsXG4gICAgICAgIGV4cGFuZGVkID0gX2luc3RhbmNlJHN0YXRlLmV4cGFuZGVkLFxuICAgICAgICBnbG9iYWxGaWx0ZXIgPSBfaW5zdGFuY2Ukc3RhdGUuZ2xvYmFsRmlsdGVyLFxuICAgICAgICBmaWx0ZXJzID0gX2luc3RhbmNlJHN0YXRlLmZpbHRlcnMsXG4gICAgICAgIGdyb3VwQnkgPSBfaW5zdGFuY2Ukc3RhdGUuZ3JvdXBCeSxcbiAgICAgICAgc29ydEJ5ID0gX2luc3RhbmNlJHN0YXRlLnNvcnRCeSxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIG1hbnVhbFBhZ2luYXRpb24gPSBpbnN0YW5jZS5tYW51YWxQYWdpbmF0aW9uO1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlR2xvYmFsRmlsdGVyJywgJ3VzZUZpbHRlcnMnLCAndXNlR3JvdXBCeScsICd1c2VTb3J0QnknLCAndXNlRXhwYW5kZWQnXSwgJ3VzZVBhZ2luYXRpb24nKTtcbiAgICB2YXIgZ2V0QXV0b1Jlc2V0UGFnZSA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRQYWdlKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRQYWdlKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRQYWdlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgbWFudWFsUGFnaW5hdGlvbiA/IG51bGwgOiBkYXRhLCBnbG9iYWxGaWx0ZXIsIGZpbHRlcnMsIGdyb3VwQnksIHNvcnRCeV0pO1xuICAgIHZhciBwYWdlQ291bnQgPSBtYW51YWxQYWdpbmF0aW9uID8gdXNlclBhZ2VDb3VudCA6IE1hdGguY2VpbChyb3dzLmxlbmd0aCAvIHBhZ2VTaXplKTtcbiAgICB2YXIgcGFnZU9wdGlvbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwYWdlQ291bnQgPiAwID8gW10uY29uY2F0KG5ldyBBcnJheShwYWdlQ291bnQpKS5maWxsKG51bGwpLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH0pIDogW107XG4gICAgfSwgW3BhZ2VDb3VudF0pO1xuICAgIHZhciBwYWdlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFnZTtcblxuICAgICAgaWYgKG1hbnVhbFBhZ2luYXRpb24pIHtcbiAgICAgICAgcGFnZSA9IHJvd3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFnZVN0YXJ0ID0gcGFnZVNpemUgKiBwYWdlSW5kZXg7XG4gICAgICAgIHZhciBwYWdlRW5kID0gcGFnZVN0YXJ0ICsgcGFnZVNpemU7XG4gICAgICAgIHBhZ2UgPSByb3dzLnNsaWNlKHBhZ2VTdGFydCwgcGFnZUVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdpbmF0ZUV4cGFuZGVkUm93cykge1xuICAgICAgICByZXR1cm4gcGFnZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cGFuZFJvd3MocGFnZSwge1xuICAgICAgICBtYW51YWxFeHBhbmRlZEtleTogbWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgIGV4cGFuZGVkOiBleHBhbmRlZCxcbiAgICAgICAgZXhwYW5kU3ViUm93czogZXhwYW5kU3ViUm93c1xuICAgICAgfSk7XG4gICAgfSwgW2V4cGFuZFN1YlJvd3MsIGV4cGFuZGVkLCBtYW51YWxFeHBhbmRlZEtleSwgbWFudWFsUGFnaW5hdGlvbiwgcGFnZUluZGV4LCBwYWdlU2l6ZSwgcGFnaW5hdGVFeHBhbmRlZFJvd3MsIHJvd3NdKTtcbiAgICB2YXIgY2FuUHJldmlvdXNQYWdlID0gcGFnZUluZGV4ID4gMDtcbiAgICB2YXIgY2FuTmV4dFBhZ2UgPSBwYWdlQ291bnQgPT09IC0xID8gcGFnZS5sZW5ndGggPj0gcGFnZVNpemUgOiBwYWdlSW5kZXggPCBwYWdlQ291bnQgLSAxO1xuICAgIHZhciBnb3RvUGFnZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYWdlSW5kZXgpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5nb3RvUGFnZSxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXhcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciBwcmV2aW91c1BhZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ290b1BhZ2UoZnVuY3Rpb24gKG9sZCkge1xuICAgICAgICByZXR1cm4gb2xkIC0gMTtcbiAgICAgIH0pO1xuICAgIH0sIFtnb3RvUGFnZV0pO1xuICAgIHZhciBuZXh0UGFnZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnb3RvUGFnZShmdW5jdGlvbiAob2xkKSB7XG4gICAgICAgIHJldHVybiBvbGQgKyAxO1xuICAgICAgfSk7XG4gICAgfSwgW2dvdG9QYWdlXSk7XG4gICAgdmFyIHNldFBhZ2VTaXplID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHBhZ2VTaXplKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0UGFnZVNpemUsXG4gICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcGFnZU9wdGlvbnM6IHBhZ2VPcHRpb25zLFxuICAgICAgcGFnZUNvdW50OiBwYWdlQ291bnQsXG4gICAgICBwYWdlOiBwYWdlLFxuICAgICAgY2FuUHJldmlvdXNQYWdlOiBjYW5QcmV2aW91c1BhZ2UsXG4gICAgICBjYW5OZXh0UGFnZTogY2FuTmV4dFBhZ2UsXG4gICAgICBnb3RvUGFnZTogZ290b1BhZ2UsXG4gICAgICBwcmV2aW91c1BhZ2U6IHByZXZpb3VzUGFnZSxcbiAgICAgIG5leHRQYWdlOiBuZXh0UGFnZSxcbiAgICAgIHNldFBhZ2VTaXplOiBzZXRQYWdlU2l6ZVxuICAgIH0pO1xuICB9XG5cbiAgYWN0aW9ucy5yZXNldFBpdm90ID0gJ3Jlc2V0UGl2b3QnO1xuICBhY3Rpb25zLnRvZ2dsZVBpdm90ID0gJ3RvZ2dsZVBpdm90JztcbiAgdmFyIF9VTlNUQUJMRV91c2VQaXZvdENvbHVtbnMgPSBmdW5jdGlvbiBfVU5TVEFCTEVfdXNlUGl2b3RDb2x1bW5zKGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0UGl2b3RUb2dnbGVQcm9wcyA9IFtkZWZhdWx0R2V0UGl2b3RUb2dnbGVQcm9wc107XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkNyk7XG4gICAgaG9va3MudXNlSW5zdGFuY2VBZnRlckRhdGEucHVzaCh1c2VJbnN0YW5jZUFmdGVyRGF0YSk7XG4gICAgaG9va3MuYWxsQ29sdW1ucy5wdXNoKGFsbENvbHVtbnMpO1xuICAgIGhvb2tzLmFjY2Vzc1ZhbHVlLnB1c2goYWNjZXNzVmFsdWUpO1xuICAgIGhvb2tzLm1hdGVyaWFsaXplZENvbHVtbnMucHVzaChtYXRlcmlhbGl6ZWRDb2x1bW5zKTtcbiAgICBob29rcy5tYXRlcmlhbGl6ZWRDb2x1bW5zRGVwcy5wdXNoKG1hdGVyaWFsaXplZENvbHVtbnNEZXBzKTtcbiAgICBob29rcy52aXNpYmxlQ29sdW1ucy5wdXNoKHZpc2libGVDb2x1bW5zJDEpO1xuICAgIGhvb2tzLnZpc2libGVDb2x1bW5zRGVwcy5wdXNoKHZpc2libGVDb2x1bW5zRGVwcyk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ3KTtcbiAgICBob29rcy5wcmVwYXJlUm93LnB1c2gocHJlcGFyZVJvdyQyKTtcbiAgfTtcbiAgX1VOU1RBQkxFX3VzZVBpdm90Q29sdW1ucy5wbHVnaW5OYW1lID0gJ3VzZVBpdm90Q29sdW1ucyc7XG4gIHZhciBkZWZhdWx0UGl2b3RDb2x1bW5zID0gW107XG5cbiAgdmFyIGRlZmF1bHRHZXRQaXZvdFRvZ2dsZVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFBpdm90VG9nZ2xlUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaGVhZGVyID0gX3JlZi5oZWFkZXI7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DbGljazogaGVhZGVyLmNhblBpdm90ID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wZXJzaXN0KCk7XG4gICAgICAgIGhlYWRlci50b2dnbGVQaXZvdCgpO1xuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogaGVhZGVyLmNhblBpdm90ID8gJ3BvaW50ZXInIDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgdGl0bGU6ICdUb2dnbGUgUGl2b3QnXG4gICAgfV07XG4gIH07IC8vIFJlZHVjZXJcblxuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkNyhzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBwaXZvdENvbHVtbnM6IGRlZmF1bHRQaXZvdENvbHVtbnNcbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRQaXZvdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBwaXZvdENvbHVtbnM6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5waXZvdENvbHVtbnMgfHwgZGVmYXVsdFBpdm90Q29sdW1uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZVBpdm90KSB7XG4gICAgICB2YXIgY29sdW1uSWQgPSBhY3Rpb24uY29sdW1uSWQsXG4gICAgICAgICAgc2V0UGl2b3QgPSBhY3Rpb24udmFsdWU7XG4gICAgICB2YXIgcmVzb2x2ZWRQaXZvdCA9IHR5cGVvZiBzZXRQaXZvdCAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRQaXZvdCA6ICFzdGF0ZS5waXZvdENvbHVtbnMuaW5jbHVkZXMoY29sdW1uSWQpO1xuXG4gICAgICBpZiAocmVzb2x2ZWRQaXZvdCkge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgcGl2b3RDb2x1bW5zOiBbXS5jb25jYXQoc3RhdGUucGl2b3RDb2x1bW5zLCBbY29sdW1uSWRdKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBwaXZvdENvbHVtbnM6IHN0YXRlLnBpdm90Q29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZCAhPT0gY29sdW1uSWQ7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZUFmdGVyRGF0YShpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLmFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4uaXNQaXZvdFNvdXJjZSA9IGluc3RhbmNlLnN0YXRlLnBpdm90Q29sdW1ucy5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsQ29sdW1ucyhjb2x1bW5zLCBfcmVmMikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYyLmluc3RhbmNlO1xuICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4uaXNQaXZvdFNvdXJjZSA9IGluc3RhbmNlLnN0YXRlLnBpdm90Q29sdW1ucy5pbmNsdWRlcyhjb2x1bW4uaWQpO1xuICAgICAgY29sdW1uLnVuaXF1ZVZhbHVlcyA9IG5ldyBTZXQoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY2Vzc1ZhbHVlKHZhbHVlLCBfcmVmMykge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmMy5jb2x1bW47XG5cbiAgICBpZiAoY29sdW1uLnVuaXF1ZVZhbHVlcyAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb2x1bW4udW5pcXVlVmFsdWVzLmFkZCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0ZXJpYWxpemVkQ29sdW1ucyhtYXRlcmlhbGl6ZWQsIF9yZWY0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZjQuaW5zdGFuY2U7XG4gICAgdmFyIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKCFzdGF0ZS5waXZvdENvbHVtbnMubGVuZ3RoIHx8ICFzdGF0ZS5ncm91cEJ5IHx8ICFzdGF0ZS5ncm91cEJ5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1hdGVyaWFsaXplZDtcbiAgICB9XG5cbiAgICB2YXIgcGl2b3RDb2x1bW5zID0gc3RhdGUucGl2b3RDb2x1bW5zLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGlkO1xuICAgICAgfSk7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIHZhciBzb3VyY2VDb2x1bW5zID0gYWxsQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAhZC5pc1Bpdm90U291cmNlICYmICFzdGF0ZS5ncm91cEJ5LmluY2x1ZGVzKGQuaWQpICYmICFzdGF0ZS5waXZvdENvbHVtbnMuaW5jbHVkZXMoZC5pZCk7XG4gICAgfSk7XG5cbiAgICB2YXIgYnVpbGRQaXZvdENvbHVtbnMgPSBmdW5jdGlvbiBidWlsZFBpdm90Q29sdW1ucyhkZXB0aCwgcGFyZW50LCBwaXZvdEZpbHRlcnMpIHtcbiAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpdm90RmlsdGVycyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHBpdm90RmlsdGVycyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGl2b3RDb2x1bW4gPSBwaXZvdENvbHVtbnNbZGVwdGhdO1xuXG4gICAgICBpZiAoIXBpdm90Q29sdW1uKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VDb2x1bW5zLm1hcChmdW5jdGlvbiAoc291cmNlQ29sdW1uKSB7XG4gICAgICAgICAgLy8gVE9ETzogV2UgY291bGQgb2ZmZXIgc3VwcG9ydCBoZXJlIGZvciByZW5lc3RpbmcgcGl2b3RlZFxuICAgICAgICAgIC8vIGNvbHVtbnMgaW5zaWRlIGNvcGllcyBvZiB0aGVpciBoZWFkZXIgZ3JvdXBzLiBGb3Igbm93LFxuICAgICAgICAgIC8vIHRoYXQgc2VlbXMgbGlrZSBpdCB3b3VsZCBiZSAoMSkgb3ZlcmtpbGwgb24gbmVzdGluZywgY29uc2lkZXJpbmdcbiAgICAgICAgICAvLyB5b3UgYWxyZWFkeSBnZXQgbmVzdGluZyBmb3IgZXZlcnkgcGl2b3QgbGV2ZWwgYW5kICgyKVxuICAgICAgICAgIC8vIHJlYWxseSBoYXJkLiA6KVxuICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc291cmNlQ29sdW1uLCB7XG4gICAgICAgICAgICBjYW5QaXZvdDogZmFsc2UsXG4gICAgICAgICAgICBpc1Bpdm90ZWQ6IHRydWUsXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICAgIGlkOiBcIlwiICsgKHBhcmVudCA/IHBhcmVudC5pZCArIFwiLlwiICsgc291cmNlQ29sdW1uLmlkIDogc291cmNlQ29sdW1uLmlkKSxcbiAgICAgICAgICAgIGFjY2Vzc29yOiBmdW5jdGlvbiBhY2Nlc3NvcihvcmlnaW5hbFJvdywgaSwgcm93KSB7XG4gICAgICAgICAgICAgIGlmIChwaXZvdEZpbHRlcnMuZXZlcnkoZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIocm93KTtcbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93LnZhbHVlc1tzb3VyY2VDb2x1bW4uaWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdW5pcXVlVmFsdWVzID0gQXJyYXkuZnJvbShwaXZvdENvbHVtbi51bmlxdWVWYWx1ZXMpLnNvcnQoKTtcbiAgICAgIHJldHVybiB1bmlxdWVWYWx1ZXMubWFwKGZ1bmN0aW9uICh1bmlxdWVWYWx1ZSkge1xuICAgICAgICB2YXIgY29sdW1uR3JvdXAgPSBfZXh0ZW5kcyh7fSwgcGl2b3RDb2x1bW4sIHtcbiAgICAgICAgICBIZWFkZXI6IHBpdm90Q29sdW1uLlBpdm90SGVhZGVyIHx8IHR5cGVvZiBwaXZvdENvbHVtbi5oZWFkZXIgPT09ICdzdHJpbmcnID8gcGl2b3RDb2x1bW4uSGVhZGVyICsgXCI6IFwiICsgdW5pcXVlVmFsdWUgOiB1bmlxdWVWYWx1ZSxcbiAgICAgICAgICBpc1Bpdm90R3JvdXA6IHRydWUsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgIGlkOiBwYXJlbnQgPyBwYXJlbnQuaWQgKyBcIi5cIiArIHBpdm90Q29sdW1uLmlkICsgXCIuXCIgKyB1bmlxdWVWYWx1ZSA6IHBpdm90Q29sdW1uLmlkICsgXCIuXCIgKyB1bmlxdWVWYWx1ZSxcbiAgICAgICAgICBwaXZvdFZhbHVlOiB1bmlxdWVWYWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb2x1bW5Hcm91cC5jb2x1bW5zID0gYnVpbGRQaXZvdENvbHVtbnMoZGVwdGggKyAxLCBjb2x1bW5Hcm91cCwgW10uY29uY2F0KHBpdm90RmlsdGVycywgW2Z1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gcm93LnZhbHVlc1twaXZvdENvbHVtbi5pZF0gPT09IHVuaXF1ZVZhbHVlO1xuICAgICAgICB9XSkpO1xuICAgICAgICByZXR1cm4gY29sdW1uR3JvdXA7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG5ld01hdGVyaWFsaXplZCA9IGZsYXR0ZW5Db2x1bW5zKGJ1aWxkUGl2b3RDb2x1bW5zKCkpO1xuICAgIHJldHVybiBbXS5jb25jYXQobWF0ZXJpYWxpemVkLCBuZXdNYXRlcmlhbGl6ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0ZXJpYWxpemVkQ29sdW1uc0RlcHMoZGVwcywgX3JlZjUpIHtcbiAgICB2YXIgX3JlZjUkaW5zdGFuY2Ukc3RhdGUgPSBfcmVmNS5pbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgcGl2b3RDb2x1bW5zID0gX3JlZjUkaW5zdGFuY2Ukc3RhdGUucGl2b3RDb2x1bW5zLFxuICAgICAgICBncm91cEJ5ID0gX3JlZjUkaW5zdGFuY2Ukc3RhdGUuZ3JvdXBCeTtcbiAgICByZXR1cm4gW10uY29uY2F0KGRlcHMsIFtwaXZvdENvbHVtbnMsIGdyb3VwQnldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGVDb2x1bW5zJDEodmlzaWJsZUNvbHVtbnMsIF9yZWY2KSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZjYuaW5zdGFuY2Uuc3RhdGU7XG4gICAgdmlzaWJsZUNvbHVtbnMgPSB2aXNpYmxlQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiAhZC5pc1Bpdm90U291cmNlO1xuICAgIH0pO1xuXG4gICAgaWYgKHN0YXRlLnBpdm90Q29sdW1ucy5sZW5ndGggJiYgc3RhdGUuZ3JvdXBCeSAmJiBzdGF0ZS5ncm91cEJ5Lmxlbmd0aCkge1xuICAgICAgdmlzaWJsZUNvbHVtbnMgPSB2aXNpYmxlQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gY29sdW1uLmlzR3JvdXBlZCB8fCBjb2x1bW4uaXNQaXZvdGVkO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpc2libGVDb2x1bW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaWJsZUNvbHVtbnNEZXBzKGRlcHMsIF9yZWY3KSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZjcuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbaW5zdGFuY2Uuc3RhdGUucGl2b3RDb2x1bW5zLCBpbnN0YW5jZS5zdGF0ZS5ncm91cEJ5XSk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQ3KGluc3RhbmNlKSB7XG4gICAgdmFyIGNvbHVtbnMgPSBpbnN0YW5jZS5jb2x1bW5zLFxuICAgICAgICBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgZmxhdEhlYWRlcnMgPSBpbnN0YW5jZS5mbGF0SGVhZGVycyxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRQaSA9IGluc3RhbmNlLmF1dG9SZXNldFBpdm90LFxuICAgICAgICBhdXRvUmVzZXRQaXZvdCA9IF9pbnN0YW5jZSRhdXRvUmVzZXRQaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRQaSxcbiAgICAgICAgbWFuYXVsUGl2b3QgPSBpbnN0YW5jZS5tYW5hdWxQaXZvdCxcbiAgICAgICAgZGlzYWJsZVBpdm90ID0gaW5zdGFuY2UuZGlzYWJsZVBpdm90LFxuICAgICAgICBkZWZhdWx0Q2FuUGl2b3QgPSBpbnN0YW5jZS5kZWZhdWx0Q2FuUGl2b3Q7XG4gICAgZW5zdXJlUGx1Z2luT3JkZXIocGx1Z2lucywgWyd1c2VHcm91cEJ5J10sICd1c2VQaXZvdENvbHVtbnMnKTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIGFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICB2YXIgYWNjZXNzb3IgPSBjb2x1bW4uYWNjZXNzb3IsXG4gICAgICAgICAgZGVmYXVsdENvbHVtblBpdm90ID0gY29sdW1uLmRlZmF1bHRQaXZvdCxcbiAgICAgICAgICBjb2x1bW5EaXNhYmxlUGl2b3QgPSBjb2x1bW4uZGlzYWJsZVBpdm90O1xuICAgICAgY29sdW1uLmNhblBpdm90ID0gYWNjZXNzb3IgPyBnZXRGaXJzdERlZmluZWQoY29sdW1uLmNhblBpdm90LCBjb2x1bW5EaXNhYmxlUGl2b3QgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgZGlzYWJsZVBpdm90ID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIHRydWUpIDogZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbi5jYW5QaXZvdCwgZGVmYXVsdENvbHVtblBpdm90LCBkZWZhdWx0Q2FuUGl2b3QsIGZhbHNlKTtcblxuICAgICAgaWYgKGNvbHVtbi5jYW5QaXZvdCkge1xuICAgICAgICBjb2x1bW4udG9nZ2xlUGl2b3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnRvZ2dsZVBpdm90KGNvbHVtbi5pZCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbHVtbi5BZ2dyZWdhdGVkID0gY29sdW1uLkFnZ3JlZ2F0ZWQgfHwgY29sdW1uLkNlbGw7XG4gICAgfSk7XG5cbiAgICB2YXIgdG9nZ2xlUGl2b3QgPSBmdW5jdGlvbiB0b2dnbGVQaXZvdChjb2x1bW5JZCwgdmFsdWUpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVQaXZvdCxcbiAgICAgICAgY29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmbGF0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgIGhlYWRlci5nZXRQaXZvdFRvZ2dsZVByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRQaXZvdFRvZ2dsZVByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBoZWFkZXI6IGhlYWRlclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGdldEF1dG9SZXNldFBpdm90ID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldFBpdm90KTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRQaXZvdCgpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0UGl2b3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBtYW5hdWxQaXZvdCA/IG51bGwgOiBjb2x1bW5zXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgdG9nZ2xlUGl2b3Q6IHRvZ2dsZVBpdm90XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93JDIocm93KSB7XG4gICAgcm93LmFsbENlbGxzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgIC8vIEdyb3VwZWQgY2VsbHMgYXJlIGluIHRoZSBwaXZvdENvbHVtbnMgYW5kIHRoZSBwaXZvdCBjZWxsIGZvciB0aGUgcm93XG4gICAgICBjZWxsLmlzUGl2b3RlZCA9IGNlbGwuY29sdW1uLmlzUGl2b3RlZDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwbHVnaW5OYW1lJDEgPSAndXNlUm93U2VsZWN0JzsgLy8gQWN0aW9uc1xuXG4gIGFjdGlvbnMucmVzZXRTZWxlY3RlZFJvd3MgPSAncmVzZXRTZWxlY3RlZFJvd3MnO1xuICBhY3Rpb25zLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZCA9ICd0b2dnbGVBbGxSb3dzU2VsZWN0ZWQnO1xuICBhY3Rpb25zLnRvZ2dsZVJvd1NlbGVjdGVkID0gJ3RvZ2dsZVJvd1NlbGVjdGVkJztcbiAgYWN0aW9ucy50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkID0gJ3RvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQnO1xuICB2YXIgdXNlUm93U2VsZWN0ID0gZnVuY3Rpb24gdXNlUm93U2VsZWN0KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0VG9nZ2xlUm93U2VsZWN0ZWRQcm9wcyA9IFtkZWZhdWx0R2V0VG9nZ2xlUm93U2VsZWN0ZWRQcm9wc107XG4gICAgaG9va3MuZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzXTtcbiAgICBob29rcy5nZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wc107XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkOCk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ4KTtcbiAgICBob29rcy5wcmVwYXJlUm93LnB1c2gocHJlcGFyZVJvdyQzKTtcbiAgfTtcbiAgdXNlUm93U2VsZWN0LnBsdWdpbk5hbWUgPSBwbHVnaW5OYW1lJDE7XG5cbiAgdmFyIGRlZmF1bHRHZXRUb2dnbGVSb3dTZWxlY3RlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgICByb3cgPSBfcmVmLnJvdztcbiAgICB2YXIgX2luc3RhbmNlJG1hbnVhbFJvd1NlID0gaW5zdGFuY2UubWFudWFsUm93U2VsZWN0ZWRLZXksXG4gICAgICAgIG1hbnVhbFJvd1NlbGVjdGVkS2V5ID0gX2luc3RhbmNlJG1hbnVhbFJvd1NlID09PSB2b2lkIDAgPyAnaXNTZWxlY3RlZCcgOiBfaW5zdGFuY2UkbWFudWFsUm93U2U7XG4gICAgdmFyIGNoZWNrZWQgPSBmYWxzZTtcblxuICAgIGlmIChyb3cub3JpZ2luYWwgJiYgcm93Lm9yaWdpbmFsW21hbnVhbFJvd1NlbGVjdGVkS2V5XSkge1xuICAgICAgY2hlY2tlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrZWQgPSByb3cuaXNTZWxlY3RlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICByb3cudG9nZ2xlUm93U2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgIH0sXG4gICAgICBjaGVja2VkOiBjaGVja2VkLFxuICAgICAgdGl0bGU6ICdUb2dnbGUgUm93IFNlbGVjdGVkJyxcbiAgICAgIGluZGV0ZXJtaW5hdGU6IHJvdy5pc1NvbWVTZWxlY3RlZFxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZjIuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgaW5zdGFuY2UudG9nZ2xlQWxsUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgY2hlY2tlZDogaW5zdGFuY2UuaXNBbGxSb3dzU2VsZWN0ZWQsXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBBbGwgUm93cyBTZWxlY3RlZCcsXG4gICAgICBpbmRldGVybWluYXRlOiBCb29sZWFuKCFpbnN0YW5jZS5pc0FsbFJvd3NTZWxlY3RlZCAmJiBPYmplY3Qua2V5cyhpbnN0YW5jZS5zdGF0ZS5zZWxlY3RlZFJvd0lkcykubGVuZ3RoKVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wcyhwcm9wcywgX3JlZjMpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmMy5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICBpbnN0YW5jZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgY2hlY2tlZDogaW5zdGFuY2UuaXNBbGxQYWdlUm93c1NlbGVjdGVkLFxuICAgICAgdGl0bGU6ICdUb2dnbGUgQWxsIEN1cnJlbnQgUGFnZSBSb3dzIFNlbGVjdGVkJyxcbiAgICAgIGluZGV0ZXJtaW5hdGU6IEJvb2xlYW4oIWluc3RhbmNlLmlzQWxsUGFnZVJvd3NTZWxlY3RlZCAmJiBpbnN0YW5jZS5wYWdlLnNvbWUoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgIHZhciBpZCA9IF9yZWY0LmlkO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RhdGUuc2VsZWN0ZWRSb3dJZHNbaWRdO1xuICAgICAgfSkpXG4gICAgfV07XG4gIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDgoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgc2VsZWN0ZWRSb3dJZHM6IHt9XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0U2VsZWN0ZWRSb3dzKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNlbGVjdGVkUm93SWRzOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuc2VsZWN0ZWRSb3dJZHMgfHwge31cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVBbGxSb3dzU2VsZWN0ZWQpIHtcbiAgICAgIHZhciBzZXRTZWxlY3RlZCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciBpc0FsbFJvd3NTZWxlY3RlZCA9IGluc3RhbmNlLmlzQWxsUm93c1NlbGVjdGVkLFxuICAgICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgICAgX2luc3RhbmNlJG5vbkdyb3VwZWRSID0gaW5zdGFuY2Uubm9uR3JvdXBlZFJvd3NCeUlkLFxuICAgICAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZCA9IF9pbnN0YW5jZSRub25Hcm91cGVkUiA9PT0gdm9pZCAwID8gcm93c0J5SWQgOiBfaW5zdGFuY2Ukbm9uR3JvdXBlZFI7XG4gICAgICB2YXIgc2VsZWN0QWxsID0gdHlwZW9mIHNldFNlbGVjdGVkICE9PSAndW5kZWZpbmVkJyA/IHNldFNlbGVjdGVkIDogIWlzQWxsUm93c1NlbGVjdGVkOyAvLyBPbmx5IHJlbW92ZS9hZGQgdGhlIHJvd3MgdGhhdCBhcmUgdmlzaWJsZSBvbiB0aGUgc2NyZWVuXG4gICAgICAvLyAgTGVhdmUgYWxsIHRoZSBvdGhlciByb3dzIHRoYXQgYXJlIHNlbGVjdGVkIGFsb25lLlxuXG4gICAgICB2YXIgc2VsZWN0ZWRSb3dJZHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zZWxlY3RlZFJvd0lkcyk7XG5cbiAgICAgIGlmIChzZWxlY3RBbGwpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobm9uR3JvdXBlZFJvd3NCeUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3dJZCkge1xuICAgICAgICAgIHNlbGVjdGVkUm93SWRzW3Jvd0lkXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmtleXMobm9uR3JvdXBlZFJvd3NCeUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3dJZCkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1tyb3dJZF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNlbGVjdGVkUm93SWRzOiBzZWxlY3RlZFJvd0lkc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZVJvd1NlbGVjdGVkKSB7XG4gICAgICB2YXIgaWQgPSBhY3Rpb24uaWQsXG4gICAgICAgICAgX3NldFNlbGVjdGVkID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIF9yb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkLFxuICAgICAgICAgIF9pbnN0YW5jZSRzZWxlY3RTdWJSbyA9IGluc3RhbmNlLnNlbGVjdFN1YlJvd3MsXG4gICAgICAgICAgc2VsZWN0U3ViUm93cyA9IF9pbnN0YW5jZSRzZWxlY3RTdWJSbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRzZWxlY3RTdWJSbyxcbiAgICAgICAgICBnZXRTdWJSb3dzID0gaW5zdGFuY2UuZ2V0U3ViUm93cztcbiAgICAgIHZhciBpc1NlbGVjdGVkID0gc3RhdGUuc2VsZWN0ZWRSb3dJZHNbaWRdO1xuICAgICAgdmFyIHNob3VsZEV4aXN0ID0gdHlwZW9mIF9zZXRTZWxlY3RlZCAhPT0gJ3VuZGVmaW5lZCcgPyBfc2V0U2VsZWN0ZWQgOiAhaXNTZWxlY3RlZDtcblxuICAgICAgaWYgKGlzU2VsZWN0ZWQgPT09IHNob3VsZEV4aXN0KSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1NlbGVjdGVkUm93SWRzID0gX2V4dGVuZHMoe30sIHN0YXRlLnNlbGVjdGVkUm93SWRzKTtcblxuICAgICAgdmFyIGhhbmRsZVJvd0J5SWQgPSBmdW5jdGlvbiBoYW5kbGVSb3dCeUlkKGlkKSB7XG4gICAgICAgIHZhciByb3cgPSBfcm93c0J5SWRbaWRdO1xuXG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICBpZiAoIXJvdy5pc0dyb3VwZWQpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRFeGlzdCkge1xuICAgICAgICAgICAgICBuZXdTZWxlY3RlZFJvd0lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG5ld1NlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZWN0U3ViUm93cyAmJiBnZXRTdWJSb3dzKHJvdykpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdWJSb3dzKHJvdykuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSb3dCeUlkKHJvdy5pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZVJvd0J5SWQoaWQpO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZFJvd0lkczogbmV3U2VsZWN0ZWRSb3dJZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkKSB7XG4gICAgICB2YXIgX3NldFNlbGVjdGVkMiA9IGFjdGlvbi52YWx1ZTtcblxuICAgICAgdmFyIHBhZ2UgPSBpbnN0YW5jZS5wYWdlLFxuICAgICAgICAgIF9yb3dzQnlJZDIgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgICBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8yID0gaW5zdGFuY2Uuc2VsZWN0U3ViUm93cyxcbiAgICAgICAgICBfc2VsZWN0U3ViUm93cyA9IF9pbnN0YW5jZSRzZWxlY3RTdWJSbzIgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8yLFxuICAgICAgICAgIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGluc3RhbmNlLmlzQWxsUGFnZVJvd3NTZWxlY3RlZCxcbiAgICAgICAgICBfZ2V0U3ViUm93cyA9IGluc3RhbmNlLmdldFN1YlJvd3M7XG5cbiAgICAgIHZhciBfc2VsZWN0QWxsID0gdHlwZW9mIF9zZXRTZWxlY3RlZDIgIT09ICd1bmRlZmluZWQnID8gX3NldFNlbGVjdGVkMiA6ICFpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQ7XG5cbiAgICAgIHZhciBfbmV3U2VsZWN0ZWRSb3dJZHMgPSBfZXh0ZW5kcyh7fSwgc3RhdGUuc2VsZWN0ZWRSb3dJZHMpO1xuXG4gICAgICB2YXIgX2hhbmRsZVJvd0J5SWQgPSBmdW5jdGlvbiBfaGFuZGxlUm93QnlJZChpZCkge1xuICAgICAgICB2YXIgcm93ID0gX3Jvd3NCeUlkMltpZF07XG5cbiAgICAgICAgaWYgKCFyb3cuaXNHcm91cGVkKSB7XG4gICAgICAgICAgaWYgKF9zZWxlY3RBbGwpIHtcbiAgICAgICAgICAgIF9uZXdTZWxlY3RlZFJvd0lkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgX25ld1NlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3NlbGVjdFN1YlJvd3MgJiYgX2dldFN1YlJvd3Mocm93KSkge1xuICAgICAgICAgIHJldHVybiBfZ2V0U3ViUm93cyhyb3cpLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIF9oYW5kbGVSb3dCeUlkKHJvdy5pZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHBhZ2UuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiBfaGFuZGxlUm93QnlJZChyb3cuaWQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNlbGVjdGVkUm93SWRzOiBfbmV3U2VsZWN0ZWRSb3dJZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDgoaW5zdGFuY2UpIHtcbiAgICB2YXIgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIHJvd3MgPSBpbnN0YW5jZS5yb3dzLFxuICAgICAgICBnZXRIb29rcyA9IGluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgX2luc3RhbmNlJG5vbkdyb3VwZWRSMiA9IGluc3RhbmNlLm5vbkdyb3VwZWRSb3dzQnlJZCxcbiAgICAgICAgbm9uR3JvdXBlZFJvd3NCeUlkID0gX2luc3RhbmNlJG5vbkdyb3VwZWRSMiA9PT0gdm9pZCAwID8gcm93c0J5SWQgOiBfaW5zdGFuY2Ukbm9uR3JvdXBlZFIyLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0U2UgPSBpbnN0YW5jZS5hdXRvUmVzZXRTZWxlY3RlZFJvd3MsXG4gICAgICAgIGF1dG9SZXNldFNlbGVjdGVkUm93cyA9IF9pbnN0YW5jZSRhdXRvUmVzZXRTZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRTZSxcbiAgICAgICAgc2VsZWN0ZWRSb3dJZHMgPSBpbnN0YW5jZS5zdGF0ZS5zZWxlY3RlZFJvd0lkcyxcbiAgICAgICAgX2luc3RhbmNlJHNlbGVjdFN1YlJvMyA9IGluc3RhbmNlLnNlbGVjdFN1YlJvd3MsXG4gICAgICAgIHNlbGVjdFN1YlJvd3MgPSBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8zID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJHNlbGVjdFN1YlJvMyxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgcGFnZSA9IGluc3RhbmNlLnBhZ2UsXG4gICAgICAgIGdldFN1YlJvd3MgPSBpbnN0YW5jZS5nZXRTdWJSb3dzO1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlRmlsdGVycycsICd1c2VHcm91cEJ5JywgJ3VzZVNvcnRCeScsICd1c2VFeHBhbmRlZCcsICd1c2VQYWdpbmF0aW9uJ10sICd1c2VSb3dTZWxlY3QnKTtcbiAgICB2YXIgc2VsZWN0ZWRGbGF0Um93cyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGVjdGVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpc1NlbGVjdGVkID0gc2VsZWN0U3ViUm93cyA/IGdldFJvd0lzU2VsZWN0ZWQocm93LCBzZWxlY3RlZFJvd0lkcywgZ2V0U3ViUm93cykgOiAhIXNlbGVjdGVkUm93SWRzW3Jvdy5pZF07XG4gICAgICAgIHJvdy5pc1NlbGVjdGVkID0gISFpc1NlbGVjdGVkO1xuICAgICAgICByb3cuaXNTb21lU2VsZWN0ZWQgPSBpc1NlbGVjdGVkID09PSBudWxsO1xuXG4gICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkRmxhdFJvd3M7XG4gICAgfSwgW3Jvd3MsIHNlbGVjdFN1YlJvd3MsIHNlbGVjdGVkUm93SWRzLCBnZXRTdWJSb3dzXSk7XG4gICAgdmFyIGlzQWxsUm93c1NlbGVjdGVkID0gQm9vbGVhbihPYmplY3Qua2V5cyhub25Hcm91cGVkUm93c0J5SWQpLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhzZWxlY3RlZFJvd0lkcykubGVuZ3RoKTtcbiAgICB2YXIgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gaXNBbGxSb3dzU2VsZWN0ZWQ7XG5cbiAgICBpZiAoaXNBbGxSb3dzU2VsZWN0ZWQpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhub25Hcm91cGVkUm93c0J5SWQpLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiAhc2VsZWN0ZWRSb3dJZHNbaWRdO1xuICAgICAgfSkpIHtcbiAgICAgICAgaXNBbGxSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzQWxsUm93c1NlbGVjdGVkKSB7XG4gICAgICBpZiAocGFnZSAmJiBwYWdlLmxlbmd0aCAmJiBwYWdlLnNvbWUoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgIHZhciBpZCA9IF9yZWY1LmlkO1xuICAgICAgICByZXR1cm4gIXNlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgIH0pKSB7XG4gICAgICAgIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRBdXRvUmVzZXRTZWxlY3RlZFJvd3MgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0U2VsZWN0ZWRSb3dzKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRTZWxlY3RlZFJvd3MoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFNlbGVjdGVkUm93c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIGRhdGFdKTtcbiAgICB2YXIgdG9nZ2xlQWxsUm93c1NlbGVjdGVkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgdG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciB0b2dnbGVSb3dTZWxlY3RlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChpZCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlUm93U2VsZWN0ZWQsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIHZhciBnZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgdmFyIGdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHNlbGVjdGVkRmxhdFJvd3M6IHNlbGVjdGVkRmxhdFJvd3MsXG4gICAgICBpc0FsbFJvd3NTZWxlY3RlZDogaXNBbGxSb3dzU2VsZWN0ZWQsXG4gICAgICBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQ6IGlzQWxsUGFnZVJvd3NTZWxlY3RlZCxcbiAgICAgIHRvZ2dsZVJvd1NlbGVjdGVkOiB0b2dnbGVSb3dTZWxlY3RlZCxcbiAgICAgIHRvZ2dsZUFsbFJvd3NTZWxlY3RlZDogdG9nZ2xlQWxsUm93c1NlbGVjdGVkLFxuICAgICAgZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHM6IGdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzLFxuICAgICAgZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzOiBnZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHMsXG4gICAgICB0b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkOiB0b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93JDMocm93LCBfcmVmNikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWY2Lmluc3RhbmNlO1xuXG4gICAgcm93LnRvZ2dsZVJvd1NlbGVjdGVkID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnRvZ2dsZVJvd1NlbGVjdGVkKHJvdy5pZCwgc2V0KTtcbiAgICB9O1xuXG4gICAgcm93LmdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihpbnN0YW5jZS5nZXRIb29rcygpLmdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgIHJvdzogcm93XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb3dJc1NlbGVjdGVkKHJvdywgc2VsZWN0ZWRSb3dJZHMsIGdldFN1YlJvd3MpIHtcbiAgICBpZiAoc2VsZWN0ZWRSb3dJZHNbcm93LmlkXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN1YlJvd3MgPSBnZXRTdWJSb3dzKHJvdyk7XG5cbiAgICBpZiAoc3ViUm93cyAmJiBzdWJSb3dzLmxlbmd0aCkge1xuICAgICAgdmFyIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgdmFyIHNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgc3ViUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJSb3cpIHtcbiAgICAgICAgLy8gQmFpbCBvdXQgZWFybHkgaWYgd2Uga25vdyBib3RoIG9mIHRoZXNlXG4gICAgICAgIGlmIChzb21lU2VsZWN0ZWQgJiYgIWFsbENoaWxkcmVuU2VsZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2V0Um93SXNTZWxlY3RlZChzdWJSb3csIHNlbGVjdGVkUm93SWRzLCBnZXRTdWJSb3dzKSkge1xuICAgICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhbGxDaGlsZHJlblNlbGVjdGVkID8gdHJ1ZSA6IHNvbWVTZWxlY3RlZCA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZGVmYXVsdEluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yID0gZnVuY3Rpb24gZGVmYXVsdEluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yKHJvdykge1xuICAgIHJldHVybiB7fTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA9IGZ1bmN0aW9uIGRlZmF1bHRJbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IoY2VsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfTsgLy8gQWN0aW9uc1xuXG5cbiAgYWN0aW9ucy5zZXRSb3dTdGF0ZSA9ICdzZXRSb3dTdGF0ZSc7XG4gIGFjdGlvbnMuc2V0Q2VsbFN0YXRlID0gJ3NldENlbGxTdGF0ZSc7XG4gIGFjdGlvbnMucmVzZXRSb3dTdGF0ZSA9ICdyZXNldFJvd1N0YXRlJztcbiAgdmFyIHVzZVJvd1N0YXRlID0gZnVuY3Rpb24gdXNlUm93U3RhdGUoaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQ5KTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDkpO1xuICAgIGhvb2tzLnByZXBhcmVSb3cucHVzaChwcmVwYXJlUm93JDQpO1xuICB9O1xuICB1c2VSb3dTdGF0ZS5wbHVnaW5OYW1lID0gJ3VzZVJvd1N0YXRlJztcblxuICBmdW5jdGlvbiByZWR1Y2VyJDkoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICB2YXIgX2luc3RhbmNlJGluaXRpYWxSb3dTID0gaW5zdGFuY2UuaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3IsXG4gICAgICAgIGluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yID0gX2luc3RhbmNlJGluaXRpYWxSb3dTID09PSB2b2lkIDAgPyBkZWZhdWx0SW5pdGlhbFJvd1N0YXRlQWNjZXNzb3IgOiBfaW5zdGFuY2UkaW5pdGlhbFJvd1MsXG4gICAgICAgIF9pbnN0YW5jZSRpbml0aWFsQ2VsbCA9IGluc3RhbmNlLmluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvcixcbiAgICAgICAgaW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yID0gX2luc3RhbmNlJGluaXRpYWxDZWxsID09PSB2b2lkIDAgPyBkZWZhdWx0SW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yIDogX2luc3RhbmNlJGluaXRpYWxDZWxsLFxuICAgICAgICByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkO1xuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHJvd1N0YXRlOiB7fVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFJvd1N0YXRlKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHJvd1N0YXRlOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUucm93U3RhdGUgfHwge31cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRSb3dTdGF0ZSkge1xuICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgdmFyIHJvd0lkID0gYWN0aW9uLnJvd0lkLFxuICAgICAgICAgIHZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIG9sZFJvd1N0YXRlID0gdHlwZW9mIHN0YXRlLnJvd1N0YXRlW3Jvd0lkXSAhPT0gJ3VuZGVmaW5lZCcgPyBzdGF0ZS5yb3dTdGF0ZVtyb3dJZF0gOiBpbml0aWFsUm93U3RhdGVBY2Nlc3Nvcihyb3dzQnlJZFtyb3dJZF0pO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICByb3dTdGF0ZTogX2V4dGVuZHMoe30sIHN0YXRlLnJvd1N0YXRlLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltyb3dJZF0gPSBmdW5jdGlvbmFsVXBkYXRlKHZhbHVlLCBvbGRSb3dTdGF0ZSksIF9leHRlbmRzMikpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0Q2VsbFN0YXRlKSB7XG4gICAgICB2YXIgX29sZFJvd1N0YXRlJGNlbGxTdGF0LCBfcm93c0J5SWQkX3Jvd0lkLCBfcm93c0J5SWQkX3Jvd0lkJGNlbGwsIF9leHRlbmRzMywgX2V4dGVuZHM0O1xuXG4gICAgICB2YXIgX3Jvd0lkID0gYWN0aW9uLnJvd0lkLFxuICAgICAgICAgIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIF92YWx1ZSA9IGFjdGlvbi52YWx1ZTtcblxuICAgICAgdmFyIF9vbGRSb3dTdGF0ZSA9IHR5cGVvZiBzdGF0ZS5yb3dTdGF0ZVtfcm93SWRdICE9PSAndW5kZWZpbmVkJyA/IHN0YXRlLnJvd1N0YXRlW19yb3dJZF0gOiBpbml0aWFsUm93U3RhdGVBY2Nlc3Nvcihyb3dzQnlJZFtfcm93SWRdKTtcblxuICAgICAgdmFyIG9sZENlbGxTdGF0ZSA9IHR5cGVvZiAoX29sZFJvd1N0YXRlID09IG51bGwgPyB2b2lkIDAgOiAoX29sZFJvd1N0YXRlJGNlbGxTdGF0ID0gX29sZFJvd1N0YXRlLmNlbGxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vbGRSb3dTdGF0ZSRjZWxsU3RhdFtjb2x1bW5JZF0pICE9PSAndW5kZWZpbmVkJyA/IF9vbGRSb3dTdGF0ZS5jZWxsU3RhdGVbY29sdW1uSWRdIDogaW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yKChfcm93c0J5SWQkX3Jvd0lkID0gcm93c0J5SWRbX3Jvd0lkXSkgPT0gbnVsbCA/IHZvaWQgMCA6IChfcm93c0J5SWQkX3Jvd0lkJGNlbGwgPSBfcm93c0J5SWQkX3Jvd0lkLmNlbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX3Jvd3NCeUlkJF9yb3dJZCRjZWxsLmZpbmQoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcm93U3RhdGU6IF9leHRlbmRzKHt9LCBzdGF0ZS5yb3dTdGF0ZSwgKF9leHRlbmRzNCA9IHt9LCBfZXh0ZW5kczRbX3Jvd0lkXSA9IF9leHRlbmRzKHt9LCBfb2xkUm93U3RhdGUsIHtcbiAgICAgICAgICBjZWxsU3RhdGU6IF9leHRlbmRzKHt9LCBfb2xkUm93U3RhdGUuY2VsbFN0YXRlIHx8IHt9LCAoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tjb2x1bW5JZF0gPSBmdW5jdGlvbmFsVXBkYXRlKF92YWx1ZSwgb2xkQ2VsbFN0YXRlKSwgX2V4dGVuZHMzKSlcbiAgICAgICAgfSksIF9leHRlbmRzNCkpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQ5KGluc3RhbmNlKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRhdXRvUmVzZXRSbyA9IGluc3RhbmNlLmF1dG9SZXNldFJvd1N0YXRlLFxuICAgICAgICBhdXRvUmVzZXRSb3dTdGF0ZSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRSbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRSbyxcbiAgICAgICAgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2g7XG4gICAgdmFyIHNldFJvd1N0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJvd0lkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRSb3dTdGF0ZSxcbiAgICAgICAgcm93SWQ6IHJvd0lkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciBzZXRDZWxsU3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAocm93SWQsIGNvbHVtbklkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRDZWxsU3RhdGUsXG4gICAgICAgIHJvd0lkOiByb3dJZCxcbiAgICAgICAgY29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciBnZXRBdXRvUmVzZXRSb3dTdGF0ZSA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRSb3dTdGF0ZSk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0Um93U3RhdGUoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFJvd1N0YXRlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkYXRhXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgc2V0Um93U3RhdGU6IHNldFJvd1N0YXRlLFxuICAgICAgc2V0Q2VsbFN0YXRlOiBzZXRDZWxsU3RhdGVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVSb3ckNChyb3csIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgIHZhciBfaW5zdGFuY2UkaW5pdGlhbFJvd1MyID0gaW5zdGFuY2UuaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3IsXG4gICAgICAgIGluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yID0gX2luc3RhbmNlJGluaXRpYWxSb3dTMiA9PT0gdm9pZCAwID8gZGVmYXVsdEluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yIDogX2luc3RhbmNlJGluaXRpYWxSb3dTMixcbiAgICAgICAgX2luc3RhbmNlJGluaXRpYWxDZWxsMiA9IGluc3RhbmNlLmluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvcixcbiAgICAgICAgaW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yID0gX2luc3RhbmNlJGluaXRpYWxDZWxsMiA9PT0gdm9pZCAwID8gZGVmYXVsdEluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA6IF9pbnN0YW5jZSRpbml0aWFsQ2VsbDIsXG4gICAgICAgIHJvd1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUucm93U3RhdGU7XG5cbiAgICBpZiAocm93KSB7XG4gICAgICByb3cuc3RhdGUgPSB0eXBlb2Ygcm93U3RhdGVbcm93LmlkXSAhPT0gJ3VuZGVmaW5lZCcgPyByb3dTdGF0ZVtyb3cuaWRdIDogaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3Iocm93KTtcblxuICAgICAgcm93LnNldFN0YXRlID0gZnVuY3Rpb24gKHVwZGF0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnNldFJvd1N0YXRlKHJvdy5pZCwgdXBkYXRlcik7XG4gICAgICB9O1xuXG4gICAgICByb3cuY2VsbHMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICBpZiAoIXJvdy5zdGF0ZS5jZWxsU3RhdGUpIHtcbiAgICAgICAgICByb3cuc3RhdGUuY2VsbFN0YXRlID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBjZWxsLnN0YXRlID0gdHlwZW9mIHJvdy5zdGF0ZS5jZWxsU3RhdGVbY2VsbC5jb2x1bW4uaWRdICE9PSAndW5kZWZpbmVkJyA/IHJvdy5zdGF0ZS5jZWxsU3RhdGVbY2VsbC5jb2x1bW4uaWRdIDogaW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yKGNlbGwpO1xuXG4gICAgICAgIGNlbGwuc2V0U3RhdGUgPSBmdW5jdGlvbiAodXBkYXRlcikge1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5zZXRDZWxsU3RhdGUocm93LmlkLCBjZWxsLmNvbHVtbi5pZCwgdXBkYXRlcik7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBhY3Rpb25zLnJlc2V0Q29sdW1uT3JkZXIgPSAncmVzZXRDb2x1bW5PcmRlcic7XG4gIGFjdGlvbnMuc2V0Q29sdW1uT3JkZXIgPSAnc2V0Q29sdW1uT3JkZXInO1xuICB2YXIgdXNlQ29sdW1uT3JkZXIgPSBmdW5jdGlvbiB1c2VDb2x1bW5PcmRlcihob29rcykge1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJGEpO1xuICAgIGhvb2tzLnZpc2libGVDb2x1bW5zRGVwcy5wdXNoKGZ1bmN0aW9uIChkZXBzLCBfcmVmKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbaW5zdGFuY2Uuc3RhdGUuY29sdW1uT3JkZXJdKTtcbiAgICB9KTtcbiAgICBob29rcy52aXNpYmxlQ29sdW1ucy5wdXNoKHZpc2libGVDb2x1bW5zJDIpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkYSk7XG4gIH07XG4gIHVzZUNvbHVtbk9yZGVyLnBsdWdpbk5hbWUgPSAndXNlQ29sdW1uT3JkZXInO1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkYShzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBjb2x1bW5PcmRlcjogW11cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRDb2x1bW5PcmRlcikge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5PcmRlcjogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLmNvbHVtbk9yZGVyIHx8IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0Q29sdW1uT3JkZXIpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgY29sdW1uT3JkZXI6IGZ1bmN0aW9uYWxVcGRhdGUoYWN0aW9uLmNvbHVtbk9yZGVyLCBzdGF0ZS5jb2x1bW5PcmRlcilcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGVDb2x1bW5zJDIoY29sdW1ucywgX3JlZjIpIHtcbiAgICB2YXIgY29sdW1uT3JkZXIgPSBfcmVmMi5pbnN0YW5jZS5zdGF0ZS5jb2x1bW5PcmRlcjtcblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIG9yZGVyLCByZXR1cm4gdGhlIG5vcm1hbCBjb2x1bW5zXG4gICAgaWYgKCFjb2x1bW5PcmRlciB8fCAhY29sdW1uT3JkZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29sdW1ucztcbiAgICB9XG5cbiAgICB2YXIgY29sdW1uT3JkZXJDb3B5ID0gW10uY29uY2F0KGNvbHVtbk9yZGVyKTsgLy8gSWYgdGhlcmUgaXMgYW4gb3JkZXIsIG1ha2UgYSBjb3B5IG9mIHRoZSBjb2x1bW5zXG5cbiAgICB2YXIgY29sdW1uc0NvcHkgPSBbXS5jb25jYXQoY29sdW1ucyk7IC8vIEFuZCBtYWtlIGEgbmV3IG9yZGVyZWQgYXJyYXkgb2YgdGhlIGNvbHVtbnNcblxuICAgIHZhciBjb2x1bW5zSW5PcmRlciA9IFtdOyAvLyBMb29wIG92ZXIgdGhlIGNvbHVtbnMgYW5kIHBsYWNlIHRoZW0gaW4gb3JkZXIgaW50byB0aGUgbmV3IGFycmF5XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciB0YXJnZXRDb2x1bW5JZCA9IGNvbHVtbk9yZGVyQ29weS5zaGlmdCgpO1xuICAgICAgdmFyIGZvdW5kSW5kZXggPSBjb2x1bW5zQ29weS5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IHRhcmdldENvbHVtbklkO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChmb3VuZEluZGV4ID4gLTEpIHtcbiAgICAgICAgY29sdW1uc0luT3JkZXIucHVzaChjb2x1bW5zQ29weS5zcGxpY2UoZm91bmRJbmRleCwgMSlbMF0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aGlsZSAoY29sdW1uc0NvcHkubGVuZ3RoICYmIGNvbHVtbk9yZGVyQ29weS5sZW5ndGgpIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfSAvLyBJZiB0aGVyZSBhcmUgYW55IGNvbHVtbnMgbGVmdCwgYWRkIHRoZW0gdG8gdGhlIGVuZFxuXG5cbiAgICByZXR1cm4gW10uY29uY2F0KGNvbHVtbnNJbk9yZGVyLCBjb2x1bW5zQ29weSk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSRhKGluc3RhbmNlKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2g7XG4gICAgaW5zdGFuY2Uuc2V0Q29sdW1uT3JkZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29sdW1uT3JkZXIpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0Q29sdW1uT3JkZXIsXG4gICAgICAgIGNvbHVtbk9yZGVyOiBjb2x1bW5PcmRlclxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gIH1cblxuICBkZWZhdWx0Q29sdW1uLmNhblJlc2l6ZSA9IHRydWU7IC8vIEFjdGlvbnNcblxuICBhY3Rpb25zLmNvbHVtblN0YXJ0UmVzaXppbmcgPSAnY29sdW1uU3RhcnRSZXNpemluZyc7XG4gIGFjdGlvbnMuY29sdW1uUmVzaXppbmcgPSAnY29sdW1uUmVzaXppbmcnO1xuICBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZyA9ICdjb2x1bW5Eb25lUmVzaXppbmcnO1xuICBhY3Rpb25zLnJlc2V0UmVzaXplID0gJ3Jlc2V0UmVzaXplJztcbiAgdmFyIHVzZVJlc2l6ZUNvbHVtbnMgPSBmdW5jdGlvbiB1c2VSZXNpemVDb2x1bW5zKGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0UmVzaXplclByb3BzID0gW2RlZmF1bHRHZXRSZXNpemVyUHJvcHNdO1xuICAgIGhvb2tzLmdldEhlYWRlclByb3BzLnB1c2goe1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH1cbiAgICB9KTtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciRiKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJGIpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucy5wdXNoKHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyQxKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFJlc2l6ZXJQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRSZXNpemVyUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgICBoZWFkZXIgPSBfcmVmLmhlYWRlcjtcbiAgICB2YXIgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaDtcblxuICAgIHZhciBvblJlc2l6ZVN0YXJ0ID0gZnVuY3Rpb24gb25SZXNpemVTdGFydChlLCBoZWFkZXIpIHtcbiAgICAgIHZhciBpc1RvdWNoRXZlbnQgPSBmYWxzZTtcblxuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIC8vIGxldHMgbm90IHJlc3BvbmQgdG8gbXVsdGlwbGUgdG91Y2hlcyAoZS5nLiAyIG9yIDMgZmluZ2VycylcbiAgICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzVG91Y2hFdmVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoZWFkZXJzVG9SZXNpemUgPSBnZXRMZWFmSGVhZGVycyhoZWFkZXIpO1xuICAgICAgdmFyIGhlYWRlcklkV2lkdGhzID0gaGVhZGVyc1RvUmVzaXplLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gW2QuaWQsIGQudG90YWxXaWR0aF07XG4gICAgICB9KTtcbiAgICAgIHZhciBjbGllbnRYID0gaXNUb3VjaEV2ZW50ID8gTWF0aC5yb3VuZChlLnRvdWNoZXNbMF0uY2xpZW50WCkgOiBlLmNsaWVudFg7XG4gICAgICB2YXIgcmFmO1xuICAgICAgdmFyIG1vc3RSZWNlbnRDbGllbnRYO1xuXG4gICAgICB2YXIgZGlzcGF0Y2hFbmQgPSBmdW5jdGlvbiBkaXNwYXRjaEVuZCgpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG4gICAgICAgIHJhZiA9IG51bGw7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZ1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkaXNwYXRjaE1vdmUgPSBmdW5jdGlvbiBkaXNwYXRjaE1vdmUoKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgICAgICByYWYgPSBudWxsO1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5jb2x1bW5SZXNpemluZyxcbiAgICAgICAgICBjbGllbnRYOiBtb3N0UmVjZW50Q2xpZW50WFxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBzY2hlZHVsZURpc3BhdGNoTW92ZU9uTmV4dEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gc2NoZWR1bGVEaXNwYXRjaE1vdmVPbk5leHRBbmltYXRpb25GcmFtZShjbGllbnRYUG9zKSB7XG4gICAgICAgIG1vc3RSZWNlbnRDbGllbnRYID0gY2xpZW50WFBvcztcblxuICAgICAgICBpZiAoIXJhZikge1xuICAgICAgICAgIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZGlzcGF0Y2hNb3ZlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGhhbmRsZXJzQW5kRXZlbnRzID0ge1xuICAgICAgICBtb3VzZToge1xuICAgICAgICAgIG1vdmVFdmVudDogJ21vdXNlbW92ZScsXG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGZ1bmN0aW9uIG1vdmVIYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZURpc3BhdGNoTW92ZU9uTmV4dEFuaW1hdGlvbkZyYW1lKGUuY2xpZW50WCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cEV2ZW50OiAnbW91c2V1cCcsXG4gICAgICAgICAgdXBIYW5kbGVyOiBmdW5jdGlvbiB1cEhhbmRsZXIoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcnNBbmRFdmVudHMubW91c2UubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGhhbmRsZXJzQW5kRXZlbnRzLm1vdXNlLnVwSGFuZGxlcik7XG4gICAgICAgICAgICBkaXNwYXRjaEVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG91Y2g6IHtcbiAgICAgICAgICBtb3ZlRXZlbnQ6ICd0b3VjaG1vdmUnLFxuICAgICAgICAgIG1vdmVIYW5kbGVyOiBmdW5jdGlvbiBtb3ZlSGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NoZWR1bGVEaXNwYXRjaE1vdmVPbk5leHRBbmltYXRpb25GcmFtZShlLnRvdWNoZXNbMF0uY2xpZW50WCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cEV2ZW50OiAndG91Y2hlbmQnLFxuICAgICAgICAgIHVwSGFuZGxlcjogZnVuY3Rpb24gdXBIYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlcnNBbmRFdmVudHMudG91Y2gubW92ZUV2ZW50LCBoYW5kbGVyc0FuZEV2ZW50cy50b3VjaC5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZXJzQW5kRXZlbnRzLnRvdWNoLnVwRXZlbnQsIGhhbmRsZXJzQW5kRXZlbnRzLnRvdWNoLm1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgIGRpc3BhdGNoRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGV2ZW50cyA9IGlzVG91Y2hFdmVudCA/IGhhbmRsZXJzQW5kRXZlbnRzLnRvdWNoIDogaGFuZGxlcnNBbmRFdmVudHMubW91c2U7XG4gICAgICB2YXIgcGFzc2l2ZUlmU3VwcG9ydGVkID0gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkgPyB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9IDogZmFsc2U7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5tb3ZlRXZlbnQsIGV2ZW50cy5tb3ZlSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzLnVwRXZlbnQsIGV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuY29sdW1uU3RhcnRSZXNpemluZyxcbiAgICAgICAgY29sdW1uSWQ6IGhlYWRlci5pZCxcbiAgICAgICAgY29sdW1uV2lkdGg6IGhlYWRlci50b3RhbFdpZHRoLFxuICAgICAgICBoZWFkZXJJZFdpZHRoczogaGVhZGVySWRXaWR0aHMsXG4gICAgICAgIGNsaWVudFg6IGNsaWVudFhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgICByZXR1cm4gZS5wZXJzaXN0KCkgfHwgb25SZXNpemVTdGFydChlLCBoZWFkZXIpO1xuICAgICAgfSxcbiAgICAgIG9uVG91Y2hTdGFydDogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICAgICAgcmV0dXJuIGUucGVyc2lzdCgpIHx8IG9uUmVzaXplU3RhcnQoZSwgaGVhZGVyKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdjb2wtcmVzaXplJ1xuICAgICAgfSxcbiAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICByb2xlOiAnc2VwYXJhdG9yJ1xuICAgIH1dO1xuICB9O1xuXG4gIHVzZVJlc2l6ZUNvbHVtbnMucGx1Z2luTmFtZSA9ICd1c2VSZXNpemVDb2x1bW5zJztcblxuICBmdW5jdGlvbiByZWR1Y2VyJGIoc3RhdGUsIGFjdGlvbikge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBjb2x1bW5SZXNpemluZzoge1xuICAgICAgICAgIGNvbHVtbldpZHRoczoge31cbiAgICAgICAgfVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFJlc2l6ZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5SZXNpemluZzoge1xuICAgICAgICAgIGNvbHVtbldpZHRoczoge31cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtblN0YXJ0UmVzaXppbmcpIHtcbiAgICAgIHZhciBjbGllbnRYID0gYWN0aW9uLmNsaWVudFgsXG4gICAgICAgICAgY29sdW1uSWQgPSBhY3Rpb24uY29sdW1uSWQsXG4gICAgICAgICAgY29sdW1uV2lkdGggPSBhY3Rpb24uY29sdW1uV2lkdGgsXG4gICAgICAgICAgaGVhZGVySWRXaWR0aHMgPSBhY3Rpb24uaGVhZGVySWRXaWR0aHM7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGNvbHVtblJlc2l6aW5nOiBfZXh0ZW5kcyh7fSwgc3RhdGUuY29sdW1uUmVzaXppbmcsIHtcbiAgICAgICAgICBzdGFydFg6IGNsaWVudFgsXG4gICAgICAgICAgaGVhZGVySWRXaWR0aHM6IGhlYWRlcklkV2lkdGhzLFxuICAgICAgICAgIGNvbHVtbldpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBjb2x1bW5JZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtblJlc2l6aW5nKSB7XG4gICAgICB2YXIgX2NsaWVudFggPSBhY3Rpb24uY2xpZW50WDtcblxuICAgICAgdmFyIF9zdGF0ZSRjb2x1bW5SZXNpemluZyA9IHN0YXRlLmNvbHVtblJlc2l6aW5nLFxuICAgICAgICAgIHN0YXJ0WCA9IF9zdGF0ZSRjb2x1bW5SZXNpemluZy5zdGFydFgsXG4gICAgICAgICAgX2NvbHVtbldpZHRoID0gX3N0YXRlJGNvbHVtblJlc2l6aW5nLmNvbHVtbldpZHRoLFxuICAgICAgICAgIF9zdGF0ZSRjb2x1bW5SZXNpemluZzIgPSBfc3RhdGUkY29sdW1uUmVzaXppbmcuaGVhZGVySWRXaWR0aHMsXG4gICAgICAgICAgX2hlYWRlcklkV2lkdGhzID0gX3N0YXRlJGNvbHVtblJlc2l6aW5nMiA9PT0gdm9pZCAwID8gW10gOiBfc3RhdGUkY29sdW1uUmVzaXppbmcyO1xuXG4gICAgICB2YXIgZGVsdGFYID0gX2NsaWVudFggLSBzdGFydFg7XG4gICAgICB2YXIgcGVyY2VudGFnZURlbHRhWCA9IGRlbHRhWCAvIF9jb2x1bW5XaWR0aDtcbiAgICAgIHZhciBuZXdDb2x1bW5XaWR0aHMgPSB7fTtcblxuICAgICAgX2hlYWRlcklkV2lkdGhzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciBoZWFkZXJJZCA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgaGVhZGVyV2lkdGggPSBfcmVmMlsxXTtcbiAgICAgICAgbmV3Q29sdW1uV2lkdGhzW2hlYWRlcklkXSA9IE1hdGgubWF4KGhlYWRlcldpZHRoICsgaGVhZGVyV2lkdGggKiBwZXJjZW50YWdlRGVsdGFYLCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGNvbHVtblJlc2l6aW5nOiBfZXh0ZW5kcyh7fSwgc3RhdGUuY29sdW1uUmVzaXppbmcsIHtcbiAgICAgICAgICBjb2x1bW5XaWR0aHM6IF9leHRlbmRzKHt9LCBzdGF0ZS5jb2x1bW5SZXNpemluZy5jb2x1bW5XaWR0aHMsIHt9LCBuZXdDb2x1bW5XaWR0aHMpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuY29sdW1uRG9uZVJlc2l6aW5nKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGNvbHVtblJlc2l6aW5nOiBfZXh0ZW5kcyh7fSwgc3RhdGUuY29sdW1uUmVzaXppbmcsIHtcbiAgICAgICAgICBzdGFydFg6IG51bGwsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogbnVsbFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyQxID0gZnVuY3Rpb24gdXNlSW5zdGFuY2VCZWZvcmVEaW1lbnNpb25zKGluc3RhbmNlKSB7XG4gICAgdmFyIGZsYXRIZWFkZXJzID0gaW5zdGFuY2UuZmxhdEhlYWRlcnMsXG4gICAgICAgIGRpc2FibGVSZXNpemluZyA9IGluc3RhbmNlLmRpc2FibGVSZXNpemluZyxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgY29sdW1uUmVzaXppbmcgPSBpbnN0YW5jZS5zdGF0ZS5jb2x1bW5SZXNpemluZztcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIGZsYXRIZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgdmFyIGNhblJlc2l6ZSA9IGdldEZpcnN0RGVmaW5lZChoZWFkZXIuZGlzYWJsZVJlc2l6aW5nID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIGRpc2FibGVSZXNpemluZyA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIGhlYWRlci5jYW5SZXNpemUgPSBjYW5SZXNpemU7XG4gICAgICBoZWFkZXIud2lkdGggPSBjb2x1bW5SZXNpemluZy5jb2x1bW5XaWR0aHNbaGVhZGVyLmlkXSB8fCBoZWFkZXIub3JpZ2luYWxXaWR0aCB8fCBoZWFkZXIud2lkdGg7XG4gICAgICBoZWFkZXIuaXNSZXNpemluZyA9IGNvbHVtblJlc2l6aW5nLmlzUmVzaXppbmdDb2x1bW4gPT09IGhlYWRlci5pZDtcblxuICAgICAgaWYgKGNhblJlc2l6ZSkge1xuICAgICAgICBoZWFkZXIuZ2V0UmVzaXplclByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRSZXNpemVyUHJvcHMsIHtcbiAgICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICBoZWFkZXI6IGhlYWRlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSRiKGluc3RhbmNlKSB7XG4gICAgdmFyIHBsdWdpbnMgPSBpbnN0YW5jZS5wbHVnaW5zLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0UmUgPSBpbnN0YW5jZS5hdXRvUmVzZXRSZXNpemUsXG4gICAgICAgIGF1dG9SZXNldFJlc2l6ZSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRSZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRSZSxcbiAgICAgICAgY29sdW1ucyA9IGluc3RhbmNlLmNvbHVtbnM7XG4gICAgZW5zdXJlUGx1Z2luT3JkZXIocGx1Z2lucywgWyd1c2VBYnNvbHV0ZUxheW91dCddLCAndXNlUmVzaXplQ29sdW1ucycpO1xuICAgIHZhciBnZXRBdXRvUmVzZXRSZXNpemUgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0UmVzaXplKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRSZXNpemUoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFJlc2l6ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbY29sdW1uc10pO1xuICAgIHZhciByZXNldFJlc2l6aW5nID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFJlc2l6ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcmVzZXRSZXNpemluZzogcmVzZXRSZXNpemluZ1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGVhZkhlYWRlcnMoaGVhZGVyKSB7XG4gICAgdmFyIGxlYWZIZWFkZXJzID0gW107XG5cbiAgICB2YXIgcmVjdXJzZUhlYWRlciA9IGZ1bmN0aW9uIHJlY3Vyc2VIZWFkZXIoaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyLmNvbHVtbnMgJiYgaGVhZGVyLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgIGhlYWRlci5jb2x1bW5zLm1hcChyZWN1cnNlSGVhZGVyKTtcbiAgICAgIH1cblxuICAgICAgbGVhZkhlYWRlcnMucHVzaChoZWFkZXIpO1xuICAgIH07XG5cbiAgICByZWN1cnNlSGVhZGVyKGhlYWRlcik7XG4gICAgcmV0dXJuIGxlYWZIZWFkZXJzO1xuICB9XG5cbiAgdmFyIGNlbGxTdHlsZXMgPSB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAwXG4gIH07XG4gIHZhciB1c2VBYnNvbHV0ZUxheW91dCA9IGZ1bmN0aW9uIHVzZUFic29sdXRlTGF5b3V0KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0VGFibGVCb2R5UHJvcHMucHVzaChnZXRSb3dTdHlsZXMpO1xuICAgIGhvb2tzLmdldFJvd1Byb3BzLnB1c2goZ2V0Um93U3R5bGVzKTtcbiAgICBob29rcy5nZXRIZWFkZXJHcm91cFByb3BzLnB1c2goZ2V0Um93U3R5bGVzKTtcbiAgICBob29rcy5nZXRGb290ZXJHcm91cFByb3BzLnB1c2goZ2V0Um93U3R5bGVzKTtcbiAgICBob29rcy5nZXRIZWFkZXJQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZikge1xuICAgICAgdmFyIGNvbHVtbiA9IF9yZWYuY29sdW1uO1xuICAgICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGNlbGxTdHlsZXMsIHtcbiAgICAgICAgICBsZWZ0OiBjb2x1bW4udG90YWxMZWZ0ICsgXCJweFwiLFxuICAgICAgICAgIHdpZHRoOiBjb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgICB9KVxuICAgICAgfV07XG4gICAgfSk7XG4gICAgaG9va3MuZ2V0Q2VsbFByb3BzLnB1c2goZnVuY3Rpb24gKHByb3BzLCBfcmVmMikge1xuICAgICAgdmFyIGNlbGwgPSBfcmVmMi5jZWxsO1xuICAgICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGNlbGxTdHlsZXMsIHtcbiAgICAgICAgICBsZWZ0OiBjZWxsLmNvbHVtbi50b3RhbExlZnQgKyBcInB4XCIsXG4gICAgICAgICAgd2lkdGg6IGNlbGwuY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICAgIGhvb2tzLmdldEZvb3RlclByb3BzLnB1c2goZnVuY3Rpb24gKHByb3BzLCBfcmVmMykge1xuICAgICAgdmFyIGNvbHVtbiA9IF9yZWYzLmNvbHVtbjtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzLCB7XG4gICAgICAgICAgbGVmdDogY29sdW1uLnRvdGFsTGVmdCArIFwicHhcIixcbiAgICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICB9O1xuICB1c2VBYnNvbHV0ZUxheW91dC5wbHVnaW5OYW1lID0gJ3VzZUFic29sdXRlTGF5b3V0JztcblxuICB2YXIgZ2V0Um93U3R5bGVzID0gZnVuY3Rpb24gZ2V0Um93U3R5bGVzKHByb3BzLCBfcmVmNCkge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWY0Lmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB3aWR0aDogaW5zdGFuY2UudG90YWxDb2x1bW5zV2lkdGggKyBcInB4XCJcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICB2YXIgY2VsbFN0eWxlcyQxID0ge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG4gIH07XG5cbiAgdmFyIGdldFJvd1N0eWxlcyQxID0gZnVuY3Rpb24gZ2V0Um93U3R5bGVzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIHdpZHRoOiBpbnN0YW5jZS50b3RhbENvbHVtbnNXaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciB1c2VCbG9ja0xheW91dCA9IGZ1bmN0aW9uIHVzZUJsb2NrTGF5b3V0KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0Um93UHJvcHMucHVzaChnZXRSb3dTdHlsZXMkMSk7XG4gICAgaG9va3MuZ2V0SGVhZGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyQxKTtcbiAgICBob29rcy5nZXRGb290ZXJHcm91cFByb3BzLnB1c2goZ2V0Um93U3R5bGVzJDEpO1xuICAgIGhvb2tzLmdldEhlYWRlclByb3BzLnB1c2goZnVuY3Rpb24gKHByb3BzLCBfcmVmMikge1xuICAgICAgdmFyIGNvbHVtbiA9IF9yZWYyLmNvbHVtbjtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzJDEsIHtcbiAgICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICAgIGhvb2tzLmdldENlbGxQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZjMpIHtcbiAgICAgIHZhciBjZWxsID0gX3JlZjMuY2VsbDtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzJDEsIHtcbiAgICAgICAgICB3aWR0aDogY2VsbC5jb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgICB9KVxuICAgICAgfV07XG4gICAgfSk7XG4gICAgaG9va3MuZ2V0Rm9vdGVyUHJvcHMucHVzaChmdW5jdGlvbiAocHJvcHMsIF9yZWY0KSB7XG4gICAgICB2YXIgY29sdW1uID0gX3JlZjQuY29sdW1uO1xuICAgICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGNlbGxTdHlsZXMkMSwge1xuICAgICAgICAgIHdpZHRoOiBjb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgICB9KVxuICAgICAgfV07XG4gICAgfSk7XG4gIH07XG4gIHVzZUJsb2NrTGF5b3V0LnBsdWdpbk5hbWUgPSAndXNlQmxvY2tMYXlvdXQnO1xuXG4gIGZ1bmN0aW9uIHVzZUZsZXhMYXlvdXQoaG9va3MpIHtcbiAgICBob29rcy5nZXRUYWJsZVByb3BzLnB1c2goZ2V0VGFibGVQcm9wcyk7XG4gICAgaG9va3MuZ2V0Um93UHJvcHMucHVzaChnZXRSb3dTdHlsZXMkMik7XG4gICAgaG9va3MuZ2V0SGVhZGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyQyKTtcbiAgICBob29rcy5nZXRGb290ZXJHcm91cFByb3BzLnB1c2goZ2V0Um93U3R5bGVzJDIpO1xuICAgIGhvb2tzLmdldEhlYWRlclByb3BzLnB1c2goZ2V0SGVhZGVyUHJvcHMpO1xuICAgIGhvb2tzLmdldENlbGxQcm9wcy5wdXNoKGdldENlbGxQcm9wcyk7XG4gICAgaG9va3MuZ2V0Rm9vdGVyUHJvcHMucHVzaChnZXRGb290ZXJQcm9wcyk7XG4gIH1cbiAgdXNlRmxleExheW91dC5wbHVnaW5OYW1lID0gJ3VzZUZsZXhMYXlvdXQnO1xuXG4gIHZhciBnZXRUYWJsZVByb3BzID0gZnVuY3Rpb24gZ2V0VGFibGVQcm9wcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbWluV2lkdGg6IGluc3RhbmNlLnRvdGFsQ29sdW1uc01pbldpZHRoICsgXCJweFwiXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGdldFJvd1N0eWxlcyQyID0gZnVuY3Rpb24gZ2V0Um93U3R5bGVzKHByb3BzLCBfcmVmMikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYyLmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleDogJzEgMCBhdXRvJyxcbiAgICAgICAgbWluV2lkdGg6IGluc3RhbmNlLnRvdGFsQ29sdW1uc01pbldpZHRoICsgXCJweFwiXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGdldEhlYWRlclByb3BzID0gZnVuY3Rpb24gZ2V0SGVhZGVyUHJvcHMocHJvcHMsIF9yZWYzKSB7XG4gICAgdmFyIGNvbHVtbiA9IF9yZWYzLmNvbHVtbjtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZmxleDogY29sdW1uLnRvdGFsRmxleFdpZHRoID8gY29sdW1uLnRvdGFsRmxleFdpZHRoICsgXCIgMCBhdXRvXCIgOiB1bmRlZmluZWQsXG4gICAgICAgIG1pbldpZHRoOiBjb2x1bW4udG90YWxNaW5XaWR0aCArIFwicHhcIixcbiAgICAgICAgd2lkdGg6IGNvbHVtbi50b3RhbFdpZHRoICsgXCJweFwiXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGdldENlbGxQcm9wcyA9IGZ1bmN0aW9uIGdldENlbGxQcm9wcyhwcm9wcywgX3JlZjQpIHtcbiAgICB2YXIgY2VsbCA9IF9yZWY0LmNlbGw7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGZsZXg6IGNlbGwuY29sdW1uLnRvdGFsRmxleFdpZHRoICsgXCIgMCBhdXRvXCIsXG4gICAgICAgIG1pbldpZHRoOiBjZWxsLmNvbHVtbi50b3RhbE1pbldpZHRoICsgXCJweFwiLFxuICAgICAgICB3aWR0aDogY2VsbC5jb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRGb290ZXJQcm9wcyA9IGZ1bmN0aW9uIGdldEZvb3RlclByb3BzKHByb3BzLCBfcmVmNSkge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmNS5jb2x1bW47XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGZsZXg6IGNvbHVtbi50b3RhbEZsZXhXaWR0aCA/IGNvbHVtbi50b3RhbEZsZXhXaWR0aCArIFwiIDAgYXV0b1wiIDogdW5kZWZpbmVkLFxuICAgICAgICBtaW5XaWR0aDogY29sdW1uLnRvdGFsTWluV2lkdGggKyBcInB4XCIsXG4gICAgICAgIHdpZHRoOiBjb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIGFjdGlvbnMuY29sdW1uU3RhcnRSZXNpemluZyA9ICdjb2x1bW5TdGFydFJlc2l6aW5nJztcbiAgYWN0aW9ucy5jb2x1bW5SZXNpemluZyA9ICdjb2x1bW5SZXNpemluZyc7XG4gIGFjdGlvbnMuY29sdW1uRG9uZVJlc2l6aW5nID0gJ2NvbHVtbkRvbmVSZXNpemluZyc7XG4gIGFjdGlvbnMucmVzZXRSZXNpemUgPSAncmVzZXRSZXNpemUnO1xuICBmdW5jdGlvbiB1c2VHcmlkTGF5b3V0KGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkYyk7XG4gICAgaG9va3MuZ2V0VGFibGVQcm9wcy5wdXNoKGdldFRhYmxlUHJvcHMkMSk7XG4gICAgaG9va3MuZ2V0SGVhZGVyUHJvcHMucHVzaChnZXRIZWFkZXJQcm9wcyQxKTtcbiAgICBob29rcy5nZXRSb3dQcm9wcy5wdXNoKGdldFJvd1Byb3BzKTtcbiAgfVxuICB1c2VHcmlkTGF5b3V0LnBsdWdpbk5hbWUgPSAndXNlR3JpZExheW91dCc7XG5cbiAgdmFyIGdldFRhYmxlUHJvcHMkMSA9IGZ1bmN0aW9uIGdldFRhYmxlUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgIHZhciBncmlkVGVtcGxhdGVDb2x1bW5zID0gaW5zdGFuY2UudmlzaWJsZUNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIHZhciBfaW5zdGFuY2Ukc3RhdGUkY29sdW07XG5cbiAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5ncmlkTGF5b3V0LmNvbHVtbldpZHRoc1tjb2x1bW4uaWRdKSByZXR1cm4gaW5zdGFuY2Uuc3RhdGUuZ3JpZExheW91dC5jb2x1bW5XaWR0aHNbY29sdW1uLmlkXSArIFwicHhcIjsgLy8gV2hlbiByZXNpemluZywgbG9jayB0aGUgd2lkdGggb2YgYWxsIHVuc2V0IGNvbHVtbnNcbiAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgdXNlci1wcm92aWRlZCB3aWR0aCBvciBkZWZhdWx0Q29sdW1uIHdpZHRoLFxuICAgICAgLy8gd2hpY2ggY291bGQgcG90ZW50aWFsbHkgYmUgJ2F1dG8nIG9yICdmcicgdW5pdHMgdGhhdCBkb24ndCBzY2FsZSBsaW5lYXJseVxuXG4gICAgICBpZiAoKF9pbnN0YW5jZSRzdGF0ZSRjb2x1bSA9IGluc3RhbmNlLnN0YXRlLmNvbHVtblJlc2l6aW5nKSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHN0YXRlJGNvbHVtLmlzUmVzaXppbmdDb2x1bW4pIHJldHVybiBpbnN0YW5jZS5zdGF0ZS5ncmlkTGF5b3V0LnN0YXJ0V2lkdGhzW2NvbHVtbi5pZF0gKyBcInB4XCI7XG4gICAgICBpZiAodHlwZW9mIGNvbHVtbi53aWR0aCA9PT0gJ251bWJlcicpIHJldHVybiBjb2x1bW4ud2lkdGggKyBcInB4XCI7XG4gICAgICByZXR1cm4gY29sdW1uLndpZHRoO1xuICAgIH0pO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZ3JpZFwiLFxuICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBncmlkVGVtcGxhdGVDb2x1bW5zLmpvaW4oXCIgXCIpXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGdldEhlYWRlclByb3BzJDEgPSBmdW5jdGlvbiBnZXRIZWFkZXJQcm9wcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZjIuY29sdW1uO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIGlkOiBcImhlYWRlci1jZWxsLVwiICsgY29sdW1uLmlkLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgIC8vZW5hYmxlcyBhIHNjcm9sbCB3cmFwcGVyIHRvIGJlIHBsYWNlZCBhcm91bmQgdGhlIHRhYmxlIGFuZCBoYXZlIHN0aWNreSBoZWFkZXJzXG4gICAgICAgIGdyaWRDb2x1bW46IFwic3BhbiBcIiArIGNvbHVtbi50b3RhbFZpc2libGVIZWFkZXJDb3VudFxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRSb3dQcm9wcyA9IGZ1bmN0aW9uIGdldFJvd1Byb3BzKHByb3BzLCBfcmVmMykge1xuICAgIHZhciByb3cgPSBfcmVmMy5yb3c7XG5cbiAgICBpZiAocm93LmlzRXhwYW5kZWQpIHtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBncmlkQ29sdW1uOiBcIjEgLyBcIiArIChyb3cuY2VsbHMubGVuZ3RoICsgMSlcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtwcm9wcywge31dO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkYyhzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBncmlkTGF5b3V0OiB7XG4gICAgICAgICAgY29sdW1uV2lkdGhzOiB7fVxuICAgICAgICB9XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0UmVzaXplKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyaWRMYXlvdXQ6IHtcbiAgICAgICAgICBjb2x1bW5XaWR0aHM6IHt9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jb2x1bW5TdGFydFJlc2l6aW5nKSB7XG4gICAgICB2YXIgY29sdW1uSWQgPSBhY3Rpb24uY29sdW1uSWQsXG4gICAgICAgICAgaGVhZGVySWRXaWR0aHMgPSBhY3Rpb24uaGVhZGVySWRXaWR0aHM7XG4gICAgICB2YXIgY29sdW1uV2lkdGggPSBnZXRFbGVtZW50V2lkdGgoY29sdW1uSWQpO1xuXG4gICAgICBpZiAoY29sdW1uV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgc3RhcnRXaWR0aHMgPSBpbnN0YW5jZS52aXNpYmxlQ29sdW1ucy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY29sdW1uKSB7XG4gICAgICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltjb2x1bW4uaWRdID0gZ2V0RWxlbWVudFdpZHRoKGNvbHVtbi5pZCksIF9leHRlbmRzMikpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBtaW5XaWR0aHMgPSBpbnN0YW5jZS52aXNpYmxlQ29sdW1ucy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY29sdW1uKSB7XG4gICAgICAgICAgdmFyIF9leHRlbmRzMztcblxuICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCAoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tjb2x1bW4uaWRdID0gY29sdW1uLm1pbldpZHRoLCBfZXh0ZW5kczMpKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgbWF4V2lkdGhzID0gaW5zdGFuY2UudmlzaWJsZUNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikge1xuICAgICAgICAgIHZhciBfZXh0ZW5kczQ7XG5cbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzNCA9IHt9LCBfZXh0ZW5kczRbY29sdW1uLmlkXSA9IGNvbHVtbi5tYXhXaWR0aCwgX2V4dGVuZHM0KSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIGhlYWRlcklkR3JpZFdpZHRocyA9IGhlYWRlcklkV2lkdGhzLm1hcChmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgICB2YXIgaGVhZGVySWQgPSBfcmVmNFswXTtcbiAgICAgICAgICByZXR1cm4gW2hlYWRlcklkLCBnZXRFbGVtZW50V2lkdGgoaGVhZGVySWQpXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBncmlkTGF5b3V0OiBfZXh0ZW5kcyh7fSwgc3RhdGUuZ3JpZExheW91dCwge1xuICAgICAgICAgICAgc3RhcnRXaWR0aHM6IHN0YXJ0V2lkdGhzLFxuICAgICAgICAgICAgbWluV2lkdGhzOiBtaW5XaWR0aHMsXG4gICAgICAgICAgICBtYXhXaWR0aHM6IG1heFdpZHRocyxcbiAgICAgICAgICAgIGhlYWRlcklkR3JpZFdpZHRoczogaGVhZGVySWRHcmlkV2lkdGhzLFxuICAgICAgICAgICAgY29sdW1uV2lkdGg6IGNvbHVtbldpZHRoXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtblJlc2l6aW5nKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGFjdGlvbi5jbGllbnRYO1xuICAgICAgdmFyIHN0YXJ0WCA9IHN0YXRlLmNvbHVtblJlc2l6aW5nLnN0YXJ0WDtcblxuICAgICAgdmFyIF9zdGF0ZSRncmlkTGF5b3V0ID0gc3RhdGUuZ3JpZExheW91dCxcbiAgICAgICAgICBfY29sdW1uV2lkdGggPSBfc3RhdGUkZ3JpZExheW91dC5jb2x1bW5XaWR0aCxcbiAgICAgICAgICBfbWluV2lkdGhzID0gX3N0YXRlJGdyaWRMYXlvdXQubWluV2lkdGhzLFxuICAgICAgICAgIF9tYXhXaWR0aHMgPSBfc3RhdGUkZ3JpZExheW91dC5tYXhXaWR0aHMsXG4gICAgICAgICAgX3N0YXRlJGdyaWRMYXlvdXQkaGVhID0gX3N0YXRlJGdyaWRMYXlvdXQuaGVhZGVySWRHcmlkV2lkdGhzLFxuICAgICAgICAgIF9oZWFkZXJJZEdyaWRXaWR0aHMgPSBfc3RhdGUkZ3JpZExheW91dCRoZWEgPT09IHZvaWQgMCA/IFtdIDogX3N0YXRlJGdyaWRMYXlvdXQkaGVhO1xuXG4gICAgICB2YXIgZGVsdGFYID0gY2xpZW50WCAtIHN0YXJ0WDtcbiAgICAgIHZhciBwZXJjZW50YWdlRGVsdGFYID0gZGVsdGFYIC8gX2NvbHVtbldpZHRoO1xuICAgICAgdmFyIG5ld0NvbHVtbldpZHRocyA9IHt9O1xuXG4gICAgICBfaGVhZGVySWRHcmlkV2lkdGhzLmZvckVhY2goZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgIHZhciBoZWFkZXJJZCA9IF9yZWY1WzBdLFxuICAgICAgICAgICAgaGVhZGVyV2lkdGggPSBfcmVmNVsxXTtcbiAgICAgICAgbmV3Q29sdW1uV2lkdGhzW2hlYWRlcklkXSA9IE1hdGgubWluKE1hdGgubWF4KF9taW5XaWR0aHNbaGVhZGVySWRdLCBoZWFkZXJXaWR0aCArIGhlYWRlcldpZHRoICogcGVyY2VudGFnZURlbHRhWCksIF9tYXhXaWR0aHNbaGVhZGVySWRdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyaWRMYXlvdXQ6IF9leHRlbmRzKHt9LCBzdGF0ZS5ncmlkTGF5b3V0LCB7XG4gICAgICAgICAgY29sdW1uV2lkdGhzOiBfZXh0ZW5kcyh7fSwgc3RhdGUuZ3JpZExheW91dC5jb2x1bW5XaWR0aHMsIHt9LCBuZXdDb2x1bW5XaWR0aHMpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuY29sdW1uRG9uZVJlc2l6aW5nKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyaWRMYXlvdXQ6IF9leHRlbmRzKHt9LCBzdGF0ZS5ncmlkTGF5b3V0LCB7XG4gICAgICAgICAgc3RhcnRXaWR0aHM6IHt9LFxuICAgICAgICAgIG1pbldpZHRoczoge30sXG4gICAgICAgICAgbWF4V2lkdGhzOiB7fVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudFdpZHRoKGNvbHVtbklkKSB7XG4gICAgdmFyIF9kb2N1bWVudCRnZXRFbGVtZW50QjtcblxuICAgIHZhciB3aWR0aCA9IChfZG9jdW1lbnQkZ2V0RWxlbWVudEIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImhlYWRlci1jZWxsLVwiICsgY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2RvY3VtZW50JGdldEVsZW1lbnRCLm9mZnNldFdpZHRoO1xuXG4gICAgaWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLl9VTlNUQUJMRV91c2VQaXZvdENvbHVtbnMgPSBfVU5TVEFCTEVfdXNlUGl2b3RDb2x1bW5zO1xuICBleHBvcnRzLmFjdGlvbnMgPSBhY3Rpb25zO1xuICBleHBvcnRzLmRlZmF1bHRDb2x1bW4gPSBkZWZhdWx0Q29sdW1uO1xuICBleHBvcnRzLmRlZmF1bHRHcm91cEJ5Rm4gPSBkZWZhdWx0R3JvdXBCeUZuO1xuICBleHBvcnRzLmRlZmF1bHRPcmRlckJ5Rm4gPSBkZWZhdWx0T3JkZXJCeUZuO1xuICBleHBvcnRzLmRlZmF1bHRSZW5kZXJlciA9IGRlZmF1bHRSZW5kZXJlcjtcbiAgZXhwb3J0cy5lbXB0eVJlbmRlcmVyID0gZW1wdHlSZW5kZXJlcjtcbiAgZXhwb3J0cy5lbnN1cmVQbHVnaW5PcmRlciA9IGVuc3VyZVBsdWdpbk9yZGVyO1xuICBleHBvcnRzLmZsZXhSZW5kZXIgPSBmbGV4UmVuZGVyO1xuICBleHBvcnRzLmZ1bmN0aW9uYWxVcGRhdGUgPSBmdW5jdGlvbmFsVXBkYXRlO1xuICBleHBvcnRzLmxvb3BIb29rcyA9IGxvb3BIb29rcztcbiAgZXhwb3J0cy5tYWtlUHJvcEdldHRlciA9IG1ha2VQcm9wR2V0dGVyO1xuICBleHBvcnRzLm1ha2VSZW5kZXJlciA9IG1ha2VSZW5kZXJlcjtcbiAgZXhwb3J0cy5yZWR1Y2VIb29rcyA9IHJlZHVjZUhvb2tzO1xuICBleHBvcnRzLnNhZmVVc2VMYXlvdXRFZmZlY3QgPSBzYWZlVXNlTGF5b3V0RWZmZWN0O1xuICBleHBvcnRzLnVzZUFic29sdXRlTGF5b3V0ID0gdXNlQWJzb2x1dGVMYXlvdXQ7XG4gIGV4cG9ydHMudXNlQXN5bmNEZWJvdW5jZSA9IHVzZUFzeW5jRGVib3VuY2U7XG4gIGV4cG9ydHMudXNlQmxvY2tMYXlvdXQgPSB1c2VCbG9ja0xheW91dDtcbiAgZXhwb3J0cy51c2VDb2x1bW5PcmRlciA9IHVzZUNvbHVtbk9yZGVyO1xuICBleHBvcnRzLnVzZUV4cGFuZGVkID0gdXNlRXhwYW5kZWQ7XG4gIGV4cG9ydHMudXNlRmlsdGVycyA9IHVzZUZpbHRlcnM7XG4gIGV4cG9ydHMudXNlRmxleExheW91dCA9IHVzZUZsZXhMYXlvdXQ7XG4gIGV4cG9ydHMudXNlR2V0TGF0ZXN0ID0gdXNlR2V0TGF0ZXN0O1xuICBleHBvcnRzLnVzZUdsb2JhbEZpbHRlciA9IHVzZUdsb2JhbEZpbHRlcjtcbiAgZXhwb3J0cy51c2VHcmlkTGF5b3V0ID0gdXNlR3JpZExheW91dDtcbiAgZXhwb3J0cy51c2VHcm91cEJ5ID0gdXNlR3JvdXBCeTtcbiAgZXhwb3J0cy51c2VNb3VudGVkTGF5b3V0RWZmZWN0ID0gdXNlTW91bnRlZExheW91dEVmZmVjdDtcbiAgZXhwb3J0cy51c2VQYWdpbmF0aW9uID0gdXNlUGFnaW5hdGlvbjtcbiAgZXhwb3J0cy51c2VSZXNpemVDb2x1bW5zID0gdXNlUmVzaXplQ29sdW1ucztcbiAgZXhwb3J0cy51c2VSb3dTZWxlY3QgPSB1c2VSb3dTZWxlY3Q7XG4gIGV4cG9ydHMudXNlUm93U3RhdGUgPSB1c2VSb3dTdGF0ZTtcbiAgZXhwb3J0cy51c2VTb3J0QnkgPSB1c2VTb3J0Qnk7XG4gIGV4cG9ydHMudXNlVGFibGUgPSB1c2VUYWJsZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QtdGFibGUuZGV2ZWxvcG1lbnQuanMubWFwXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwic2VsZiIsIlJlYWN0VGFibGUiLCJSZWFjdCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsInJlc29sdmUiLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImFyZyIsImluZm8iLCJ2YWx1ZSIsImVycm9yIiwiZG9uZSIsIlByb21pc2UiLCJ0aGVuIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJmbiIsImFyZ3MiLCJhcmd1bWVudHMiLCJhcHBseSIsImVyciIsInVuZGVmaW5lZCIsIl9leHRlbmRzIiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImxlbmd0aCIsInNvdXJjZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwia2V5cyIsImluZGV4T2YiLCJfdG9QcmltaXRpdmUiLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJyZXMiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfdG9Qcm9wZXJ0eUtleSIsInJlbmRlckVyciIsImFjdGlvbnMiLCJpbml0IiwiZGVmYXVsdFJlbmRlcmVyIiwiX3JlZiIsIl9yZWYkdmFsdWUiLCJlbXB0eVJlbmRlcmVyIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiZGVmYXVsdENvbHVtbiIsIkNlbGwiLCJ3aWR0aCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJNQVhfU0FGRV9JTlRFR0VSIiwibWVyZ2VQcm9wcyIsIl9sZW4iLCJwcm9wTGlzdCIsIkFycmF5IiwiX2tleSIsInJlZHVjZSIsInByb3BzIiwibmV4dCIsInN0eWxlIiwiY2xhc3NOYW1lIiwicmVzdCIsImhhbmRsZVByb3BHZXR0ZXIiLCJwcmV2UHJvcHMiLCJ1c2VyUHJvcHMiLCJtZXRhIiwiaXNBcnJheSIsImNvbmNhdCIsIm1ha2VQcm9wR2V0dGVyIiwiaG9va3MiLCJwcmV2IiwicmVkdWNlSG9va3MiLCJpbml0aWFsIiwiYWxsb3dVbmRlZmluZWQiLCJuZXh0VmFsdWUiLCJjb25zb2xlIiwiRXJyb3IiLCJsb29wSG9va3MiLCJjb250ZXh0IiwiZm9yRWFjaCIsImhvb2siLCJlbnN1cmVQbHVnaW5PcmRlciIsInBsdWdpbnMiLCJiZWZvcmVzIiwicGx1Z2luTmFtZSIsImFmdGVycyIsInBsdWdpbkluZGV4IiwiZmluZEluZGV4IiwicGx1Z2luIiwiYmVmb3JlIiwiYmVmb3JlSW5kZXgiLCJmdW5jdGlvbmFsVXBkYXRlIiwidXBkYXRlciIsIm9sZCIsInVzZUdldExhdGVzdCIsIm9iaiIsInJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJ1c2VDYWxsYmFjayIsInNhZmVVc2VMYXlvdXRFZmZlY3QiLCJkb2N1bWVudCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZU1vdW50ZWRMYXlvdXRFZmZlY3QiLCJkZXBzIiwibW91bnRlZFJlZiIsInVzZUFzeW5jRGVib3VuY2UiLCJkZWZhdWx0Rm4iLCJkZWZhdWx0V2FpdCIsImRlYm91bmNlUmVmIiwiZ2V0RGVmYXVsdEZuIiwiZ2V0RGVmYXVsdFdhaXQiLCJfcmVmMiIsInJlZ2VuZXJhdG9yUnVudGltZSIsIm1hcmsiLCJfY2FsbGVlMiIsIl9sZW4yIiwiX2tleTIiLCJfYXJnczIiLCJ3cmFwIiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwicHJvbWlzZSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiX2NhbGxlZSIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJ0MCIsInQxIiwic2VudCIsInQyIiwiZmluaXNoIiwic3RvcCIsImFicnVwdCIsIm1ha2VSZW5kZXJlciIsImluc3RhbmNlIiwiY29sdW1uIiwidHlwZSIsIkNvbXAiLCJmbGV4UmVuZGVyIiwiaXNSZWFjdENvbXBvbmVudCIsImNvbXBvbmVudCIsImlzQ2xhc3NDb21wb25lbnQiLCJpc0V4b3RpY0NvbXBvbmVudCIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCIkJHR5cGVvZiIsImluY2x1ZGVzIiwiZGVzY3JpcHRpb24iLCJsaW5rQ29sdW1uU3RydWN0dXJlIiwiY29sdW1ucyIsInBhcmVudCIsImRlcHRoIiwibWFwIiwiYXNzaWduQ29sdW1uQWNjZXNzb3IiLCJmbGF0dGVuQ29sdW1ucyIsImZsYXR0ZW5CeSIsImlkIiwiYWNjZXNzb3IiLCJIZWFkZXIiLCJhY2Nlc3NvclBhdGgiLCJzcGxpdCIsInJvdyIsImdldEJ5IiwiZGVjb3JhdGVDb2x1bW4iLCJ1c2VyRGVmYXVsdENvbHVtbiIsIkZvb3RlciIsIm9yaWdpbmFsV2lkdGgiLCJtYWtlSGVhZGVyR3JvdXBzIiwiYWxsQ29sdW1ucyIsImFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzIiwiaGVhZGVyR3JvdXBzIiwic2NhbkNvbHVtbnMiLCJ1aWQiLCJnZXRVSUQiLCJfbG9vcCIsImhlYWRlckdyb3VwIiwiaGVhZGVycyIsInBhcmVudENvbHVtbnMiLCJoYXNQYXJlbnRzIiwic29tZSIsImQiLCJsYXRlc3RQYXJlbnRDb2x1bW4iLCJyZXZlcnNlIiwibmV3UGFyZW50Iiwib3JpZ2luYWxJZCIsInBsYWNlaG9sZGVyT2YiLCJwdXNoIiwicGF0aE9iakNhY2hlIiwiTWFwIiwicGF0aCIsImRlZiIsImNhY2hlS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsInBhdGhPYmoiLCJnZXQiLCJtYWtlUGF0aEFycmF5Iiwic2V0IiwidmFsIiwiY3Vyc29yIiwicGF0aFBhcnQiLCJlIiwiZ2V0Rmlyc3REZWZpbmVkIiwiaXNGdW5jdGlvbiIsImEiLCJhcnIiLCJmbGF0IiwicmVjdXJzZSIsImV4cGFuZFJvd3MiLCJyb3dzIiwibWFudWFsRXhwYW5kZWRLZXkiLCJleHBhbmRlZCIsIl9yZWYkZXhwYW5kU3ViUm93cyIsImV4cGFuZFN1YlJvd3MiLCJleHBhbmRlZFJvd3MiLCJoYW5kbGVSb3ciLCJhZGRUb0V4cGFuZGVkUm93cyIsImlzRXhwYW5kZWQiLCJvcmlnaW5hbCIsImNhbkV4cGFuZCIsInN1YlJvd3MiLCJnZXRGaWx0ZXJNZXRob2QiLCJmaWx0ZXIiLCJ1c2VyRmlsdGVyVHlwZXMiLCJmaWx0ZXJUeXBlcyIsInRleHQiLCJzaG91bGRBdXRvUmVtb3ZlRmlsdGVyIiwiYXV0b1JlbW92ZSIsInVucHJlcGFyZWRBY2Nlc3NXYXJuaW5nIiwicGFzc2l2ZVN1cHBvcnRlZCIsInBhc3NpdmVFdmVudFN1cHBvcnRlZCIsInN1cHBvcnRlZCIsIm9wdGlvbnMiLCJwYXNzaXZlIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZU9wZW5CcmFja2V0IiwicmVDbG9zZUJyYWNrZXQiLCJmbGF0dGVuRGVlcCIsInJlcGxhY2UiLCJqb2luIiwibmV3QXJyIiwiZGVmYXVsdEdldFRhYmxlUHJvcHMiLCJyb2xlIiwiZGVmYXVsdEdldFRhYmxlQm9keVByb3BzIiwiZGVmYXVsdEdldEhlYWRlclByb3BzIiwiY29sU3BhbiIsInRvdGFsVmlzaWJsZUhlYWRlckNvdW50IiwiZGVmYXVsdEdldEZvb3RlclByb3BzIiwiZGVmYXVsdEdldEhlYWRlckdyb3VwUHJvcHMiLCJfcmVmMyIsImluZGV4IiwiZGVmYXVsdEdldEZvb3Rlckdyb3VwUHJvcHMiLCJfcmVmNCIsImRlZmF1bHRHZXRSb3dQcm9wcyIsIl9yZWY1IiwiZGVmYXVsdEdldENlbGxQcm9wcyIsIl9yZWY2IiwiY2VsbCIsIm1ha2VEZWZhdWx0UGx1Z2luSG9va3MiLCJ1c2VPcHRpb25zIiwic3RhdGVSZWR1Y2VycyIsInVzZUNvbnRyb2xsZWRTdGF0ZSIsImNvbHVtbnNEZXBzIiwiYWxsQ29sdW1uc0RlcHMiLCJhY2Nlc3NWYWx1ZSIsIm1hdGVyaWFsaXplZENvbHVtbnMiLCJtYXRlcmlhbGl6ZWRDb2x1bW5zRGVwcyIsInVzZUluc3RhbmNlQWZ0ZXJEYXRhIiwidmlzaWJsZUNvbHVtbnMiLCJ2aXNpYmxlQ29sdW1uc0RlcHMiLCJoZWFkZXJHcm91cHNEZXBzIiwidXNlSW5zdGFuY2VCZWZvcmVEaW1lbnNpb25zIiwidXNlSW5zdGFuY2UiLCJwcmVwYXJlUm93IiwiZ2V0VGFibGVQcm9wcyIsImdldFRhYmxlQm9keVByb3BzIiwiZ2V0SGVhZGVyR3JvdXBQcm9wcyIsImdldEZvb3Rlckdyb3VwUHJvcHMiLCJnZXRIZWFkZXJQcm9wcyIsImdldEZvb3RlclByb3BzIiwiZ2V0Um93UHJvcHMiLCJnZXRDZWxsUHJvcHMiLCJ1c2VGaW5hbEluc3RhbmNlIiwicmVzZXRIaWRkZW5Db2x1bW5zIiwidG9nZ2xlSGlkZUNvbHVtbiIsInNldEhpZGRlbkNvbHVtbnMiLCJ0b2dnbGVIaWRlQWxsQ29sdW1ucyIsInVzZUNvbHVtblZpc2liaWxpdHkiLCJnZXRUb2dnbGVIaWRkZW5Qcm9wcyIsImRlZmF1bHRHZXRUb2dnbGVIaWRkZW5Qcm9wcyIsImdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMiLCJkZWZhdWx0R2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcyIsInJlZHVjZXIiLCJzdGF0ZSIsImhpZGRlbkNvbHVtbnMiLCJvbkNoYW5nZSIsInRvZ2dsZUhpZGRlbiIsImNoZWNrZWQiLCJpc1Zpc2libGUiLCJ0aXRsZSIsImFsbENvbHVtbnNIaWRkZW4iLCJpbmRldGVybWluYXRlIiwiYWN0aW9uIiwicHJldmlvdXNTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInNob3VsZCIsImNvbHVtbklkIiwic2hvdWxkQWxsIiwiaXNNb3VudGVkUmVmIiwiaGFuZGxlQ29sdW1uIiwicGFyZW50VmlzaWJsZSIsInN1YkNvbHVtbiIsInN1YkhlYWRlciIsImZsYXRIZWFkZXJzIiwiZGlzcGF0Y2giLCJnZXRIb29rcyIsIl9pbnN0YW5jZSRhdXRvUmVzZXRIaSIsImF1dG9SZXNldEhpZGRlbkNvbHVtbnMiLCJnZXRJbnN0YW5jZSIsImdldEF1dG9SZXNldEhpZGRlbkNvbHVtbnMiLCJkZWZhdWx0SW5pdGlhbFN0YXRlIiwiZGVmYXVsdENvbHVtbkluc3RhbmNlIiwiZGVmYXVsdFJlZHVjZXIiLCJwcmV2U3RhdGUiLCJkZWZhdWx0R2V0U3ViUm93cyIsImRlZmF1bHRHZXRSb3dJZCIsImRlZmF1bHRVc2VDb250cm9sbGVkU3RhdGUiLCJhcHBseURlZmF1bHRzIiwiX3Byb3BzJGluaXRpYWxTdGF0ZSIsIl9wcm9wcyRkZWZhdWx0Q29sdW1uIiwiX3Byb3BzJGdldFN1YlJvd3MiLCJnZXRTdWJSb3dzIiwiX3Byb3BzJGdldFJvd0lkIiwiZ2V0Um93SWQiLCJfcHJvcHMkc3RhdGVSZWR1Y2VyIiwic3RhdGVSZWR1Y2VyIiwiX3Byb3BzJHVzZUNvbnRyb2xsZWRTIiwidXNlVGFibGUiLCJpbnN0YW5jZVJlZiIsIkJvb2xlYW4iLCJfZ2V0SW5zdGFuY2UiLCJkYXRhIiwidXNlckNvbHVtbnMiLCJnZXRTdGF0ZVJlZHVjZXIiLCJzIiwiaGFuZGxlciIsIl9SZWFjdCR1c2VSZWR1Y2VyIiwidXNlUmVkdWNlciIsInJlZHVjZXJTdGF0ZSIsInVzZU1lbW8iLCJfUmVhY3QkdXNlTWVtbyIsImZsYXRSb3dzIiwicm93c0J5SWQiLCJhbGxDb2x1bW5zUXVldWUiLCJzaGlmdCIsImFjY2Vzc1Jvd3NGb3JDb2x1bW4iLCJhY2Nlc3NWYWx1ZUhvb2tzIiwiaW5pdGlhbFJvd3MiLCJmaW5kIiwiZHVwbGljYXRlQ29sdW1ucyIsImFsbCIsInZpc2libGVDb2x1bW5zRGVwIiwic29ydCIsIl9jYWxjdWxhdGVIZWFkZXJXaWR0aCIsImNhbGN1bGF0ZUhlYWRlcldpZHRocyIsInRvdGFsQ29sdW1uc01pbldpZHRoIiwidG90YWxDb2x1bW5zV2lkdGgiLCJ0b3RhbENvbHVtbnNNYXhXaWR0aCIsInJlbmRlciIsImZvb3Rlckdyb3VwcyIsImFsbENlbGxzIiwidmFsdWVzIiwiY2VsbHMiLCJsZWZ0Iiwic3VtVG90YWxNaW5XaWR0aCIsInN1bVRvdGFsV2lkdGgiLCJzdW1Ub3RhbE1heFdpZHRoIiwic3VtVG90YWxGbGV4V2lkdGgiLCJoZWFkZXIiLCJzdWJIZWFkZXJzIiwidG90YWxMZWZ0IiwiX2NhbGN1bGF0ZUhlYWRlcldpZHRoMiIsInRvdGFsTWluV2lkdGgiLCJ0b3RhbFdpZHRoIiwidG90YWxNYXhXaWR0aCIsInRvdGFsRmxleFdpZHRoIiwiTWF0aCIsIm1pbiIsIm1heCIsImNhblJlc2l6ZSIsImFjY2Vzc1JvdyIsIm9yaWdpbmFsUm93Iiwicm93SW5kZXgiLCJwYXJlbnRSb3dzIiwib3JpZ2luYWxTdWJSb3dzIiwicmVzZXRFeHBhbmRlZCIsInRvZ2dsZVJvd0V4cGFuZGVkIiwidG9nZ2xlQWxsUm93c0V4cGFuZGVkIiwidXNlRXhwYW5kZWQiLCJnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyIsImRlZmF1bHRHZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyIsImdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMiLCJkZWZhdWx0R2V0VG9nZ2xlUm93RXhwYW5kZWRQcm9wcyIsInJlZHVjZXIkMSIsInVzZUluc3RhbmNlJDEiLCJvbkNsaWNrIiwiaXNBbGxSb3dzRXhwYW5kZWQiLCJleHBhbmRBbGwiLCJyb3dJZCIsInNldEV4cGFuZGVkIiwiZXhpc3RzIiwic2hvdWxkRXhpc3QiLCJfZXh0ZW5kczIiLCJfc3RhdGUkZXhwYW5kZWQiLCJfIiwiX2luc3RhbmNlJG1hbnVhbEV4cGFuIiwiX2luc3RhbmNlJHBhZ2luYXRlRXhwIiwicGFnaW5hdGVFeHBhbmRlZFJvd3MiLCJfaW5zdGFuY2UkZXhwYW5kU3ViUm8iLCJfaW5zdGFuY2UkYXV0b1Jlc2V0RXgiLCJhdXRvUmVzZXRFeHBhbmRlZCIsImdldEF1dG9SZXNldEV4cGFuZGVkIiwiZXhwYW5kZWREZXB0aCIsImZpbmRFeHBhbmRlZERlcHRoIiwicHJlRXhwYW5kZWRSb3dzIiwibWF4RGVwdGgiLCJzcGxpdElkIiwiaWRzIiwiZmlsdGVyVmFsdWUiLCJyb3dWYWx1ZSIsInRvTG93ZXJDYXNlIiwiZXhhY3RUZXh0IiwiZXhhY3RUZXh0Q2FzZSIsImluY2x1ZGVzQWxsIiwiZXZlcnkiLCJpbmNsdWRlc1NvbWUiLCJpbmNsdWRlc1ZhbHVlIiwiZXhhY3QiLCJlcXVhbHMiLCJiZXR3ZWVuIiwiSW5maW5pdHkiLCJ0ZW1wIiwiZnJlZXplIiwiX19wcm90b19fIiwicmVzZXRGaWx0ZXJzIiwic2V0RmlsdGVyIiwic2V0QWxsRmlsdGVycyIsInVzZUZpbHRlcnMiLCJyZWR1Y2VyJDIiLCJ1c2VJbnN0YW5jZSQyIiwiZmlsdGVycyIsImZpbHRlck1ldGhvZCIsInByZXZpb3VzZmlsdGVyIiwibmV3RmlsdGVyIiwiX2FsbENvbHVtbnMiLCJfdXNlckZpbHRlclR5cGVzIiwibWFudWFsRmlsdGVycyIsIl9pbnN0YW5jZSRkZWZhdWx0Q2FuRiIsImRlZmF1bHRDYW5GaWx0ZXIiLCJkaXNhYmxlRmlsdGVycyIsIl9pbnN0YW5jZSRhdXRvUmVzZXRGaSIsImF1dG9SZXNldEZpbHRlcnMiLCJjb2x1bW5EZWZhdWx0Q2FuRmlsdGVyIiwiY29sdW1uRGlzYWJsZUZpbHRlcnMiLCJjYW5GaWx0ZXIiLCJmb3VuZCIsImZpbHRlcmVkRmxhdFJvd3MiLCJmaWx0ZXJlZFJvd3NCeUlkIiwiZmlsdGVyUm93cyIsImZpbHRlcmVkUm93cyIsImZpbHRlcmVkU29GYXIiLCJwcmVGaWx0ZXJlZFJvd3MiLCJ3YXJuIiwibm9uRmlsdGVyZWRDb2x1bW5zIiwiZ2V0QXV0b1Jlc2V0RmlsdGVycyIsInByZUZpbHRlcmVkRmxhdFJvd3MiLCJwcmVGaWx0ZXJlZFJvd3NCeUlkIiwicmVzZXRHbG9iYWxGaWx0ZXIiLCJzZXRHbG9iYWxGaWx0ZXIiLCJ1c2VHbG9iYWxGaWx0ZXIiLCJyZWR1Y2VyJDMiLCJ1c2VJbnN0YW5jZSQzIiwiZ2xvYmFsRmlsdGVyIiwic3RhdGVXaXRob3V0R2xvYmFsRmlsdGVyIiwibWFudWFsR2xvYmFsRmlsdGVyIiwiZ2xvYmFsRmlsdGVyVmFsdWUiLCJfaW5zdGFuY2UkYXV0b1Jlc2V0R2wiLCJhdXRvUmVzZXRHbG9iYWxGaWx0ZXIiLCJkaXNhYmxlR2xvYmFsRmlsdGVyIiwiY29sdW1uRGlzYWJsZUdsb2JhbEZpbHRlciIsImZpbHRlcmFibGVDb2x1bW5zIiwiYyIsImdsb2JhbEZpbHRlcmVkUm93cyIsImdsb2JhbEZpbHRlcmVkRmxhdFJvd3MiLCJnbG9iYWxGaWx0ZXJlZFJvd3NCeUlkIiwiZ2V0QXV0b1Jlc2V0R2xvYmFsRmlsdGVyIiwicHJlR2xvYmFsRmlsdGVyZWRSb3dzIiwicHJlR2xvYmFsRmlsdGVyZWRGbGF0Um93cyIsInByZUdsb2JhbEZpbHRlcmVkUm93c0J5SWQiLCJzdW0iLCJhZ2dyZWdhdGVkVmFsdWVzIiwibWluTWF4IiwiYXZlcmFnZSIsIm1lZGlhbiIsIm1pZCIsImZsb29yIiwibnVtcyIsImIiLCJ1bmlxdWUiLCJmcm9tIiwiU2V0IiwidW5pcXVlQ291bnQiLCJzaXplIiwiY291bnQiLCJhZ2dyZWdhdGlvbnMiLCJlbXB0eUFycmF5IiwiZW1wdHlPYmplY3QiLCJyZXNldEdyb3VwQnkiLCJzZXRHcm91cEJ5IiwidG9nZ2xlR3JvdXBCeSIsInVzZUdyb3VwQnkiLCJnZXRHcm91cEJ5VG9nZ2xlUHJvcHMiLCJkZWZhdWx0R2V0R3JvdXBCeVRvZ2dsZVByb3BzIiwicmVkdWNlciQ0IiwiZ3JvdXBCeSIsInVzZUluc3RhbmNlJDQiLCJwcmVwYXJlUm93JDEiLCJjYW5Hcm91cEJ5IiwicGVyc2lzdCIsInJlc29sdmVkR3JvdXBCeSIsImdyb3VwQnlDb2x1bW5zIiwiZyIsImNvbCIsIm5vbkdyb3VwQnlDb2x1bW5zIiwiaXNHcm91cGVkIiwiZ3JvdXBlZEluZGV4IiwiZGVmYXVsdFVzZXJBZ2dyZWdhdGlvbnMiLCJfaW5zdGFuY2UkZ3JvdXBCeUZuIiwiZ3JvdXBCeUZuIiwiZGVmYXVsdEdyb3VwQnlGbiIsIm1hbnVhbEdyb3VwQnkiLCJfaW5zdGFuY2UkYWdncmVnYXRpb24iLCJ1c2VyQWdncmVnYXRpb25zIiwiX2luc3RhbmNlJGF1dG9SZXNldEdyIiwiYXV0b1Jlc2V0R3JvdXBCeSIsImRpc2FibGVHcm91cEJ5IiwiZGVmYXVsdENhbkdyb3VwQnkiLCJkZWZhdWx0Q29sdW1uR3JvdXBCeSIsImRlZmF1bHRHcm91cEJ5IiwiY29sdW1uRGlzYWJsZUdyb3VwQnkiLCJBZ2dyZWdhdGVkIiwiZXhpc3RpbmdHcm91cEJ5IiwiYWdncmVnYXRlUm93c1RvVmFsdWVzIiwibGVhZlJvd3MiLCJncm91cGVkUm93cyIsImFnZ3JlZ2F0ZUZuIiwiYWdncmVnYXRlIiwiZ3JvdXBlZFZhbHVlcyIsImxlYWZWYWx1ZXMiLCJjb2x1bW5WYWx1ZSIsImFnZ3JlZ2F0ZVZhbHVlIiwiYWdncmVnYXRlVmFsdWVGbiIsImdyb3VwZWRGbGF0Um93cyIsImdyb3VwZWRSb3dzQnlJZCIsIm9ubHlHcm91cGVkRmxhdFJvd3MiLCJvbmx5R3JvdXBlZFJvd3NCeUlkIiwibm9uR3JvdXBlZEZsYXRSb3dzIiwibm9uR3JvdXBlZFJvd3NCeUlkIiwiZ3JvdXBVcFJlY3Vyc2l2ZWx5IiwicGFyZW50SWQiLCJyb3dHcm91cHNNYXAiLCJhZ2dyZWdhdGVkR3JvdXBlZFJvd3MiLCJlbnRyaWVzIiwiZ3JvdXBCeVZhbCIsImdyb3VwQnlJRCIsInN1YlJvdyIsImdldEF1dG9SZXNldEdyb3VwQnkiLCJwcmVHcm91cGVkUm93cyIsInByZUdyb3VwZWRGbGF0Um93IiwicHJlR3JvdXBlZFJvd3NCeUlkIiwiX3JvdyRzdWJSb3dzIiwiaXNQbGFjZWhvbGRlciIsImlzQWdncmVnYXRlZCIsInJlc0tleSIsInJlU3BsaXRBbHBoYU51bWVyaWMiLCJhbHBoYW51bWVyaWMiLCJyb3dBIiwicm93QiIsIl9nZXRSb3dWYWx1ZXNCeUNvbHVtbiIsImdldFJvd1ZhbHVlc0J5Q29sdW1uSUQiLCJ0b1N0cmluZyIsImFhIiwiYmIiLCJhbiIsInBhcnNlSW50IiwiYm4iLCJjb21ibyIsImlzTmFOIiwiZGF0ZXRpbWUiLCJfZ2V0Um93VmFsdWVzQnlDb2x1bW4yIiwiZ2V0VGltZSIsImNvbXBhcmVCYXNpYyIsImJhc2ljIiwiX2dldFJvd1ZhbHVlc0J5Q29sdW1uMyIsInN0cmluZyIsIl9nZXRSb3dWYWx1ZXNCeUNvbHVtbjQiLCJhbG93ZXIiLCJibG93ZXIiLCJudW1iZXIiLCJfZ2V0Um93VmFsdWVzQnlDb2x1bW41IiwicmVwbGFjZU5vbk51bWVyaWMiLCJyb3cxIiwicm93MiIsInNvcnRUeXBlcyIsInJlc2V0U29ydEJ5Iiwic2V0U29ydEJ5IiwidG9nZ2xlU29ydEJ5IiwiY2xlYXJTb3J0QnkiLCJzb3J0VHlwZSIsInNvcnREZXNjRmlyc3QiLCJ1c2VTb3J0QnkiLCJnZXRTb3J0QnlUb2dnbGVQcm9wcyIsImRlZmF1bHRHZXRTb3J0QnlUb2dnbGVQcm9wcyIsInJlZHVjZXIkNSIsInVzZUluc3RhbmNlJDUiLCJfaW5zdGFuY2UkaXNNdWx0aVNvcnQiLCJpc011bHRpU29ydEV2ZW50Iiwic2hpZnRLZXkiLCJjYW5Tb3J0IiwiZGlzYWJsZU11bHRpU29ydCIsInNvcnRCeSIsIm5ld1NvcnRCeSIsIl9zb3J0QnkiLCJkZXNjIiwibXVsdGkiLCJkaXNhYmxlU29ydFJlbW92ZSIsImRpc2FibGVNdWx0aVJlbW92ZSIsIl9pbnN0YW5jZSRtYXhNdWx0aVNvciIsIm1heE11bHRpU29ydENvbENvdW50IiwiX3NvcnRCeTIiLCJleGlzdGluZ1NvcnRCeSIsImV4aXN0aW5nSW5kZXgiLCJoYXNEZXNjRGVmaW5lZCIsIl9uZXdTb3J0QnkiLCJzb3J0QWN0aW9uIiwic3BsaWNlIiwiX2luc3RhbmNlJG9yZGVyQnlGbiIsIm9yZGVyQnlGbiIsImRlZmF1bHRPcmRlckJ5Rm4iLCJ1c2VyU29ydFR5cGVzIiwibWFudWFsU29ydEJ5IiwiZGVmYXVsdENhblNvcnQiLCJkaXNhYmxlU29ydEJ5IiwiX2luc3RhbmNlJGF1dG9SZXNldFNvIiwiYXV0b1Jlc2V0U29ydEJ5IiwiZGVmYXVsdENvbHVtbkNhblNvcnQiLCJjb2x1bW5EaXNhYmxlU29ydEJ5IiwiY29sdW1uU29ydCIsImlzU29ydGVkIiwic29ydGVkSW5kZXgiLCJpc1NvcnRlZERlc2MiLCJzb3J0ZWRGbGF0Um93cyIsImF2YWlsYWJsZVNvcnRCeSIsInNvcnREYXRhIiwic29ydGVkRGF0YSIsInNvcnRNZXRob2QiLCJzb3J0SW52ZXJ0ZWQiLCJzb3J0ZWRSb3dzIiwiZ2V0QXV0b1Jlc2V0U29ydEJ5IiwicHJlU29ydGVkUm93cyIsInByZVNvcnRlZEZsYXRSb3dzIiwiZnVuY3MiLCJkaXJzIiwic29ydEZuIiwic29ydEludCIsInJlc2V0UGFnZSIsImdvdG9QYWdlIiwic2V0UGFnZVNpemUiLCJ1c2VQYWdpbmF0aW9uIiwicmVkdWNlciQ2IiwidXNlSW5zdGFuY2UkNiIsInBhZ2VTaXplIiwicGFnZUluZGV4IiwicGFnZUNvdW50IiwicGFnZSIsIm5ld1BhZ2VJbmRleCIsImNhbk5hdmlnYXRlIiwidG9wUm93SW5kZXgiLCJfaW5zdGFuY2UkYXV0b1Jlc2V0UGEiLCJhdXRvUmVzZXRQYWdlIiwidXNlclBhZ2VDb3VudCIsIl9pbnN0YW5jZSRzdGF0ZSIsIm1hbnVhbFBhZ2luYXRpb24iLCJnZXRBdXRvUmVzZXRQYWdlIiwiY2VpbCIsInBhZ2VPcHRpb25zIiwiZmlsbCIsInBhZ2VTdGFydCIsInBhZ2VFbmQiLCJzbGljZSIsImNhblByZXZpb3VzUGFnZSIsImNhbk5leHRQYWdlIiwicHJldmlvdXNQYWdlIiwibmV4dFBhZ2UiLCJyZXNldFBpdm90IiwidG9nZ2xlUGl2b3QiLCJfVU5TVEFCTEVfdXNlUGl2b3RDb2x1bW5zIiwiZ2V0UGl2b3RUb2dnbGVQcm9wcyIsImRlZmF1bHRHZXRQaXZvdFRvZ2dsZVByb3BzIiwicmVkdWNlciQ3IiwidmlzaWJsZUNvbHVtbnMkMSIsInVzZUluc3RhbmNlJDciLCJwcmVwYXJlUm93JDIiLCJkZWZhdWx0UGl2b3RDb2x1bW5zIiwiY2FuUGl2b3QiLCJwaXZvdENvbHVtbnMiLCJzZXRQaXZvdCIsInJlc29sdmVkUGl2b3QiLCJpc1Bpdm90U291cmNlIiwidW5pcXVlVmFsdWVzIiwiYWRkIiwibWF0ZXJpYWxpemVkIiwic291cmNlQ29sdW1ucyIsImJ1aWxkUGl2b3RDb2x1bW5zIiwicGl2b3RGaWx0ZXJzIiwicGl2b3RDb2x1bW4iLCJzb3VyY2VDb2x1bW4iLCJpc1Bpdm90ZWQiLCJ1bmlxdWVWYWx1ZSIsImNvbHVtbkdyb3VwIiwiUGl2b3RIZWFkZXIiLCJpc1Bpdm90R3JvdXAiLCJwaXZvdFZhbHVlIiwibmV3TWF0ZXJpYWxpemVkIiwiX3JlZjUkaW5zdGFuY2Ukc3RhdGUiLCJfcmVmNyIsIl9pbnN0YW5jZSRhdXRvUmVzZXRQaSIsImF1dG9SZXNldFBpdm90IiwibWFuYXVsUGl2b3QiLCJkaXNhYmxlUGl2b3QiLCJkZWZhdWx0Q2FuUGl2b3QiLCJkZWZhdWx0Q29sdW1uUGl2b3QiLCJkZWZhdWx0UGl2b3QiLCJjb2x1bW5EaXNhYmxlUGl2b3QiLCJnZXRBdXRvUmVzZXRQaXZvdCIsInBsdWdpbk5hbWUkMSIsInJlc2V0U2VsZWN0ZWRSb3dzIiwidG9nZ2xlQWxsUm93c1NlbGVjdGVkIiwidG9nZ2xlUm93U2VsZWN0ZWQiLCJ0b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkIiwidXNlUm93U2VsZWN0IiwiZ2V0VG9nZ2xlUm93U2VsZWN0ZWRQcm9wcyIsImRlZmF1bHRHZXRUb2dnbGVSb3dTZWxlY3RlZFByb3BzIiwiZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMiLCJkZWZhdWx0R2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMiLCJnZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHMiLCJkZWZhdWx0R2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzIiwicmVkdWNlciQ4IiwidXNlSW5zdGFuY2UkOCIsInByZXBhcmVSb3ckMyIsIl9pbnN0YW5jZSRtYW51YWxSb3dTZSIsIm1hbnVhbFJvd1NlbGVjdGVkS2V5IiwiaXNTZWxlY3RlZCIsImlzU29tZVNlbGVjdGVkIiwiaXNBbGxSb3dzU2VsZWN0ZWQiLCJzZWxlY3RlZFJvd0lkcyIsImlzQWxsUGFnZVJvd3NTZWxlY3RlZCIsInNldFNlbGVjdGVkIiwiX2luc3RhbmNlJG5vbkdyb3VwZWRSIiwic2VsZWN0QWxsIiwiX3NldFNlbGVjdGVkIiwiX3Jvd3NCeUlkIiwiX2luc3RhbmNlJHNlbGVjdFN1YlJvIiwic2VsZWN0U3ViUm93cyIsIm5ld1NlbGVjdGVkUm93SWRzIiwiaGFuZGxlUm93QnlJZCIsIl9zZXRTZWxlY3RlZDIiLCJfcm93c0J5SWQyIiwiX2luc3RhbmNlJHNlbGVjdFN1YlJvMiIsIl9zZWxlY3RTdWJSb3dzIiwiX2dldFN1YlJvd3MiLCJfc2VsZWN0QWxsIiwiX25ld1NlbGVjdGVkUm93SWRzIiwiX2hhbmRsZVJvd0J5SWQiLCJfaW5zdGFuY2Ukbm9uR3JvdXBlZFIyIiwiX2luc3RhbmNlJGF1dG9SZXNldFNlIiwiYXV0b1Jlc2V0U2VsZWN0ZWRSb3dzIiwiX2luc3RhbmNlJHNlbGVjdFN1YlJvMyIsInNlbGVjdGVkRmxhdFJvd3MiLCJnZXRSb3dJc1NlbGVjdGVkIiwiZ2V0QXV0b1Jlc2V0U2VsZWN0ZWRSb3dzIiwiYWxsQ2hpbGRyZW5TZWxlY3RlZCIsInNvbWVTZWxlY3RlZCIsImRlZmF1bHRJbml0aWFsUm93U3RhdGVBY2Nlc3NvciIsImRlZmF1bHRJbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IiLCJzZXRSb3dTdGF0ZSIsInNldENlbGxTdGF0ZSIsInJlc2V0Um93U3RhdGUiLCJ1c2VSb3dTdGF0ZSIsInJlZHVjZXIkOSIsInVzZUluc3RhbmNlJDkiLCJwcmVwYXJlUm93JDQiLCJfaW5zdGFuY2UkaW5pdGlhbFJvd1MiLCJpbml0aWFsUm93U3RhdGVBY2Nlc3NvciIsIl9pbnN0YW5jZSRpbml0aWFsQ2VsbCIsImluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciIsInJvd1N0YXRlIiwib2xkUm93U3RhdGUiLCJfb2xkUm93U3RhdGUkY2VsbFN0YXQiLCJfcm93c0J5SWQkX3Jvd0lkIiwiX3Jvd3NCeUlkJF9yb3dJZCRjZWxsIiwiX2V4dGVuZHMzIiwiX2V4dGVuZHM0IiwiX3Jvd0lkIiwiX3ZhbHVlIiwiX29sZFJvd1N0YXRlIiwib2xkQ2VsbFN0YXRlIiwiY2VsbFN0YXRlIiwiX2luc3RhbmNlJGF1dG9SZXNldFJvIiwiYXV0b1Jlc2V0Um93U3RhdGUiLCJnZXRBdXRvUmVzZXRSb3dTdGF0ZSIsIl9pbnN0YW5jZSRpbml0aWFsUm93UzIiLCJfaW5zdGFuY2UkaW5pdGlhbENlbGwyIiwic2V0U3RhdGUiLCJyZXNldENvbHVtbk9yZGVyIiwic2V0Q29sdW1uT3JkZXIiLCJ1c2VDb2x1bW5PcmRlciIsInJlZHVjZXIkYSIsImNvbHVtbk9yZGVyIiwidmlzaWJsZUNvbHVtbnMkMiIsInVzZUluc3RhbmNlJGEiLCJjb2x1bW5PcmRlckNvcHkiLCJjb2x1bW5zQ29weSIsImNvbHVtbnNJbk9yZGVyIiwidGFyZ2V0Q29sdW1uSWQiLCJmb3VuZEluZGV4IiwiY29sdW1uU3RhcnRSZXNpemluZyIsImNvbHVtblJlc2l6aW5nIiwiY29sdW1uRG9uZVJlc2l6aW5nIiwicmVzZXRSZXNpemUiLCJ1c2VSZXNpemVDb2x1bW5zIiwiZ2V0UmVzaXplclByb3BzIiwiZGVmYXVsdEdldFJlc2l6ZXJQcm9wcyIsInBvc2l0aW9uIiwicmVkdWNlciRiIiwidXNlSW5zdGFuY2UkYiIsInVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyQxIiwib25SZXNpemVTdGFydCIsImlzVG91Y2hFdmVudCIsInRvdWNoZXMiLCJoZWFkZXJzVG9SZXNpemUiLCJnZXRMZWFmSGVhZGVycyIsImhlYWRlcklkV2lkdGhzIiwiY2xpZW50WCIsInJvdW5kIiwicmFmIiwibW9zdFJlY2VudENsaWVudFgiLCJkaXNwYXRjaEVuZCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZGlzcGF0Y2hNb3ZlIiwic2NoZWR1bGVEaXNwYXRjaE1vdmVPbk5leHRBbmltYXRpb25GcmFtZSIsImNsaWVudFhQb3MiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVyc0FuZEV2ZW50cyIsIm1vdXNlIiwibW92ZUV2ZW50IiwibW92ZUhhbmRsZXIiLCJ1cEV2ZW50IiwidXBIYW5kbGVyIiwidG91Y2giLCJjYW5jZWxhYmxlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJldmVudHMiLCJwYXNzaXZlSWZTdXBwb3J0ZWQiLCJjb2x1bW5XaWR0aCIsIm9uTW91c2VEb3duIiwib25Ub3VjaFN0YXJ0IiwiZHJhZ2dhYmxlIiwiY29sdW1uV2lkdGhzIiwic3RhcnRYIiwiaXNSZXNpemluZ0NvbHVtbiIsIl9jbGllbnRYIiwiX3N0YXRlJGNvbHVtblJlc2l6aW5nIiwiX2NvbHVtbldpZHRoIiwiX3N0YXRlJGNvbHVtblJlc2l6aW5nMiIsIl9oZWFkZXJJZFdpZHRocyIsImRlbHRhWCIsInBlcmNlbnRhZ2VEZWx0YVgiLCJuZXdDb2x1bW5XaWR0aHMiLCJoZWFkZXJJZCIsImhlYWRlcldpZHRoIiwiZGlzYWJsZVJlc2l6aW5nIiwiaXNSZXNpemluZyIsIl9pbnN0YW5jZSRhdXRvUmVzZXRSZSIsImF1dG9SZXNldFJlc2l6ZSIsImdldEF1dG9SZXNldFJlc2l6ZSIsInJlc2V0UmVzaXppbmciLCJsZWFmSGVhZGVycyIsInJlY3Vyc2VIZWFkZXIiLCJjZWxsU3R5bGVzIiwidG9wIiwidXNlQWJzb2x1dGVMYXlvdXQiLCJnZXRSb3dTdHlsZXMiLCJjZWxsU3R5bGVzJDEiLCJkaXNwbGF5IiwiYm94U2l6aW5nIiwiZ2V0Um93U3R5bGVzJDEiLCJ1c2VCbG9ja0xheW91dCIsInVzZUZsZXhMYXlvdXQiLCJnZXRSb3dTdHlsZXMkMiIsImZsZXgiLCJ1c2VHcmlkTGF5b3V0IiwicmVkdWNlciRjIiwiZ2V0VGFibGVQcm9wcyQxIiwiZ2V0SGVhZGVyUHJvcHMkMSIsImdyaWRUZW1wbGF0ZUNvbHVtbnMiLCJfaW5zdGFuY2Ukc3RhdGUkY29sdW0iLCJncmlkTGF5b3V0Iiwic3RhcnRXaWR0aHMiLCJncmlkQ29sdW1uIiwiZ2V0RWxlbWVudFdpZHRoIiwiYWNjIiwibWluV2lkdGhzIiwibWF4V2lkdGhzIiwiaGVhZGVySWRHcmlkV2lkdGhzIiwiX3N0YXRlJGdyaWRMYXlvdXQiLCJfbWluV2lkdGhzIiwiX21heFdpZHRocyIsIl9zdGF0ZSRncmlkTGF5b3V0JGhlYSIsIl9oZWFkZXJJZEdyaWRXaWR0aHMiLCJfZG9jdW1lbnQkZ2V0RWxlbWVudEIiLCJnZXRFbGVtZW50QnlJZCIsIm9mZnNldFdpZHRoIiwiZGVmaW5lUHJvcGVydHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-table/dist/react-table.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-table/index.js":
/*!*******************************************!*\
  !*** ./node_modules/react-table/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./dist/react-table.development.js */ \"(ssr)/./node_modules/react-table/dist/react-table.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFibGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyxpSkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC10YWJsZS1kZW1vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRhYmxlL2luZGV4LmpzPzM5MDciXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvcmVhY3QtdGFibGUucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvcmVhY3QtdGFibGUuZGV2ZWxvcG1lbnQuanMnKVxufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-table/index.js\n");

/***/ })

};
;